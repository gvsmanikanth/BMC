(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.noscope = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
/*
#
# Opentip v2.4.6
#
# More info at [www.opentip.org](http://www.opentip.org)
# 
# Copyright (c) 2012, Matias Meno  
# Graphics by Tjandra Mayerhold
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
*/

var Opentip, firstAdapter, i, mouseMoved, mousePosition, mousePositionObservers, position, vendors, _i, _len, _ref,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty;

Opentip = (function() {

  Opentip.prototype.STICKS_OUT_TOP = 1;

  Opentip.prototype.STICKS_OUT_BOTTOM = 2;

  Opentip.prototype.STICKS_OUT_LEFT = 1;

  Opentip.prototype.STICKS_OUT_RIGHT = 2;

  Opentip.prototype["class"] = {
    container: "opentip-container",
    opentip: "opentip",
    header: "ot-header",
    content: "ot-content",
    loadingIndicator: "ot-loading-indicator",
    close: "ot-close",
    goingToHide: "ot-going-to-hide",
    hidden: "ot-hidden",
    hiding: "ot-hiding",
    goingToShow: "ot-going-to-show",
    showing: "ot-showing",
    visible: "ot-visible",
    loading: "ot-loading",
    ajaxError: "ot-ajax-error",
    fixed: "ot-fixed",
    showEffectPrefix: "ot-show-effect-",
    hideEffectPrefix: "ot-hide-effect-",
    stylePrefix: "style-"
  };

  function Opentip(element, content, title, options) {
    var elementsOpentips, hideTrigger, methodToBind, optionSources, prop, styleName, _i, _j, _len, _len1, _ref, _ref1, _ref2, _tmpStyle,
      _this = this;
    this.id = ++Opentip.lastId;
    this.debug("Creating Opentip.");
    Opentip.tips.push(this);
    this.adapter = Opentip.adapter;
    elementsOpentips = this.adapter.data(element, "opentips") || [];
    elementsOpentips.push(this);
    this.adapter.data(element, "opentips", elementsOpentips);
    this.triggerElement = this.adapter.wrap(element);
    if (this.triggerElement.length > 1) {
      throw new Error("You can't call Opentip on multiple elements.");
    }
    if (this.triggerElement.length < 1) {
      throw new Error("Invalid element.");
    }
    this.loaded = false;
    this.loading = false;
    this.visible = false;
    this.waitingToShow = false;
    this.waitingToHide = false;
    this.currentPosition = {
      left: 0,
      top: 0
    };
    this.dimensions = {
      width: 100,
      height: 50
    };
    this.content = "";
    this.redraw = true;
    this.currentObservers = {
      showing: false,
      visible: false,
      hiding: false,
      hidden: false
    };
    options = this.adapter.clone(options);
    if (typeof content === "object") {
      options = content;
      content = title = void 0;
    } else if (typeof title === "object") {
      options = title;
      title = void 0;
    }
    if (title != null) {
      options.title = title;
    }
    if (content != null) {
      this.setContent(content);
    }
    if (options["extends"] == null) {
      if (options.style != null) {
        options["extends"] = options.style;
      } else {
        options["extends"] = Opentip.defaultStyle;
      }
    }
    optionSources = [options];
    _tmpStyle = options;
    while (_tmpStyle["extends"]) {
      styleName = _tmpStyle["extends"];
      _tmpStyle = Opentip.styles[styleName];
      if (_tmpStyle == null) {
        throw new Error("Invalid style: " + styleName);
      }
      optionSources.unshift(_tmpStyle);
      if (!((_tmpStyle["extends"] != null) || styleName === "standard")) {
        _tmpStyle["extends"] = "standard";
      }
    }
    options = (_ref = this.adapter).extend.apply(_ref, [{}].concat(__slice.call(optionSources)));
    options.hideTriggers = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = options.hideTriggers;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        hideTrigger = _ref1[_i];
        _results.push(hideTrigger);
      }
      return _results;
    })();
    if (options.hideTrigger && options.hideTriggers.length === 0) {
      options.hideTriggers.push(options.hideTrigger);
    }
    _ref1 = ["tipJoint", "targetJoint", "stem"];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      prop = _ref1[_i];
      if (options[prop] && typeof options[prop] === "string") {
        options[prop] = new Opentip.Joint(options[prop]);
      }
    }
    if (options.ajax && (options.ajax === true || !options.ajax)) {
      if (this.adapter.tagName(this.triggerElement) === "A") {
        options.ajax = this.adapter.attr(this.triggerElement, "href");
      } else {
        options.ajax = false;
      }
    }
    if (options.showOn === "click" && this.adapter.tagName(this.triggerElement) === "A") {
      this.adapter.observe(this.triggerElement, "click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        return e.stopped = true;
      });
    }
    if (options.target) {
      options.fixed = true;
    }
    if (options.stem === true) {
      options.stem = new Opentip.Joint(options.tipJoint);
    }
    if (options.target === true) {
      options.target = this.triggerElement;
    } else if (options.target) {
      options.target = this.adapter.wrap(options.target);
    }
    this.currentStem = options.stem;
    if (options.delay == null) {
      options.delay = options.showOn === "mouseover" ? 0.2 : 0;
    }
    if (options.targetJoint == null) {
      options.targetJoint = new Opentip.Joint(options.tipJoint).flip();
    }
    this.showTriggers = [];
    this.showTriggersWhenVisible = [];
    this.hideTriggers = [];
    if (options.showOn && options.showOn !== "creation") {
      this.showTriggers.push({
        element: this.triggerElement,
        event: options.showOn
      });
    }
    if (options.ajaxCache != null) {
      options.cache = options.ajaxCache;
      delete options.ajaxCache;
    }
    this.options = options;
    this.bound = {};
    _ref2 = ["prepareToShow", "prepareToHide", "show", "hide", "reposition"];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      methodToBind = _ref2[_j];
      this.bound[methodToBind] = (function(methodToBind) {
        return function() {
          return _this[methodToBind].apply(_this, arguments);
        };
      })(methodToBind);
    }
    this.adapter.domReady(function() {
      _this.activate();
      if (_this.options.showOn === "creation") {
        return _this.prepareToShow();
      }
    });
  }

  Opentip.prototype._setup = function() {
    var hideOn, hideTrigger, hideTriggerElement, i, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.debug("Setting up the tooltip.");
    this._buildContainer();
    this.hideTriggers = [];
    _ref = this.options.hideTriggers;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      hideTrigger = _ref[i];
      hideTriggerElement = null;
      hideOn = this.options.hideOn instanceof Array ? this.options.hideOn[i] : this.options.hideOn;
      if (typeof hideTrigger === "string") {
        switch (hideTrigger) {
          case "trigger":
            hideOn = hideOn || "mouseout";
            hideTriggerElement = this.triggerElement;
            break;
          case "tip":
            hideOn = hideOn || "mouseover";
            hideTriggerElement = this.container;
            break;
          case "target":
            hideOn = hideOn || "mouseover";
            hideTriggerElement = this.options.target;
            break;
          case "closeButton":
            break;
          default:
            throw new Error("Unknown hide trigger: " + hideTrigger + ".");
        }
      } else {
        hideOn = hideOn || "mouseover";
        hideTriggerElement = this.adapter.wrap(hideTrigger);
      }
      if (hideTriggerElement) {
        this.hideTriggers.push({
          element: hideTriggerElement,
          event: hideOn,
          original: hideTrigger
        });
      }
    }
    _ref1 = this.hideTriggers;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      hideTrigger = _ref1[_j];
      _results.push(this.showTriggersWhenVisible.push({
        element: hideTrigger.element,
        event: "mouseover"
      }));
    }
    return _results;
  };

  Opentip.prototype._buildContainer = function() {
    this.container = this.adapter.create("<div id=\"opentip-" + this.id + "\" class=\"" + this["class"].container + " " + this["class"].hidden + " " + this["class"].stylePrefix + this.options.className + "\"></div>");
    this.adapter.css(this.container, {
      position: "absolute"
    });
    if (this.options.ajax) {
      this.adapter.addClass(this.container, this["class"].loading);
    }
    if (this.options.fixed) {
      this.adapter.addClass(this.container, this["class"].fixed);
    }
    if (this.options.showEffect) {
      this.adapter.addClass(this.container, "" + this["class"].showEffectPrefix + this.options.showEffect);
    }
    if (this.options.hideEffect) {
      return this.adapter.addClass(this.container, "" + this["class"].hideEffectPrefix + this.options.hideEffect);
    }
  };

  Opentip.prototype._buildElements = function() {
    var headerElement, titleElement;
    this.tooltipElement = this.adapter.create("<div class=\"" + this["class"].opentip + "\"><div class=\"" + this["class"].header + "\"></div><div class=\"" + this["class"].content + "\"></div></div>");
    this.backgroundCanvas = this.adapter.wrap(document.createElement("canvas"));
    this.adapter.css(this.backgroundCanvas, {
      position: "absolute"
    });
    if (typeof G_vmlCanvasManager !== "undefined" && G_vmlCanvasManager !== null) {
      G_vmlCanvasManager.initElement(this.adapter.unwrap(this.backgroundCanvas));
    }
    headerElement = this.adapter.find(this.tooltipElement, "." + this["class"].header);
    if (this.options.title) {
      titleElement = this.adapter.create("<h1></h1>");
      this.adapter.update(titleElement, this.options.title, this.options.escapeTitle);
      this.adapter.append(headerElement, titleElement);
    }
    if (this.options.ajax && !this.loaded) {
      this.adapter.append(this.tooltipElement, this.adapter.create("<div class=\"" + this["class"].loadingIndicator + "\"><span>↻</span></div>"));
    }
    if (__indexOf.call(this.options.hideTriggers, "closeButton") >= 0) {
      this.closeButtonElement = this.adapter.create("<a href=\"javascript:undefined;\" class=\"" + this["class"].close + "\"><span>Close</span></a>");
      this.adapter.append(headerElement, this.closeButtonElement);
    }
    this.adapter.append(this.container, this.backgroundCanvas);
    this.adapter.append(this.container, this.tooltipElement);
    this.adapter.append(document.body, this.container);
    this._newContent = true;
    return this.redraw = true;
  };

  Opentip.prototype.setContent = function(content) {
    this.content = content;
    this._newContent = true;
    if (typeof this.content === "function") {
      this._contentFunction = this.content;
      this.content = "";
    } else {
      this._contentFunction = null;
    }
    if (this.visible) {
      return this._updateElementContent();
    }
  };

  Opentip.prototype._updateElementContent = function() {
    var contentDiv;
    if (this._newContent || (!this.options.cache && this._contentFunction)) {
      contentDiv = this.adapter.find(this.container, "." + this["class"].content);
      if (contentDiv != null) {
        if (this._contentFunction) {
          this.debug("Executing content function.");
          this.content = this._contentFunction(this);
        }
        this.adapter.update(contentDiv, this.content, this.options.escapeContent);
      }
      this._newContent = false;
    }
    this._storeAndLockDimensions();
    return this.reposition();
  };

  Opentip.prototype._storeAndLockDimensions = function() {
    var prevDimension;
    if (!this.container) {
      return;
    }
    prevDimension = this.dimensions;
    this.adapter.css(this.container, {
      width: "auto",
      left: "0px",
      top: "0px"
    });
    this.dimensions = this.adapter.dimensions(this.container);
    this.dimensions.width += 1;
    this.adapter.css(this.container, {
      width: "" + this.dimensions.width + "px",
      top: "" + this.currentPosition.top + "px",
      left: "" + this.currentPosition.left + "px"
    });
    if (!this._dimensionsEqual(this.dimensions, prevDimension)) {
      this.redraw = true;
      return this._draw();
    }
  };

  Opentip.prototype.activate = function() {
    return this._setupObservers("hidden", "hiding");
  };

  Opentip.prototype.deactivate = function() {
    this.debug("Deactivating tooltip.");
    this.hide();
    return this._setupObservers("-showing", "-visible", "-hidden", "-hiding");
  };

  Opentip.prototype._setupObservers = function() {
    var observeOrStop, removeObserver, state, states, trigger, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2,
      _this = this;
    states = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = states.length; _i < _len; _i++) {
      state = states[_i];
      removeObserver = false;
      if (state.charAt(0) === "-") {
        removeObserver = true;
        state = state.substr(1);
      }
      if (this.currentObservers[state] === !removeObserver) {
        continue;
      }
      this.currentObservers[state] = !removeObserver;
      observeOrStop = function() {
        var args, _ref, _ref1;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (removeObserver) {
          return (_ref = _this.adapter).stopObserving.apply(_ref, args);
        } else {
          return (_ref1 = _this.adapter).observe.apply(_ref1, args);
        }
      };
      switch (state) {
        case "showing":
          _ref = this.hideTriggers;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            trigger = _ref[_j];
            observeOrStop(trigger.element, trigger.event, this.bound.prepareToHide);
          }
          observeOrStop((document.onresize != null ? document : window), "resize", this.bound.reposition);
          observeOrStop(window, "scroll", this.bound.reposition);
          break;
        case "visible":
          _ref1 = this.showTriggersWhenVisible;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            trigger = _ref1[_k];
            observeOrStop(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          break;
        case "hiding":
          _ref2 = this.showTriggers;
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            trigger = _ref2[_l];
            observeOrStop(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          break;
        case "hidden":
          break;
        default:
          throw new Error("Unknown state: " + state);
      }
    }
    return null;
  };

  Opentip.prototype.prepareToShow = function() {
    this._abortHiding();
    this._abortShowing();
    if (this.visible) {
      return;
    }
    this.debug("Showing in " + this.options.delay + "s.");
    if (this.container == null) {
      this._setup();
    }
    if (this.options.group) {
      Opentip._abortShowingGroup(this.options.group, this);
    }
    this.preparingToShow = true;
    this._setupObservers("-hidden", "-hiding", "showing");
    this._followMousePosition();
    if (this.options.fixed && !this.options.target) {
      this.initialMousePosition = mousePosition;
    }
    this.reposition();
    return this._showTimeoutId = this.setTimeout(this.bound.show, this.options.delay || 0);
  };

  Opentip.prototype.show = function() {
    var _this = this;
    this._abortHiding();
    if (this.visible) {
      return;
    }
    this._clearTimeouts();
    if (!this._triggerElementExists()) {
      return this.deactivate();
    }
    this.debug("Showing now.");
    if (this.container == null) {
      this._setup();
    }
    if (this.options.group) {
      Opentip._hideGroup(this.options.group, this);
    }
    this.visible = true;
    this.preparingToShow = false;
    if (this.tooltipElement == null) {
      this._buildElements();
    }
    this._updateElementContent();
    if (this.options.ajax && (!this.loaded || !this.options.cache)) {
      this._loadAjax();
    }
    this._searchAndActivateCloseButtons();
    this._startEnsureTriggerElement();
    this.adapter.css(this.container, {
      zIndex: Opentip.lastZIndex++
    });
    this._setupObservers("-hidden", "-hiding", "-showing", "-visible", "showing", "visible");
    if (this.options.fixed && !this.options.target) {
      this.initialMousePosition = mousePosition;
    }
    this.reposition();
    this.adapter.removeClass(this.container, this["class"].hiding);
    this.adapter.removeClass(this.container, this["class"].hidden);
    this.adapter.addClass(this.container, this["class"].goingToShow);
    this.setCss3Style(this.container, {
      transitionDuration: "0s"
    });
    this.defer(function() {
      var delay;
      if (!_this.visible || _this.preparingToHide) {
        return;
      }
      _this.adapter.removeClass(_this.container, _this["class"].goingToShow);
      _this.adapter.addClass(_this.container, _this["class"].showing);
      delay = 0;
      if (_this.options.showEffect && _this.options.showEffectDuration) {
        delay = _this.options.showEffectDuration;
      }
      _this.setCss3Style(_this.container, {
        transitionDuration: "" + delay + "s"
      });
      _this._visibilityStateTimeoutId = _this.setTimeout(function() {
        _this.adapter.removeClass(_this.container, _this["class"].showing);
        return _this.adapter.addClass(_this.container, _this["class"].visible);
      }, delay);
      return _this._activateFirstInput();
    });
    return this._draw();
  };

  Opentip.prototype._abortShowing = function() {
    if (this.preparingToShow) {
      this.debug("Aborting showing.");
      this._clearTimeouts();
      this._stopFollowingMousePosition();
      this.preparingToShow = false;
      return this._setupObservers("-showing", "-visible", "hiding", "hidden");
    }
  };

  Opentip.prototype.prepareToHide = function() {
    this._abortShowing();
    this._abortHiding();
    if (!this.visible) {
      return;
    }
    this.debug("Hiding in " + this.options.hideDelay + "s");
    this.preparingToHide = true;
    this._setupObservers("-showing", "visible", "-hidden", "hiding");
    return this._hideTimeoutId = this.setTimeout(this.bound.hide, this.options.hideDelay);
  };

  Opentip.prototype.hide = function() {
    var _this = this;
    this._abortShowing();
    if (!this.visible) {
      return;
    }
    this._clearTimeouts();
    this.debug("Hiding!");
    this.visible = false;
    this.preparingToHide = false;
    this._stopEnsureTriggerElement();
    this._setupObservers("-showing", "-visible", "-hiding", "-hidden", "hiding", "hidden");
    if (!this.options.fixed) {
      this._stopFollowingMousePosition();
    }
    if (!this.container) {
      return;
    }
    this.adapter.removeClass(this.container, this["class"].visible);
    this.adapter.removeClass(this.container, this["class"].showing);
    this.adapter.addClass(this.container, this["class"].goingToHide);
    this.setCss3Style(this.container, {
      transitionDuration: "0s"
    });
    return this.defer(function() {
      var hideDelay;
      _this.adapter.removeClass(_this.container, _this["class"].goingToHide);
      _this.adapter.addClass(_this.container, _this["class"].hiding);
      hideDelay = 0;
      if (_this.options.hideEffect && _this.options.hideEffectDuration) {
        hideDelay = _this.options.hideEffectDuration;
      }
      _this.setCss3Style(_this.container, {
        transitionDuration: "" + hideDelay + "s"
      });
      return _this._visibilityStateTimeoutId = _this.setTimeout(function() {
        _this.adapter.removeClass(_this.container, _this["class"].hiding);
        _this.adapter.addClass(_this.container, _this["class"].hidden);
        _this.setCss3Style(_this.container, {
          transitionDuration: "0s"
        });
        if (_this.options.removeElementsOnHide) {
          _this.debug("Removing HTML elements.");
          _this.adapter.remove(_this.container);
          delete _this.container;
          return delete _this.tooltipElement;
        }
      }, hideDelay);
    });
  };

  Opentip.prototype._abortHiding = function() {
    if (this.preparingToHide) {
      this.debug("Aborting hiding.");
      this._clearTimeouts();
      this.preparingToHide = false;
      return this._setupObservers("-hiding", "showing", "visible");
    }
  };

  Opentip.prototype.reposition = function() {
    var position, stem, _ref,
      _this = this;
    position = this.getPosition();
    if (position == null) {
      return;
    }
    stem = this.options.stem;
    if (this.options.containInViewport) {
      _ref = this._ensureViewportContainment(position), position = _ref.position, stem = _ref.stem;
    }
    if (this._positionsEqual(position, this.currentPosition)) {
      return;
    }
    if (!(!this.options.stem || stem.eql(this.currentStem))) {
      this.redraw = true;
    }
    this.currentPosition = position;
    this.currentStem = stem;
    this._draw();
    this.adapter.css(this.container, {
      left: "" + position.left + "px",
      top: "" + position.top + "px"
    });
    return this.defer(function() {
      var rawContainer, redrawFix;
      rawContainer = _this.adapter.unwrap(_this.container);
      rawContainer.style.visibility = "hidden";
      redrawFix = rawContainer.offsetHeight;
      return rawContainer.style.visibility = "visible";
    });
  };

  Opentip.prototype.getPosition = function(tipJoint, targetJoint, stem) {
    var additionalHorizontal, additionalVertical, offsetDistance, position, stemLength, targetDimensions, targetPosition, unwrappedTarget, _ref;
    if (!this.container) {
      return;
    }
    if (tipJoint == null) {
      tipJoint = this.options.tipJoint;
    }
    if (targetJoint == null) {
      targetJoint = this.options.targetJoint;
    }
    position = {};
    if (this.options.target) {
      targetPosition = this.adapter.offset(this.options.target);
      targetDimensions = this.adapter.dimensions(this.options.target);
      position = targetPosition;
      if (targetJoint.right) {
        unwrappedTarget = this.adapter.unwrap(this.options.target);
        if (unwrappedTarget.getBoundingClientRect != null) {
          position.left = unwrappedTarget.getBoundingClientRect().right + ((_ref = window.pageXOffset) != null ? _ref : document.body.scrollLeft);
        } else {
          position.left += targetDimensions.width;
        }
      } else if (targetJoint.center) {
        position.left += Math.round(targetDimensions.width / 2);
      }
      if (targetJoint.bottom) {
        position.top += targetDimensions.height;
      } else if (targetJoint.middle) {
        position.top += Math.round(targetDimensions.height / 2);
      }
      if (this.options.borderWidth) {
        if (this.options.tipJoint.left) {
          position.left += this.options.borderWidth;
        }
        if (this.options.tipJoint.right) {
          position.left -= this.options.borderWidth;
        }
        if (this.options.tipJoint.top) {
          position.top += this.options.borderWidth;
        } else if (this.options.tipJoint.bottom) {
          position.top -= this.options.borderWidth;
        }
      }
    } else {
      if (this.initialMousePosition) {
        position = {
          top: this.initialMousePosition.y,
          left: this.initialMousePosition.x
        };
      } else {
        position = {
          top: mousePosition.y,
          left: mousePosition.x
        };
      }
    }
    if (this.options.autoOffset) {
      stemLength = this.options.stem ? this.options.stemLength : 0;
      offsetDistance = stemLength && this.options.fixed ? 2 : 10;
      additionalHorizontal = tipJoint.middle && !this.options.fixed ? 15 : 0;
      additionalVertical = tipJoint.center && !this.options.fixed ? 15 : 0;
      if (tipJoint.right) {
        position.left -= offsetDistance + additionalHorizontal;
      } else if (tipJoint.left) {
        position.left += offsetDistance + additionalHorizontal;
      }
      if (tipJoint.bottom) {
        position.top -= offsetDistance + additionalVertical;
      } else if (tipJoint.top) {
        position.top += offsetDistance + additionalVertical;
      }
      if (stemLength) {
        if (stem == null) {
          stem = this.options.stem;
        }
        if (stem.right) {
          position.left -= stemLength;
        } else if (stem.left) {
          position.left += stemLength;
        }
        if (stem.bottom) {
          position.top -= stemLength;
        } else if (stem.top) {
          position.top += stemLength;
        }
      }
    }
    position.left += this.options.offset[0];
    position.top += this.options.offset[1];
    if (tipJoint.right) {
      position.left -= this.dimensions.width;
    } else if (tipJoint.center) {
      position.left -= Math.round(this.dimensions.width / 2);
    }
    if (tipJoint.bottom) {
      position.top -= this.dimensions.height;
    } else if (tipJoint.middle) {
      position.top -= Math.round(this.dimensions.height / 2);
    }
    return position;
  };

  Opentip.prototype._ensureViewportContainment = function(position) {
    var needsRepositioning, newSticksOut, originals, revertedX, revertedY, scrollOffset, stem, sticksOut, targetJoint, tipJoint, viewportDimensions, viewportPosition;
    stem = this.options.stem;
    originals = {
      position: position,
      stem: stem
    };
    if (!(this.visible && position)) {
      return originals;
    }
    sticksOut = this._sticksOut(position);
    if (!(sticksOut[0] || sticksOut[1])) {
      return originals;
    }
    tipJoint = new Opentip.Joint(this.options.tipJoint);
    if (this.options.targetJoint) {
      targetJoint = new Opentip.Joint(this.options.targetJoint);
    }
    scrollOffset = this.adapter.scrollOffset();
    viewportDimensions = this.adapter.viewportDimensions();
    viewportPosition = [position.left - scrollOffset[0], position.top - scrollOffset[1]];
    needsRepositioning = false;
    if (viewportDimensions.width >= this.dimensions.width) {
      if (sticksOut[0]) {
        needsRepositioning = true;
        switch (sticksOut[0]) {
          case this.STICKS_OUT_LEFT:
            tipJoint.setHorizontal("left");
            if (this.options.targetJoint) {
              targetJoint.setHorizontal("right");
            }
            break;
          case this.STICKS_OUT_RIGHT:
            tipJoint.setHorizontal("right");
            if (this.options.targetJoint) {
              targetJoint.setHorizontal("left");
            }
        }
      }
    }
    if (viewportDimensions.height >= this.dimensions.height) {
      if (sticksOut[1]) {
        needsRepositioning = true;
        switch (sticksOut[1]) {
          case this.STICKS_OUT_TOP:
            tipJoint.setVertical("top");
            if (this.options.targetJoint) {
              targetJoint.setVertical("bottom");
            }
            break;
          case this.STICKS_OUT_BOTTOM:
            tipJoint.setVertical("bottom");
            if (this.options.targetJoint) {
              targetJoint.setVertical("top");
            }
        }
      }
    }
    if (!needsRepositioning) {
      return originals;
    }
    if (this.options.stem) {
      stem = tipJoint;
    }
    position = this.getPosition(tipJoint, targetJoint, stem);
    newSticksOut = this._sticksOut(position);
    revertedX = false;
    revertedY = false;
    if (newSticksOut[0] && (newSticksOut[0] !== sticksOut[0])) {
      revertedX = true;
      tipJoint.setHorizontal(this.options.tipJoint.horizontal);
      if (this.options.targetJoint) {
        targetJoint.setHorizontal(this.options.targetJoint.horizontal);
      }
    }
    if (newSticksOut[1] && (newSticksOut[1] !== sticksOut[1])) {
      revertedY = true;
      tipJoint.setVertical(this.options.tipJoint.vertical);
      if (this.options.targetJoint) {
        targetJoint.setVertical(this.options.targetJoint.vertical);
      }
    }
    if (revertedX && revertedY) {
      return originals;
    }
    if (revertedX || revertedY) {
      if (this.options.stem) {
        stem = tipJoint;
      }
      position = this.getPosition(tipJoint, targetJoint, stem);
    }
    return {
      position: position,
      stem: stem
    };
  };

  Opentip.prototype._sticksOut = function(position) {
    var positionOffset, scrollOffset, sticksOut, viewportDimensions;
    scrollOffset = this.adapter.scrollOffset();
    viewportDimensions = this.adapter.viewportDimensions();
    positionOffset = [position.left - scrollOffset[0], position.top - scrollOffset[1]];
    sticksOut = [false, false];
    if (positionOffset[0] < 0) {
      sticksOut[0] = this.STICKS_OUT_LEFT;
    } else if (positionOffset[0] + this.dimensions.width > viewportDimensions.width) {
      sticksOut[0] = this.STICKS_OUT_RIGHT;
    }
    if (positionOffset[1] < 0) {
      sticksOut[1] = this.STICKS_OUT_TOP;
    } else if (positionOffset[1] + this.dimensions.height > viewportDimensions.height) {
      sticksOut[1] = this.STICKS_OUT_BOTTOM;
    }
    return sticksOut;
  };

  Opentip.prototype._draw = function() {
    var backgroundCanvas, bulge, canvasDimensions, canvasPosition, closeButton, closeButtonInner, closeButtonOuter, ctx, drawCorner, drawLine, hb, position, stemBase, stemLength, _i, _len, _ref, _ref1, _ref2,
      _this = this;
    if (!(this.backgroundCanvas && this.redraw)) {
      return;
    }
    this.debug("Drawing background.");
    this.redraw = false;
    if (this.currentStem) {
      _ref = ["top", "right", "bottom", "left"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        position = _ref[_i];
        this.adapter.removeClass(this.container, "stem-" + position);
      }
      this.adapter.addClass(this.container, "stem-" + this.currentStem.horizontal);
      this.adapter.addClass(this.container, "stem-" + this.currentStem.vertical);
    }
    closeButtonInner = [0, 0];
    closeButtonOuter = [0, 0];
    if (__indexOf.call(this.options.hideTriggers, "closeButton") >= 0) {
      closeButton = new Opentip.Joint(((_ref1 = this.currentStem) != null ? _ref1.toString() : void 0) === "top right" ? "top left" : "top right");
      closeButtonInner = [this.options.closeButtonRadius + this.options.closeButtonOffset[0], this.options.closeButtonRadius + this.options.closeButtonOffset[1]];
      closeButtonOuter = [this.options.closeButtonRadius - this.options.closeButtonOffset[0], this.options.closeButtonRadius - this.options.closeButtonOffset[1]];
    }
    canvasDimensions = this.adapter.clone(this.dimensions);
    canvasPosition = [0, 0];
    if (this.options.borderWidth) {
      canvasDimensions.width += this.options.borderWidth * 2;
      canvasDimensions.height += this.options.borderWidth * 2;
      canvasPosition[0] -= this.options.borderWidth;
      canvasPosition[1] -= this.options.borderWidth;
    }
    if (this.options.shadow) {
      canvasDimensions.width += this.options.shadowBlur * 2;
      canvasDimensions.width += Math.max(0, this.options.shadowOffset[0] - this.options.shadowBlur * 2);
      canvasDimensions.height += this.options.shadowBlur * 2;
      canvasDimensions.height += Math.max(0, this.options.shadowOffset[1] - this.options.shadowBlur * 2);
      canvasPosition[0] -= Math.max(0, this.options.shadowBlur - this.options.shadowOffset[0]);
      canvasPosition[1] -= Math.max(0, this.options.shadowBlur - this.options.shadowOffset[1]);
    }
    bulge = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    if (this.currentStem) {
      if (this.currentStem.left) {
        bulge.left = this.options.stemLength;
      } else if (this.currentStem.right) {
        bulge.right = this.options.stemLength;
      }
      if (this.currentStem.top) {
        bulge.top = this.options.stemLength;
      } else if (this.currentStem.bottom) {
        bulge.bottom = this.options.stemLength;
      }
    }
    if (closeButton) {
      if (closeButton.left) {
        bulge.left = Math.max(bulge.left, closeButtonOuter[0]);
      } else if (closeButton.right) {
        bulge.right = Math.max(bulge.right, closeButtonOuter[0]);
      }
      if (closeButton.top) {
        bulge.top = Math.max(bulge.top, closeButtonOuter[1]);
      } else if (closeButton.bottom) {
        bulge.bottom = Math.max(bulge.bottom, closeButtonOuter[1]);
      }
    }
    canvasDimensions.width += bulge.left + bulge.right;
    canvasDimensions.height += bulge.top + bulge.bottom;
    canvasPosition[0] -= bulge.left;
    canvasPosition[1] -= bulge.top;
    if (this.currentStem && this.options.borderWidth) {
      _ref2 = this._getPathStemMeasures(this.options.stemBase, this.options.stemLength, this.options.borderWidth), stemLength = _ref2.stemLength, stemBase = _ref2.stemBase;
    }
    backgroundCanvas = this.adapter.unwrap(this.backgroundCanvas);
    backgroundCanvas.width = canvasDimensions.width;
    backgroundCanvas.height = canvasDimensions.height;
    this.adapter.css(this.backgroundCanvas, {
      width: "" + backgroundCanvas.width + "px",
      height: "" + backgroundCanvas.height + "px",
      left: "" + canvasPosition[0] + "px",
      top: "" + canvasPosition[1] + "px"
    });
    ctx = backgroundCanvas.getContext("2d");
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
    ctx.beginPath();
    ctx.fillStyle = this._getColor(ctx, this.dimensions, this.options.background, this.options.backgroundGradientHorizontal);
    ctx.lineJoin = "miter";
    ctx.miterLimit = 500;
    hb = this.options.borderWidth / 2;
    if (this.options.borderWidth) {
      ctx.strokeStyle = this.options.borderColor;
      ctx.lineWidth = this.options.borderWidth;
    } else {
      stemLength = this.options.stemLength;
      stemBase = this.options.stemBase;
    }
    if (stemBase == null) {
      stemBase = 0;
    }
    drawLine = function(length, stem, first) {
      if (first) {
        ctx.moveTo(Math.max(stemBase, _this.options.borderRadius, closeButtonInner[0]) + 1 - hb, -hb);
      }
      if (stem) {
        ctx.lineTo(length / 2 - stemBase / 2, -hb);
        ctx.lineTo(length / 2, -stemLength - hb);
        return ctx.lineTo(length / 2 + stemBase / 2, -hb);
      }
    };
    drawCorner = function(stem, closeButton, i) {
      var angle1, angle2, innerWidth, offset;
      if (stem) {
        ctx.lineTo(-stemBase + hb, 0 - hb);
        ctx.lineTo(stemLength + hb, -stemLength - hb);
        return ctx.lineTo(hb, stemBase - hb);
      } else if (closeButton) {
        offset = _this.options.closeButtonOffset;
        innerWidth = closeButtonInner[0];
        if (i % 2 !== 0) {
          offset = [offset[1], offset[0]];
          innerWidth = closeButtonInner[1];
        }
        angle1 = Math.acos(offset[1] / _this.options.closeButtonRadius);
        angle2 = Math.acos(offset[0] / _this.options.closeButtonRadius);
        ctx.lineTo(-innerWidth + hb, -hb);
        return ctx.arc(hb - offset[0], -hb + offset[1], _this.options.closeButtonRadius, -(Math.PI / 2 + angle1), angle2, false);
      } else {
        ctx.lineTo(-_this.options.borderRadius + hb, -hb);
        return ctx.quadraticCurveTo(hb, -hb, hb, _this.options.borderRadius - hb);
      }
    };
    ctx.translate(-canvasPosition[0], -canvasPosition[1]);
    ctx.save();
    (function() {
      var cornerStem, i, lineLength, lineStem, positionIdx, positionX, positionY, rotation, _j, _ref3, _results;
      _results = [];
      for (i = _j = 0, _ref3 = Opentip.positions.length / 2; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        positionIdx = i * 2;
        positionX = i === 0 || i === 3 ? 0 : _this.dimensions.width;
        positionY = i < 2 ? 0 : _this.dimensions.height;
        rotation = (Math.PI / 2) * i;
        lineLength = i % 2 === 0 ? _this.dimensions.width : _this.dimensions.height;
        lineStem = new Opentip.Joint(Opentip.positions[positionIdx]);
        cornerStem = new Opentip.Joint(Opentip.positions[positionIdx + 1]);
        ctx.save();
        ctx.translate(positionX, positionY);
        ctx.rotate(rotation);
        drawLine(lineLength, lineStem.eql(_this.currentStem), i === 0);
        ctx.translate(lineLength, 0);
        drawCorner(cornerStem.eql(_this.currentStem), cornerStem.eql(closeButton), i);
        _results.push(ctx.restore());
      }
      return _results;
    })();
    ctx.closePath();
    ctx.save();
    if (this.options.shadow) {
      ctx.shadowColor = this.options.shadowColor;
      ctx.shadowBlur = this.options.shadowBlur;
      ctx.shadowOffsetX = this.options.shadowOffset[0];
      ctx.shadowOffsetY = this.options.shadowOffset[1];
    }
    ctx.fill();
    ctx.restore();
    if (this.options.borderWidth) {
      ctx.stroke();
    }
    ctx.restore();
    if (closeButton) {
      return (function() {
        var crossCenter, crossHeight, crossWidth, hcs, linkCenter;
        crossWidth = crossHeight = _this.options.closeButtonRadius * 2;
        if (closeButton.toString() === "top right") {
          linkCenter = [_this.dimensions.width - _this.options.closeButtonOffset[0], _this.options.closeButtonOffset[1]];
          crossCenter = [linkCenter[0] + hb, linkCenter[1] - hb];
        } else {
          linkCenter = [_this.options.closeButtonOffset[0], _this.options.closeButtonOffset[1]];
          crossCenter = [linkCenter[0] - hb, linkCenter[1] - hb];
        }
        ctx.translate(crossCenter[0], crossCenter[1]);
        hcs = _this.options.closeButtonCrossSize / 2;
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = _this.options.closeButtonCrossColor;
        ctx.lineWidth = _this.options.closeButtonCrossLineWidth;
        ctx.lineCap = "round";
        ctx.moveTo(-hcs, -hcs);
        ctx.lineTo(hcs, hcs);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(hcs, -hcs);
        ctx.lineTo(-hcs, hcs);
        ctx.stroke();
        ctx.restore();
        return _this.adapter.css(_this.closeButtonElement, {
          left: "" + (linkCenter[0] - hcs - _this.options.closeButtonLinkOverscan) + "px",
          top: "" + (linkCenter[1] - hcs - _this.options.closeButtonLinkOverscan) + "px",
          width: "" + (_this.options.closeButtonCrossSize + _this.options.closeButtonLinkOverscan * 2) + "px",
          height: "" + (_this.options.closeButtonCrossSize + _this.options.closeButtonLinkOverscan * 2) + "px"
        });
      })();
    }
  };

  Opentip.prototype._getPathStemMeasures = function(outerStemBase, outerStemLength, borderWidth) {
    var angle, distanceBetweenTips, halfAngle, hb, rhombusSide, stemBase, stemLength;
    hb = borderWidth / 2;
    halfAngle = Math.atan((outerStemBase / 2) / outerStemLength);
    angle = halfAngle * 2;
    rhombusSide = hb / Math.sin(angle);
    distanceBetweenTips = 2 * rhombusSide * Math.cos(halfAngle);
    stemLength = hb + outerStemLength - distanceBetweenTips;
    if (stemLength < 0) {
      throw new Error("Sorry but your stemLength / stemBase ratio is strange.");
    }
    stemBase = (Math.tan(halfAngle) * stemLength) * 2;
    return {
      stemLength: stemLength,
      stemBase: stemBase
    };
  };

  Opentip.prototype._getColor = function(ctx, dimensions, color, horizontal) {
    var colorStop, gradient, i, _i, _len;
    if (horizontal == null) {
      horizontal = false;
    }
    if (typeof color === "string") {
      return color;
    }
    if (horizontal) {
      gradient = ctx.createLinearGradient(0, 0, dimensions.width, 0);
    } else {
      gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);
    }
    for (i = _i = 0, _len = color.length; _i < _len; i = ++_i) {
      colorStop = color[i];
      gradient.addColorStop(colorStop[0], colorStop[1]);
    }
    return gradient;
  };

  Opentip.prototype._searchAndActivateCloseButtons = function() {
    var element, _i, _len, _ref;
    _ref = this.adapter.findAll(this.container, "." + this["class"].close);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      this.hideTriggers.push({
        element: this.adapter.wrap(element),
        event: "click"
      });
    }
    if (this.currentObservers.showing) {
      this._setupObservers("-showing", "showing");
    }
    if (this.currentObservers.visible) {
      return this._setupObservers("-visible", "visible");
    }
  };

  Opentip.prototype._activateFirstInput = function() {
    var input;
    input = this.adapter.unwrap(this.adapter.find(this.container, "input, textarea"));
    return input != null ? typeof input.focus === "function" ? input.focus() : void 0 : void 0;
  };

  Opentip.prototype._followMousePosition = function() {
    if (!this.options.fixed) {
      return Opentip._observeMousePosition(this.bound.reposition);
    }
  };

  Opentip.prototype._stopFollowingMousePosition = function() {
    if (!this.options.fixed) {
      return Opentip._stopObservingMousePosition(this.bound.reposition);
    }
  };

  Opentip.prototype._clearShowTimeout = function() {
    return clearTimeout(this._showTimeoutId);
  };

  Opentip.prototype._clearHideTimeout = function() {
    return clearTimeout(this._hideTimeoutId);
  };

  Opentip.prototype._clearTimeouts = function() {
    clearTimeout(this._visibilityStateTimeoutId);
    this._clearShowTimeout();
    return this._clearHideTimeout();
  };

  Opentip.prototype._triggerElementExists = function() {
    var el;
    el = this.adapter.unwrap(this.triggerElement);
    while (el.parentNode) {
      if (el.parentNode.tagName === "BODY") {
        return true;
      }
      el = el.parentNode;
    }
    return false;
  };

  Opentip.prototype._loadAjax = function() {
    var _this = this;
    if (this.loading) {
      return;
    }
    this.loaded = false;
    this.loading = true;
    this.adapter.addClass(this.container, this["class"].loading);
    this.setContent("");
    this.debug("Loading content from " + this.options.ajax);
    return this.adapter.ajax({
      url: this.options.ajax,
      method: this.options.ajaxMethod,
      onSuccess: function(responseText) {
        _this.debug("Loading successful.");
        _this.adapter.removeClass(_this.container, _this["class"].loading);
        return _this.setContent(responseText);
      },
      onError: function(error) {
        var message;
        message = _this.options.ajaxErrorMessage;
        _this.debug(message, error);
        _this.setContent(message);
        return _this.adapter.addClass(_this.container, _this["class"].ajaxError);
      },
      onComplete: function() {
        _this.adapter.removeClass(_this.container, _this["class"].loading);
        _this.loading = false;
        _this.loaded = true;
        _this._searchAndActivateCloseButtons();
        _this._activateFirstInput();
        return _this.reposition();
      }
    });
  };

  Opentip.prototype._ensureTriggerElement = function() {
    if (!this._triggerElementExists()) {
      this.deactivate();
      return this._stopEnsureTriggerElement();
    }
  };

  Opentip.prototype._ensureTriggerElementInterval = 1000;

  Opentip.prototype._startEnsureTriggerElement = function() {
    var _this = this;
    return this._ensureTriggerElementTimeoutId = setInterval((function() {
      return _this._ensureTriggerElement();
    }), this._ensureTriggerElementInterval);
  };

  Opentip.prototype._stopEnsureTriggerElement = function() {
    return clearInterval(this._ensureTriggerElementTimeoutId);
  };

  return Opentip;

})();

vendors = ["khtml", "ms", "o", "moz", "webkit"];

Opentip.prototype.setCss3Style = function(element, styles) {
  var prop, value, vendor, vendorProp, _results;
  element = this.adapter.unwrap(element);
  _results = [];
  for (prop in styles) {
    if (!__hasProp.call(styles, prop)) continue;
    value = styles[prop];
    if (element.style[prop] != null) {
      _results.push(element.style[prop] = value);
    } else {
      _results.push((function() {
        var _i, _len, _results1;
        _results1 = [];
        for (_i = 0, _len = vendors.length; _i < _len; _i++) {
          vendor = vendors[_i];
          vendorProp = "" + (this.ucfirst(vendor)) + (this.ucfirst(prop));
          if (element.style[vendorProp] != null) {
            _results1.push(element.style[vendorProp] = value);
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      }).call(this));
    }
  }
  return _results;
};

Opentip.prototype.defer = function(func) {
  return setTimeout(func, 0);
};

Opentip.prototype.setTimeout = function(func, seconds) {
  return setTimeout(func, seconds ? seconds * 1000 : 0);
};

Opentip.prototype.ucfirst = function(string) {
  if (string == null) {
    return "";
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
};

Opentip.prototype.dasherize = function(string) {
  return string.replace(/([A-Z])/g, function(_, character) {
    return "-" + (character.toLowerCase());
  });
};

mousePositionObservers = [];

mousePosition = {
  x: 0,
  y: 0
};

mouseMoved = function(e) {
  var observer, _i, _len, _results;
  mousePosition = Opentip.adapter.mousePosition(e);
  _results = [];
  for (_i = 0, _len = mousePositionObservers.length; _i < _len; _i++) {
    observer = mousePositionObservers[_i];
    _results.push(observer());
  }
  return _results;
};

Opentip.followMousePosition = function() {
  return Opentip.adapter.observe(document.body, "mousemove", mouseMoved);
};

Opentip._observeMousePosition = function(observer) {
  return mousePositionObservers.push(observer);
};

Opentip._stopObservingMousePosition = function(removeObserver) {
  var observer;
  return mousePositionObservers = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = mousePositionObservers.length; _i < _len; _i++) {
      observer = mousePositionObservers[_i];
      if (observer !== removeObserver) {
        _results.push(observer);
      }
    }
    return _results;
  })();
};

Opentip.Joint = (function() {

  function Joint(pointerString) {
    if (pointerString == null) {
      return;
    }
    if (pointerString instanceof Opentip.Joint) {
      pointerString = pointerString.toString();
    }
    this.set(pointerString);
    this;

  }

  Joint.prototype.set = function(string) {
    string = string.toLowerCase();
    this.setHorizontal(string);
    this.setVertical(string);
    return this;
  };

  Joint.prototype.setHorizontal = function(string) {
    var i, valid, _i, _j, _len, _len1, _results;
    valid = ["left", "center", "right"];
    for (_i = 0, _len = valid.length; _i < _len; _i++) {
      i = valid[_i];
      if (~string.indexOf(i)) {
        this.horizontal = i.toLowerCase();
      }
    }
    if (this.horizontal == null) {
      this.horizontal = "center";
    }
    _results = [];
    for (_j = 0, _len1 = valid.length; _j < _len1; _j++) {
      i = valid[_j];
      _results.push(this[i] = this.horizontal === i ? i : void 0);
    }
    return _results;
  };

  Joint.prototype.setVertical = function(string) {
    var i, valid, _i, _j, _len, _len1, _results;
    valid = ["top", "middle", "bottom"];
    for (_i = 0, _len = valid.length; _i < _len; _i++) {
      i = valid[_i];
      if (~string.indexOf(i)) {
        this.vertical = i.toLowerCase();
      }
    }
    if (this.vertical == null) {
      this.vertical = "middle";
    }
    _results = [];
    for (_j = 0, _len1 = valid.length; _j < _len1; _j++) {
      i = valid[_j];
      _results.push(this[i] = this.vertical === i ? i : void 0);
    }
    return _results;
  };

  Joint.prototype.eql = function(pointer) {
    return (pointer != null) && this.horizontal === pointer.horizontal && this.vertical === pointer.vertical;
  };

  Joint.prototype.flip = function() {
    var flippedIndex, positionIdx;
    positionIdx = Opentip.position[this.toString(true)];
    flippedIndex = (positionIdx + 4) % 8;
    this.set(Opentip.positions[flippedIndex]);
    return this;
  };

  Joint.prototype.toString = function(camelized) {
    var horizontal, vertical;
    if (camelized == null) {
      camelized = false;
    }
    vertical = this.vertical === "middle" ? "" : this.vertical;
    horizontal = this.horizontal === "center" ? "" : this.horizontal;
    if (vertical && horizontal) {
      if (camelized) {
        horizontal = Opentip.prototype.ucfirst(horizontal);
      } else {
        horizontal = " " + horizontal;
      }
    }
    return "" + vertical + horizontal;
  };

  return Joint;

})();

Opentip.prototype._positionsEqual = function(posA, posB) {
  return (posA != null) && (posB != null) && posA.left === posB.left && posA.top === posB.top;
};

Opentip.prototype._dimensionsEqual = function(dimA, dimB) {
  return (dimA != null) && (dimB != null) && dimA.width === dimB.width && dimA.height === dimB.height;
};

Opentip.prototype.debug = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  if (Opentip.debug && ((typeof console !== "undefined" && console !== null ? console.debug : void 0) != null)) {
    args.unshift("#" + this.id + " |");
    return console.debug.apply(console, args);
  }
};

Opentip.findElements = function() {
  var adapter, content, element, optionName, optionValue, options, _i, _len, _ref, _results;
  adapter = Opentip.adapter;
  _ref = adapter.findAll(document.body, "[data-ot]");
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    element = _ref[_i];
    options = {};
    content = adapter.data(element, "ot");
    if (content === "" || content === "true" || content === "yes") {
      content = adapter.attr(element, "title");
      adapter.attr(element, "title", "");
    }
    content = content || "";
    for (optionName in Opentip.styles.standard) {
      optionValue = adapter.data(element, "ot" + (Opentip.prototype.ucfirst(optionName)));
      if (optionValue != null) {
        if (optionValue === "yes" || optionValue === "true" || optionValue === "on") {
          optionValue = true;
        } else if (optionValue === "no" || optionValue === "false" || optionValue === "off") {
          optionValue = false;
        }
        options[optionName] = optionValue;
      }
    }
    _results.push(new Opentip(element, content, options));
  }
  return _results;
};

Opentip.version = "2.4.6";

Opentip.debug = false;

Opentip.lastId = 0;

Opentip.lastZIndex = 100;

Opentip.tips = [];

Opentip._abortShowingGroup = function(group, originatingOpentip) {
  var opentip, _i, _len, _ref, _results;
  _ref = Opentip.tips;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    opentip = _ref[_i];
    if (opentip !== originatingOpentip && opentip.options.group === group) {
      _results.push(opentip._abortShowing());
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

Opentip._hideGroup = function(group, originatingOpentip) {
  var opentip, _i, _len, _ref, _results;
  _ref = Opentip.tips;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    opentip = _ref[_i];
    if (opentip !== originatingOpentip && opentip.options.group === group) {
      _results.push(opentip.hide());
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

Opentip.adapters = {};

Opentip.adapter = null;

firstAdapter = true;

Opentip.addAdapter = function(adapter) {
  Opentip.adapters[adapter.name] = adapter;
  if (firstAdapter) {
    Opentip.adapter = adapter;
    adapter.domReady(Opentip.findElements);
    adapter.domReady(Opentip.followMousePosition);
    return firstAdapter = false;
  }
};

Opentip.positions = ["top", "topRight", "right", "bottomRight", "bottom", "bottomLeft", "left", "topLeft"];

Opentip.position = {};

_ref = Opentip.positions;
for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
  position = _ref[i];
  Opentip.position[position] = i;
}

Opentip.styles = {
  standard: {
    "extends": null,
    title: void 0,
    escapeTitle: true,
    escapeContent: false,
    className: "standard",
    stem: true,
    delay: null,
    hideDelay: 0.1,
    fixed: false,
    showOn: "mouseover",
    hideTrigger: "trigger",
    hideTriggers: [],
    hideOn: null,
    removeElementsOnHide: false,
    offset: [0, 0],
    containInViewport: true,
    autoOffset: true,
    showEffect: "appear",
    hideEffect: "fade",
    showEffectDuration: 0.3,
    hideEffectDuration: 0.2,
    stemLength: 5,
    stemBase: 8,
    tipJoint: "top left",
    target: null,
    targetJoint: null,
    cache: true,
    ajax: false,
    ajaxMethod: "GET",
    ajaxErrorMessage: "There was a problem downloading the content.",
    group: null,
    style: null,
    background: "#fff18f",
    backgroundGradientHorizontal: false,
    closeButtonOffset: [5, 5],
    closeButtonRadius: 7,
    closeButtonCrossSize: 4,
    closeButtonCrossColor: "#d2c35b",
    closeButtonCrossLineWidth: 1.5,
    closeButtonLinkOverscan: 6,
    borderRadius: 5,
    borderWidth: 1,
    borderColor: "#f2e37b",
    shadow: true,
    shadowBlur: 10,
    shadowOffset: [3, 3],
    shadowColor: "rgba(0, 0, 0, 0.1)"
  },
  glass: {
    "extends": "standard",
    className: "glass",
    background: [[0, "rgba(252, 252, 252, 0.8)"], [0.5, "rgba(255, 255, 255, 0.8)"], [0.5, "rgba(250, 250, 250, 0.9)"], [1, "rgba(245, 245, 245, 0.9)"]],
    borderColor: "#eee",
    closeButtonCrossColor: "rgba(0, 0, 0, 0.2)",
    borderRadius: 15,
    closeButtonRadius: 10,
    closeButtonOffset: [8, 8]
  },
  dark: {
    "extends": "standard",
    className: "dark",
    borderRadius: 13,
    borderColor: "#444",
    closeButtonCrossColor: "rgba(240, 240, 240, 1)",
    shadowColor: "rgba(0, 0, 0, 0.3)",
    shadowOffset: [2, 2],
    background: [[0, "rgba(30, 30, 30, 0.7)"], [0.5, "rgba(30, 30, 30, 0.8)"], [0.5, "rgba(10, 10, 10, 0.8)"], [1, "rgba(10, 10, 10, 0.9)"]]
  },
  alert: {
    "extends": "standard",
    className: "alert",
    borderRadius: 1,
    borderColor: "#AE0D11",
    closeButtonCrossColor: "rgba(255, 255, 255, 1)",
    shadowColor: "rgba(0, 0, 0, 0.3)",
    shadowOffset: [2, 2],
    background: [[0, "rgba(203, 15, 19, 0.7)"], [0.5, "rgba(203, 15, 19, 0.8)"], [0.5, "rgba(189, 14, 18, 0.8)"], [1, "rgba(179, 14, 17, 0.9)"]]
  }
};

Opentip.defaultStyle = "standard";

if (typeof module !== "undefined" && module !== null) {
  module.exports = Opentip;
} else {
  window.Opentip = Opentip;
}


// Generated by CoffeeScript 1.4.0
var __slice = [].slice;

(function($) {
  var Adapter;
  $.fn.opentip = function(content, title, options) {
    return new Opentip(this, content, title, options);
  };
  Adapter = (function() {

    function Adapter() {}

    Adapter.prototype.name = "jquery";

    Adapter.prototype.domReady = function(callback) {
      return $(callback);
    };

    Adapter.prototype.create = function(html) {
      return $(html);
    };

    Adapter.prototype.wrap = function(element) {
      element = $(element);
      if (element.length > 1) {
        throw new Error("Multiple elements provided.");
      }
      return element;
    };

    Adapter.prototype.unwrap = function(element) {
      return $(element)[0];
    };

    Adapter.prototype.tagName = function(element) {
      return this.unwrap(element).tagName;
    };

    Adapter.prototype.attr = function() {
      var args, element, _ref;
      element = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref = $(element)).attr.apply(_ref, args);
    };

    Adapter.prototype.data = function() {
      var args, element, _ref;
      element = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref = $(element)).data.apply(_ref, args);
    };

    Adapter.prototype.find = function(element, selector) {
      return $(element).find(selector).get(0);
    };

    Adapter.prototype.findAll = function(element, selector) {
      return $(element).find(selector);
    };

    Adapter.prototype.update = function(element, content, escape) {
      element = $(element);
      if (escape) {
        return element.text(content);
      } else {
        return element.html(content);
      }
    };

    Adapter.prototype.append = function(element, child) {
      return $(element).append(child);
    };

    Adapter.prototype.remove = function(element) {
      return $(element).remove();
    };

    Adapter.prototype.addClass = function(element, className) {
      return $(element).addClass(className);
    };

    Adapter.prototype.removeClass = function(element, className) {
      return $(element).removeClass(className);
    };

    Adapter.prototype.css = function(element, properties) {
      return $(element).css(properties);
    };

    Adapter.prototype.dimensions = function(element) {
      return {
        width: $(element).outerWidth(),
        height: $(element).outerHeight()
      };
    };

    Adapter.prototype.scrollOffset = function() {
      return [window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft, window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop];
    };

    Adapter.prototype.viewportDimensions = function() {
      return {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight
      };
    };

    Adapter.prototype.mousePosition = function(e) {
      if (e == null) {
        return null;
      }
      return {
        x: e.pageX,
        y: e.pageY
      };
    };

    Adapter.prototype.offset = function(element) {
      var offset;
      offset = $(element).offset();
      return {
        left: offset.left,
        top: offset.top
      };
    };

    Adapter.prototype.observe = function(element, eventName, observer) {
      return $(element).bind(eventName, observer);
    };

    Adapter.prototype.stopObserving = function(element, eventName, observer) {
      return $(element).unbind(eventName, observer);
    };

    Adapter.prototype.ajax = function(options) {
      var _ref, _ref1;
      if (options.url == null) {
        throw new Error("No url provided");
      }
      return $.ajax({
        url: options.url,
        type: (_ref = (_ref1 = options.method) != null ? _ref1.toUpperCase() : void 0) != null ? _ref : "GET"
      }).done(function(content) {
        return typeof options.onSuccess === "function" ? options.onSuccess(content) : void 0;
      }).fail(function(request) {
        return typeof options.onError === "function" ? options.onError("Server responded with status " + request.status) : void 0;
      }).always(function() {
        return typeof options.onComplete === "function" ? options.onComplete() : void 0;
      });
    };

    Adapter.prototype.clone = function(object) {
      return $.extend({}, object);
    };

    Adapter.prototype.extend = function() {
      var sources, target;
      target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return $.extend.apply($, [target].concat(__slice.call(sources)));
    };

    return Adapter;

  })();
  return Opentip.addAdapter(new Adapter);
})(jQuery);


// Modified by Matias Meno to work in IE8.
// I removed the line 312, as proposed by someone on the google forum.

// Copyright 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Known Issues:
//
// * Patterns are not implemented.
// * Radial gradient are not implemented. The VML version of these look very
//   different from the canvas one.
// * Clipping paths are not implemented.
// * Coordsize. The width and height attribute have higher priority than the
//   width and height style values which isn't correct.
// * Painting mode isn't implemented.
// * Canvas width/height should is using content-box by default. IE in
//   Quirks mode will draw the canvas using border-box. Either change your
//   doctype to HTML5
//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype)
//   or use Box Sizing Behavior from WebFX
//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html)
// * Non uniform scaling does not correctly scale strokes.
// * Optimize. There is always room for speed improvements.

// Only add this code if we do not already have a canvas implementation
if (!document.createElement('canvas').getContext) {

(function() {

  // alias some functions to make (compiled) code shorter
  var m = Math;
  var mr = m.round;
  var ms = m.sin;
  var mc = m.cos;
  var abs = m.abs;
  var sqrt = m.sqrt;

  // this is used for sub pixel precision
  var Z = 10;
  var Z2 = Z / 2;

  /**
   * This funtion is assigned to the <canvas> elements as element.getContext().
   * @this {HTMLElement}
   * @return {CanvasRenderingContext2D_}
   */
  function getContext() {
    return this.context_ ||
        (this.context_ = new CanvasRenderingContext2D_(this));
  }

  var slice = Array.prototype.slice;

  /**
   * Binds a function to an object. The returned function will always use the
   * passed in {@code obj} as {@code this}.
   *
   * Example:
   *
   *   g = bind(f, obj, a, b)
   *   g(c, d) // will do f.call(obj, a, b, c, d)
   *
   * @param {Function} f The function to bind the object to
   * @param {Object} obj The object that should act as this when the function
   *     is called
   * @param {*} var_args Rest arguments that will be used as the initial
   *     arguments when the function is called
   * @return {Function} A new function that has bound this
   */
  function bind(f, obj, var_args) {
    var a = slice.call(arguments, 2);
    return function() {
      return f.apply(obj, a.concat(slice.call(arguments)));
    };
  }

  var G_vmlCanvasManager_ = {
    init: function(opt_doc) {
      if (/MSIE/.test(navigator.userAgent) && !window.opera) {
        var doc = opt_doc || document;
        // Create a dummy element so that IE will allow canvas elements to be
        // recognized.
        doc.createElement('canvas');
        doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
      }
    },

    init_: function(doc) {
      // create xmlns
      if (!doc.namespaces['g_vml_']) {
        doc.namespaces.add('g_vml_', 'urn:schemas-microsoft-com:vml',
                           '#default#VML');

      }
      if (!doc.namespaces['g_o_']) {
        doc.namespaces.add('g_o_', 'urn:schemas-microsoft-com:office:office',
                           '#default#VML');
      }

      // Setup default CSS.  Only add one style sheet per document
      if (!doc.styleSheets['ex_canvas_']) {
        var ss = doc.createStyleSheet();
        ss.owningElement.id = 'ex_canvas_';
        ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +
            // default size is 300x150 in Gecko and Opera
            'text-align:left;width:300px;height:150px}' +
            'g_vml_\\:*{behavior:url(#default#VML)}' +
            'g_o_\\:*{behavior:url(#default#VML)}';

      }

      // find all canvas elements
      var els = doc.getElementsByTagName('canvas');
      for (var i = 0; i < els.length; i++) {
        this.initElement(els[i]);
      }
    },

    /**
     * Public initializes a canvas element so that it can be used as canvas
     * element from now on. This is called automatically before the page is
     * loaded but if you are creating elements using createElement you need to
     * make sure this is called on the element.
     * @param {HTMLElement} el The canvas element to initialize.
     * @return {HTMLElement} the element that was created.
     */
    initElement: function(el) {
      if (!el.getContext) {

        el.getContext = getContext;

        // Remove fallback content. There is no way to hide text nodes so we
        // just remove all childNodes. We could hide all elements and remove
        // text nodes but who really cares about the fallback content.
        el.innerHTML = '';

        // do not use inline function because that will leak memory
        el.attachEvent('onpropertychange', onPropertyChange);
        el.attachEvent('onresize', onResize);

        var attrs = el.attributes;
        if (attrs.width && attrs.width.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setWidth_(attrs.width.nodeValue);
          el.style.width = attrs.width.nodeValue + 'px';
        } else {
          el.width = el.clientWidth;
        }
        if (attrs.height && attrs.height.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setHeight_(attrs.height.nodeValue);
          el.style.height = attrs.height.nodeValue + 'px';
        } else {
          el.height = el.clientHeight;
        }
        //el.getContext().setCoordsize_()
      }
      return el;
    }
  };

  function onPropertyChange(e) {
    var el = e.srcElement;

    switch (e.propertyName) {
      case 'width':
        el.style.width = el.attributes.width.nodeValue + 'px';
        el.getContext().clearRect();
        break;
      case 'height':
        el.style.height = el.attributes.height.nodeValue + 'px';
        el.getContext().clearRect();
        break;
    }
  }

  function onResize(e) {
    var el = e.srcElement;
    if (el.firstChild) {
      el.firstChild.style.width =  el.clientWidth + 'px';
      el.firstChild.style.height = el.clientHeight + 'px';
    }
  }

  G_vmlCanvasManager_.init();

  // precompute "00" to "FF"
  var dec2hex = [];
  for (var i = 0; i < 16; i++) {
    for (var j = 0; j < 16; j++) {
      dec2hex[i * 16 + j] = i.toString(16) + j.toString(16);
    }
  }

  function createMatrixIdentity() {
    return [
      [1, 0, 0],
      [0, 1, 0],
      [0, 0, 1]
    ];
  }

  function matrixMultiply(m1, m2) {
    var result = createMatrixIdentity();

    for (var x = 0; x < 3; x++) {
      for (var y = 0; y < 3; y++) {
        var sum = 0;

        for (var z = 0; z < 3; z++) {
          sum += m1[x][z] * m2[z][y];
        }

        result[x][y] = sum;
      }
    }
    return result;
  }

  function copyState(o1, o2) {
    o2.fillStyle     = o1.fillStyle;
    o2.lineCap       = o1.lineCap;
    o2.lineJoin      = o1.lineJoin;
    o2.lineWidth     = o1.lineWidth;
    o2.miterLimit    = o1.miterLimit;
    o2.shadowBlur    = o1.shadowBlur;
    o2.shadowColor   = o1.shadowColor;
    o2.shadowOffsetX = o1.shadowOffsetX;
    o2.shadowOffsetY = o1.shadowOffsetY;
    o2.strokeStyle   = o1.strokeStyle;
    o2.globalAlpha   = o1.globalAlpha;
    o2.arcScaleX_    = o1.arcScaleX_;
    o2.arcScaleY_    = o1.arcScaleY_;
    o2.lineScale_    = o1.lineScale_;
  }

  function processStyle(styleString) {
    var str, alpha = 1;

    styleString = String(styleString);
    if (styleString.substring(0, 3) == 'rgb') {
      var start = styleString.indexOf('(', 3);
      var end = styleString.indexOf(')', start + 1);
      var guts = styleString.substring(start + 1, end).split(',');

      str = '#';
      for (var i = 0; i < 3; i++) {
        str += dec2hex[Number(guts[i])];
      }

      if (guts.length == 4 && styleString.substr(3, 1) == 'a') {
        alpha = guts[3];
      }
    } else {
      str = styleString;
    }

    return {color: str, alpha: alpha};
  }

  function processLineCap(lineCap) {
    switch (lineCap) {
      case 'butt':
        return 'flat';
      case 'round':
        return 'round';
      case 'square':
      default:
        return 'square';
    }
  }

  /**
   * This class implements CanvasRenderingContext2D interface as described by
   * the WHATWG.
   * @param {HTMLElement} surfaceElement The element that the 2D context should
   * be associated with
   */
  function CanvasRenderingContext2D_(surfaceElement) {
    this.m_ = createMatrixIdentity();

    this.mStack_ = [];
    this.aStack_ = [];
    this.currentPath_ = [];

    // Canvas context properties
    this.strokeStyle = '#000';
    this.fillStyle = '#000';

    this.lineWidth = 1;
    this.lineJoin = 'miter';
    this.lineCap = 'butt';
    this.miterLimit = Z * 1;
    this.globalAlpha = 1;
    this.canvas = surfaceElement;

    var el = surfaceElement.ownerDocument.createElement('div');
    el.style.width =  surfaceElement.clientWidth + 'px';
    el.style.height = surfaceElement.clientHeight + 'px';
    // el.style.overflow = 'hidden';
    el.style.position = 'absolute';
    surfaceElement.appendChild(el);

    this.element_ = el;
    this.arcScaleX_ = 1;
    this.arcScaleY_ = 1;
    this.lineScale_ = 1;
  }

  var contextPrototype = CanvasRenderingContext2D_.prototype;
  contextPrototype.clearRect = function() {
    this.element_.innerHTML = '';
  };

  contextPrototype.beginPath = function() {
    // TODO: Branch current matrix so that save/restore has no effect
    //       as per safari docs.
    this.currentPath_ = [];
  };

  contextPrototype.moveTo = function(aX, aY) {
    var p = this.getCoords_(aX, aY);
    this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});
    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.lineTo = function(aX, aY) {
    var p = this.getCoords_(aX, aY);
    this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});

    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                                            aCP2x, aCP2y,
                                            aX, aY) {
    var p = this.getCoords_(aX, aY);
    var cp1 = this.getCoords_(aCP1x, aCP1y);
    var cp2 = this.getCoords_(aCP2x, aCP2y);
    bezierCurveTo(this, cp1, cp2, p);
  };

  // Helper function that takes the already fixed cordinates.
  function bezierCurveTo(self, cp1, cp2, p) {
    self.currentPath_.push({
      type: 'bezierCurveTo',
      cp1x: cp1.x,
      cp1y: cp1.y,
      cp2x: cp2.x,
      cp2y: cp2.y,
      x: p.x,
      y: p.y
    });
    self.currentX_ = p.x;
    self.currentY_ = p.y;
  }

  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
    // the following is lifted almost directly from
    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

    var cp = this.getCoords_(aCPx, aCPy);
    var p = this.getCoords_(aX, aY);

    var cp1 = {
      x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
      y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
    };
    var cp2 = {
      x: cp1.x + (p.x - this.currentX_) / 3.0,
      y: cp1.y + (p.y - this.currentY_) / 3.0
    };

    bezierCurveTo(this, cp1, cp2, p);
  };

  contextPrototype.arc = function(aX, aY, aRadius,
                                  aStartAngle, aEndAngle, aClockwise) {
    aRadius *= Z;
    var arcType = aClockwise ? 'at' : 'wa';

    var xStart = aX + mc(aStartAngle) * aRadius - Z2;
    var yStart = aY + ms(aStartAngle) * aRadius - Z2;

    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

    // IE won't render arches drawn counter clockwise if xStart == xEnd.
    if (xStart == xEnd && !aClockwise) {
      xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                       // that can be represented in binary
    }

    var p = this.getCoords_(aX, aY);
    var pStart = this.getCoords_(xStart, yStart);
    var pEnd = this.getCoords_(xEnd, yEnd);

    this.currentPath_.push({type: arcType,
                           x: p.x,
                           y: p.y,
                           radius: aRadius,
                           xStart: pStart.x,
                           yStart: pStart.y,
                           xEnd: pEnd.x,
                           yEnd: pEnd.y});

  };

  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
  };

  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.stroke();

    this.currentPath_ = oldPath;
  };

  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.fill();

    this.currentPath_ = oldPath;
  };

  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
    var gradient = new CanvasGradient_('gradient');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    return gradient;
  };

  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                                                   aX1, aY1, aR1) {
    var gradient = new CanvasGradient_('gradientradial');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.r0_ = aR0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    gradient.r1_ = aR1;
    return gradient;
  };

  contextPrototype.drawImage = function(image, var_args) {
    var dx, dy, dw, dh, sx, sy, sw, sh;

    // to find the original width we overide the width and height
    var oldRuntimeWidth = image.runtimeStyle.width;
    var oldRuntimeHeight = image.runtimeStyle.height;
    image.runtimeStyle.width = 'auto';
    image.runtimeStyle.height = 'auto';

    // get the original size
    var w = image.width;
    var h = image.height;

    // and remove overides
    image.runtimeStyle.width = oldRuntimeWidth;
    image.runtimeStyle.height = oldRuntimeHeight;

    if (arguments.length == 3) {
      dx = arguments[1];
      dy = arguments[2];
      sx = sy = 0;
      sw = dw = w;
      sh = dh = h;
    } else if (arguments.length == 5) {
      dx = arguments[1];
      dy = arguments[2];
      dw = arguments[3];
      dh = arguments[4];
      sx = sy = 0;
      sw = w;
      sh = h;
    } else if (arguments.length == 9) {
      sx = arguments[1];
      sy = arguments[2];
      sw = arguments[3];
      sh = arguments[4];
      dx = arguments[5];
      dy = arguments[6];
      dw = arguments[7];
      dh = arguments[8];
    } else {
      throw Error('Invalid number of arguments');
    }

    var d = this.getCoords_(dx, dy);

    var w2 = sw / 2;
    var h2 = sh / 2;

    var vmlStr = [];

    var W = 10;
    var H = 10;

    // For some reason that I've now forgotten, using divs didn't work
    vmlStr.push(' <g_vml_:group',
                ' coordsize="', Z * W, ',', Z * H, '"',
                ' coordorigin="0,0"' ,
                ' style="width:', W, 'px;height:', H, 'px;position:absolute;');

    // If filters are necessary (rotation exists), create them
    // filters are bog-slow, so only create them if abbsolutely necessary
    // The following check doesn't account for skews (which don't exist
    // in the canvas spec (yet) anyway.

    if (this.m_[0][0] != 1 || this.m_[0][1]) {
      var filter = [];

      // Note the 12/21 reversal
      filter.push('M11=', this.m_[0][0], ',',
                  'M12=', this.m_[1][0], ',',
                  'M21=', this.m_[0][1], ',',
                  'M22=', this.m_[1][1], ',',
                  'Dx=', mr(d.x / Z), ',',
                  'Dy=', mr(d.y / Z), '');

      // Bounding box calculation (need to minimize displayed area so that
      // filters don't waste time on unused pixels.
      var max = d;
      var c2 = this.getCoords_(dx + dw, dy);
      var c3 = this.getCoords_(dx, dy + dh);
      var c4 = this.getCoords_(dx + dw, dy + dh);

      max.x = m.max(max.x, c2.x, c3.x, c4.x);
      max.y = m.max(max.y, c2.y, c3.y, c4.y);

      vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
                  'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',
                  filter.join(''), ", sizingmethod='clip');")
    } else {
      vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
    }

    vmlStr.push(' ">' ,
                '<g_vml_:image src="', image.src, '"',
                ' style="width:', Z * dw, 'px;',
                ' height:', Z * dh, 'px;"',
                ' cropleft="', sx / w, '"',
                ' croptop="', sy / h, '"',
                ' cropright="', (w - sx - sw) / w, '"',
                ' cropbottom="', (h - sy - sh) / h, '"',
                ' />',
                '</g_vml_:group>');

    this.element_.insertAdjacentHTML('BeforeEnd',
                                    vmlStr.join(''));
  };

  contextPrototype.stroke = function(aFill) {
    var lineStr = [];
    var lineOpen = false;
    var a = processStyle(aFill ? this.fillStyle : this.strokeStyle);
    var color = a.color;
    var opacity = a.alpha * this.globalAlpha;

    var W = 10;
    var H = 10;

    lineStr.push('<g_vml_:shape',
                 ' filled="', !!aFill, '"',
                 ' style="position:absolute;width:', W, 'px;height:', H, 'px;"',
                 ' coordorigin="0 0" coordsize="', Z * W, ' ', Z * H, '"',
                 ' stroked="', !aFill, '"',
                 ' path="');

    var newSeq = false;
    var min = {x: null, y: null};
    var max = {x: null, y: null};

    for (var i = 0; i < this.currentPath_.length; i++) {
      var p = this.currentPath_[i];
      var c;

      switch (p.type) {
        case 'moveTo':
          c = p;
          lineStr.push(' m ', mr(p.x), ',', mr(p.y));
          break;
        case 'lineTo':
          lineStr.push(' l ', mr(p.x), ',', mr(p.y));
          break;
        case 'close':
          lineStr.push(' x ');
          p = null;
          break;
        case 'bezierCurveTo':
          lineStr.push(' c ',
                       mr(p.cp1x), ',', mr(p.cp1y), ',',
                       mr(p.cp2x), ',', mr(p.cp2y), ',',
                       mr(p.x), ',', mr(p.y));
          break;
        case 'at':
        case 'wa':
          lineStr.push(' ', p.type, ' ',
                       mr(p.x - this.arcScaleX_ * p.radius), ',',
                       mr(p.y - this.arcScaleY_ * p.radius), ' ',
                       mr(p.x + this.arcScaleX_ * p.radius), ',',
                       mr(p.y + this.arcScaleY_ * p.radius), ' ',
                       mr(p.xStart), ',', mr(p.yStart), ' ',
                       mr(p.xEnd), ',', mr(p.yEnd));
          break;
      }


      // TODO: Following is broken for curves due to
      //       move to proper paths.

      // Figure out dimensions so we can do gradient fills
      // properly
      if (p) {
        if (min.x == null || p.x < min.x) {
          min.x = p.x;
        }
        if (max.x == null || p.x > max.x) {
          max.x = p.x;
        }
        if (min.y == null || p.y < min.y) {
          min.y = p.y;
        }
        if (max.y == null || p.y > max.y) {
          max.y = p.y;
        }
      }
    }
    lineStr.push(' ">');

    if (!aFill) {
      var lineWidth = this.lineScale_ * this.lineWidth;

      // VML cannot correctly render a line if the width is less than 1px.
      // In that case, we dilute the color to make the line look thinner.
      if (lineWidth < 1) {
        opacity *= lineWidth;
      }

      lineStr.push(
        '<g_vml_:stroke',
        ' opacity="', opacity, '"',
        ' joinstyle="', this.lineJoin, '"',
        ' miterlimit="', this.miterLimit, '"',
        ' endcap="', processLineCap(this.lineCap), '"',
        ' weight="', lineWidth, 'px"',
        ' color="', color, '" />'
      );
    } else if (typeof this.fillStyle == 'object') {
      var fillStyle = this.fillStyle;
      var angle = 0;
      var focus = {x: 0, y: 0};

      // additional offset
      var shift = 0;
      // scale factor for offset
      var expansion = 1;

      if (fillStyle.type_ == 'gradient') {
        var x0 = fillStyle.x0_ / this.arcScaleX_;
        var y0 = fillStyle.y0_ / this.arcScaleY_;
        var x1 = fillStyle.x1_ / this.arcScaleX_;
        var y1 = fillStyle.y1_ / this.arcScaleY_;
        var p0 = this.getCoords_(x0, y0);
        var p1 = this.getCoords_(x1, y1);
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;
        angle = Math.atan2(dx, dy) * 180 / Math.PI;

        // The angle should be a non-negative number.
        if (angle < 0) {
          angle += 360;
        }

        // Very small angles produce an unexpected result because they are
        // converted to a scientific notation string.
        if (angle < 1e-6) {
          angle = 0;
        }
      } else {
        var p0 = this.getCoords_(fillStyle.x0_, fillStyle.y0_);
        var width  = max.x - min.x;
        var height = max.y - min.y;
        focus = {
          x: (p0.x - min.x) / width,
          y: (p0.y - min.y) / height
        };

        width  /= this.arcScaleX_ * Z;
        height /= this.arcScaleY_ * Z;
        var dimension = m.max(width, height);
        shift = 2 * fillStyle.r0_ / dimension;
        expansion = 2 * fillStyle.r1_ / dimension - shift;
      }

      // We need to sort the color stops in ascending order by offset,
      // otherwise IE won't interpret it correctly.
      var stops = fillStyle.colors_;
      stops.sort(function(cs1, cs2) {
        return cs1.offset - cs2.offset;
      });

      var length = stops.length;
      var color1 = stops[0].color;
      var color2 = stops[length - 1].color;
      var opacity1 = stops[0].alpha * this.globalAlpha;
      var opacity2 = stops[length - 1].alpha * this.globalAlpha;

      var colors = [];
      for (var i = 0; i < length; i++) {
        var stop = stops[i];
        colors.push(stop.offset * expansion + shift + ' ' + stop.color);
      }

      // When colors attribute is used, the meanings of opacity and o:opacity2
      // are reversed.
      lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"',
                   ' method="none" focus="100%"',
                   ' color="', color1, '"',
                   ' color2="', color2, '"',
                   ' colors="', colors.join(','), '"',
                   ' opacity="', opacity2, '"',
                   ' g_o_:opacity2="', opacity1, '"',
                   ' angle="', angle, '"',
                   ' focusposition="', focus.x, ',', focus.y, '" />');
    } else {
      lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity,
                   '" />');
    }

    lineStr.push('</g_vml_:shape>');

    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
  };

  contextPrototype.fill = function() {
    this.stroke(true);
  }

  contextPrototype.closePath = function() {
    this.currentPath_.push({type: 'close'});
  };

  /**
   * @private
   */
  contextPrototype.getCoords_ = function(aX, aY) {
    var m = this.m_;
    return {
      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
    }
  };

  contextPrototype.save = function() {
    var o = {};
    copyState(this, o);
    this.aStack_.push(o);
    this.mStack_.push(this.m_);
    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
  };

  contextPrototype.restore = function() {
    copyState(this.aStack_.pop(), this);
    this.m_ = this.mStack_.pop();
  };

  function matrixIsFinite(m) {
    for (var j = 0; j < 3; j++) {
      for (var k = 0; k < 2; k++) {
        if (!isFinite(m[j][k]) || isNaN(m[j][k])) {
          return false;
        }
      }
    }
    return true;
  }

  function setM(ctx, m, updateLineScale) {
    if (!matrixIsFinite(m)) {
      return;
    }
    ctx.m_ = m;

    if (updateLineScale) {
      // Get the line scale.
      // Determinant of this.m_ means how much the area is enlarged by the
      // transformation. So its square root can be used as a scale factor
      // for width.
      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
      ctx.lineScale_ = sqrt(abs(det));
    }
  }

  contextPrototype.translate = function(aX, aY) {
    var m1 = [
      [1,  0,  0],
      [0,  1,  0],
      [aX, aY, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.rotate = function(aRot) {
    var c = mc(aRot);
    var s = ms(aRot);

    var m1 = [
      [c,  s, 0],
      [-s, c, 0],
      [0,  0, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.scale = function(aX, aY) {
    this.arcScaleX_ *= aX;
    this.arcScaleY_ *= aY;
    var m1 = [
      [aX, 0,  0],
      [0,  aY, 0],
      [0,  0,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
    var m1 = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
    var m = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, m, true);
  };

  /******** STUBS ********/
  contextPrototype.clip = function() {
    // TODO: Implement
  };

  contextPrototype.arcTo = function() {
    // TODO: Implement
  };

  contextPrototype.createPattern = function() {
    return new CanvasPattern_;
  };

  // Gradient / Pattern Stubs
  function CanvasGradient_(aType) {
    this.type_ = aType;
    this.x0_ = 0;
    this.y0_ = 0;
    this.r0_ = 0;
    this.x1_ = 0;
    this.y1_ = 0;
    this.r1_ = 0;
    this.colors_ = [];
  }

  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
    aColor = processStyle(aColor);
    this.colors_.push({offset: aOffset,
                       color: aColor.color,
                       alpha: aColor.alpha});
  };

  function CanvasPattern_() {}

  // set up externs
  G_vmlCanvasManager = G_vmlCanvasManager_;
  CanvasRenderingContext2D = CanvasRenderingContext2D_;
  CanvasGradient = CanvasGradient_;
  CanvasPattern = CanvasPattern_;

})();

} // if
},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9tb2R1bGVzL29wZW50aXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNC4wXHJcbi8qXHJcbiNcclxuIyBPcGVudGlwIHYyLjQuNlxyXG4jXHJcbiMgTW9yZSBpbmZvIGF0IFt3d3cub3BlbnRpcC5vcmddKGh0dHA6Ly93d3cub3BlbnRpcC5vcmcpXHJcbiMgXHJcbiMgQ29weXJpZ2h0IChjKSAyMDEyLCBNYXRpYXMgTWVubyAgXHJcbiMgR3JhcGhpY3MgYnkgVGphbmRyYSBNYXllcmhvbGRcclxuIyBcclxuIyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiMgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4jIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuIyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiMgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuIyBcclxuIyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4jIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4jIFxyXG4jIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuIyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuIyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuIyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiMgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuIyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiMgVEhFIFNPRlRXQVJFLlxyXG4jXHJcbiovXHJcblxyXG52YXIgT3BlbnRpcCwgZmlyc3RBZGFwdGVyLCBpLCBtb3VzZU1vdmVkLCBtb3VzZVBvc2l0aW9uLCBtb3VzZVBvc2l0aW9uT2JzZXJ2ZXJzLCBwb3NpdGlvbiwgdmVuZG9ycywgX2ksIF9sZW4sIF9yZWYsXHJcbiAgX19zbGljZSA9IFtdLnNsaWNlLFxyXG4gIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9LFxyXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xyXG5cclxuT3BlbnRpcCA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuU1RJQ0tTX09VVF9UT1AgPSAxO1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5TVElDS1NfT1VUX0JPVFRPTSA9IDI7XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLlNUSUNLU19PVVRfTEVGVCA9IDE7XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLlNUSUNLU19PVVRfUklHSFQgPSAyO1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZVtcImNsYXNzXCJdID0ge1xyXG4gICAgY29udGFpbmVyOiBcIm9wZW50aXAtY29udGFpbmVyXCIsXHJcbiAgICBvcGVudGlwOiBcIm9wZW50aXBcIixcclxuICAgIGhlYWRlcjogXCJvdC1oZWFkZXJcIixcclxuICAgIGNvbnRlbnQ6IFwib3QtY29udGVudFwiLFxyXG4gICAgbG9hZGluZ0luZGljYXRvcjogXCJvdC1sb2FkaW5nLWluZGljYXRvclwiLFxyXG4gICAgY2xvc2U6IFwib3QtY2xvc2VcIixcclxuICAgIGdvaW5nVG9IaWRlOiBcIm90LWdvaW5nLXRvLWhpZGVcIixcclxuICAgIGhpZGRlbjogXCJvdC1oaWRkZW5cIixcclxuICAgIGhpZGluZzogXCJvdC1oaWRpbmdcIixcclxuICAgIGdvaW5nVG9TaG93OiBcIm90LWdvaW5nLXRvLXNob3dcIixcclxuICAgIHNob3dpbmc6IFwib3Qtc2hvd2luZ1wiLFxyXG4gICAgdmlzaWJsZTogXCJvdC12aXNpYmxlXCIsXHJcbiAgICBsb2FkaW5nOiBcIm90LWxvYWRpbmdcIixcclxuICAgIGFqYXhFcnJvcjogXCJvdC1hamF4LWVycm9yXCIsXHJcbiAgICBmaXhlZDogXCJvdC1maXhlZFwiLFxyXG4gICAgc2hvd0VmZmVjdFByZWZpeDogXCJvdC1zaG93LWVmZmVjdC1cIixcclxuICAgIGhpZGVFZmZlY3RQcmVmaXg6IFwib3QtaGlkZS1lZmZlY3QtXCIsXHJcbiAgICBzdHlsZVByZWZpeDogXCJzdHlsZS1cIlxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIE9wZW50aXAoZWxlbWVudCwgY29udGVudCwgdGl0bGUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBlbGVtZW50c09wZW50aXBzLCBoaWRlVHJpZ2dlciwgbWV0aG9kVG9CaW5kLCBvcHRpb25Tb3VyY2VzLCBwcm9wLCBzdHlsZU5hbWUsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYsIF9yZWYxLCBfcmVmMiwgX3RtcFN0eWxlLFxyXG4gICAgICBfdGhpcyA9IHRoaXM7XHJcbiAgICB0aGlzLmlkID0gKytPcGVudGlwLmxhc3RJZDtcclxuICAgIHRoaXMuZGVidWcoXCJDcmVhdGluZyBPcGVudGlwLlwiKTtcclxuICAgIE9wZW50aXAudGlwcy5wdXNoKHRoaXMpO1xyXG4gICAgdGhpcy5hZGFwdGVyID0gT3BlbnRpcC5hZGFwdGVyO1xyXG4gICAgZWxlbWVudHNPcGVudGlwcyA9IHRoaXMuYWRhcHRlci5kYXRhKGVsZW1lbnQsIFwib3BlbnRpcHNcIikgfHwgW107XHJcbiAgICBlbGVtZW50c09wZW50aXBzLnB1c2godGhpcyk7XHJcbiAgICB0aGlzLmFkYXB0ZXIuZGF0YShlbGVtZW50LCBcIm9wZW50aXBzXCIsIGVsZW1lbnRzT3BlbnRpcHMpO1xyXG4gICAgdGhpcy50cmlnZ2VyRWxlbWVudCA9IHRoaXMuYWRhcHRlci53cmFwKGVsZW1lbnQpO1xyXG4gICAgaWYgKHRoaXMudHJpZ2dlckVsZW1lbnQubGVuZ3RoID4gMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuJ3QgY2FsbCBPcGVudGlwIG9uIG11bHRpcGxlIGVsZW1lbnRzLlwiKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnRyaWdnZXJFbGVtZW50Lmxlbmd0aCA8IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbGVtZW50LlwiKTtcclxuICAgIH1cclxuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgdGhpcy53YWl0aW5nVG9TaG93ID0gZmFsc2U7XHJcbiAgICB0aGlzLndhaXRpbmdUb0hpZGUgPSBmYWxzZTtcclxuICAgIHRoaXMuY3VycmVudFBvc2l0aW9uID0ge1xyXG4gICAgICBsZWZ0OiAwLFxyXG4gICAgICB0b3A6IDBcclxuICAgIH07XHJcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB7XHJcbiAgICAgIHdpZHRoOiAxMDAsXHJcbiAgICAgIGhlaWdodDogNTBcclxuICAgIH07XHJcbiAgICB0aGlzLmNvbnRlbnQgPSBcIlwiO1xyXG4gICAgdGhpcy5yZWRyYXcgPSB0cnVlO1xyXG4gICAgdGhpcy5jdXJyZW50T2JzZXJ2ZXJzID0ge1xyXG4gICAgICBzaG93aW5nOiBmYWxzZSxcclxuICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgIGhpZGluZzogZmFsc2UsXHJcbiAgICAgIGhpZGRlbjogZmFsc2VcclxuICAgIH07XHJcbiAgICBvcHRpb25zID0gdGhpcy5hZGFwdGVyLmNsb25lKG9wdGlvbnMpO1xyXG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBjb250ZW50O1xyXG4gICAgICBjb250ZW50ID0gdGl0bGUgPSB2b2lkIDA7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aXRsZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICBvcHRpb25zID0gdGl0bGU7XHJcbiAgICAgIHRpdGxlID0gdm9pZCAwO1xyXG4gICAgfVxyXG4gICAgaWYgKHRpdGxlICE9IG51bGwpIHtcclxuICAgICAgb3B0aW9ucy50aXRsZSA9IHRpdGxlO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLnNldENvbnRlbnQoY29udGVudCk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9uc1tcImV4dGVuZHNcIl0gPT0gbnVsbCkge1xyXG4gICAgICBpZiAob3B0aW9ucy5zdHlsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgb3B0aW9uc1tcImV4dGVuZHNcIl0gPSBvcHRpb25zLnN0eWxlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9wdGlvbnNbXCJleHRlbmRzXCJdID0gT3BlbnRpcC5kZWZhdWx0U3R5bGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG9wdGlvblNvdXJjZXMgPSBbb3B0aW9uc107XHJcbiAgICBfdG1wU3R5bGUgPSBvcHRpb25zO1xyXG4gICAgd2hpbGUgKF90bXBTdHlsZVtcImV4dGVuZHNcIl0pIHtcclxuICAgICAgc3R5bGVOYW1lID0gX3RtcFN0eWxlW1wiZXh0ZW5kc1wiXTtcclxuICAgICAgX3RtcFN0eWxlID0gT3BlbnRpcC5zdHlsZXNbc3R5bGVOYW1lXTtcclxuICAgICAgaWYgKF90bXBTdHlsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHlsZTogXCIgKyBzdHlsZU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIG9wdGlvblNvdXJjZXMudW5zaGlmdChfdG1wU3R5bGUpO1xyXG4gICAgICBpZiAoISgoX3RtcFN0eWxlW1wiZXh0ZW5kc1wiXSAhPSBudWxsKSB8fCBzdHlsZU5hbWUgPT09IFwic3RhbmRhcmRcIikpIHtcclxuICAgICAgICBfdG1wU3R5bGVbXCJleHRlbmRzXCJdID0gXCJzdGFuZGFyZFwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBvcHRpb25zID0gKF9yZWYgPSB0aGlzLmFkYXB0ZXIpLmV4dGVuZC5hcHBseShfcmVmLCBbe31dLmNvbmNhdChfX3NsaWNlLmNhbGwob3B0aW9uU291cmNlcykpKTtcclxuICAgIG9wdGlvbnMuaGlkZVRyaWdnZXJzID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcclxuICAgICAgX3JlZjEgPSBvcHRpb25zLmhpZGVUcmlnZ2VycztcclxuICAgICAgX3Jlc3VsdHMgPSBbXTtcclxuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xyXG4gICAgICAgIGhpZGVUcmlnZ2VyID0gX3JlZjFbX2ldO1xyXG4gICAgICAgIF9yZXN1bHRzLnB1c2goaGlkZVRyaWdnZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfcmVzdWx0cztcclxuICAgIH0pKCk7XHJcbiAgICBpZiAob3B0aW9ucy5oaWRlVHJpZ2dlciAmJiBvcHRpb25zLmhpZGVUcmlnZ2Vycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgb3B0aW9ucy5oaWRlVHJpZ2dlcnMucHVzaChvcHRpb25zLmhpZGVUcmlnZ2VyKTtcclxuICAgIH1cclxuICAgIF9yZWYxID0gW1widGlwSm9pbnRcIiwgXCJ0YXJnZXRKb2ludFwiLCBcInN0ZW1cIl07XHJcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XHJcbiAgICAgIHByb3AgPSBfcmVmMVtfaV07XHJcbiAgICAgIGlmIChvcHRpb25zW3Byb3BdICYmIHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgb3B0aW9uc1twcm9wXSA9IG5ldyBPcGVudGlwLkpvaW50KG9wdGlvbnNbcHJvcF0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5hamF4ICYmIChvcHRpb25zLmFqYXggPT09IHRydWUgfHwgIW9wdGlvbnMuYWpheCkpIHtcclxuICAgICAgaWYgKHRoaXMuYWRhcHRlci50YWdOYW1lKHRoaXMudHJpZ2dlckVsZW1lbnQpID09PSBcIkFcIikge1xyXG4gICAgICAgIG9wdGlvbnMuYWpheCA9IHRoaXMuYWRhcHRlci5hdHRyKHRoaXMudHJpZ2dlckVsZW1lbnQsIFwiaHJlZlwiKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvcHRpb25zLmFqYXggPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuc2hvd09uID09PSBcImNsaWNrXCIgJiYgdGhpcy5hZGFwdGVyLnRhZ05hbWUodGhpcy50cmlnZ2VyRWxlbWVudCkgPT09IFwiQVwiKSB7XHJcbiAgICAgIHRoaXMuYWRhcHRlci5vYnNlcnZlKHRoaXMudHJpZ2dlckVsZW1lbnQsIFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIHJldHVybiBlLnN0b3BwZWQgPSB0cnVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xyXG4gICAgICBvcHRpb25zLmZpeGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLnN0ZW0gPT09IHRydWUpIHtcclxuICAgICAgb3B0aW9ucy5zdGVtID0gbmV3IE9wZW50aXAuSm9pbnQob3B0aW9ucy50aXBKb2ludCk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy50YXJnZXQgPT09IHRydWUpIHtcclxuICAgICAgb3B0aW9ucy50YXJnZXQgPSB0aGlzLnRyaWdnZXJFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnRhcmdldCkge1xyXG4gICAgICBvcHRpb25zLnRhcmdldCA9IHRoaXMuYWRhcHRlci53cmFwKG9wdGlvbnMudGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHRoaXMuY3VycmVudFN0ZW0gPSBvcHRpb25zLnN0ZW07XHJcbiAgICBpZiAob3B0aW9ucy5kZWxheSA9PSBudWxsKSB7XHJcbiAgICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLnNob3dPbiA9PT0gXCJtb3VzZW92ZXJcIiA/IDAuMiA6IDA7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy50YXJnZXRKb2ludCA9PSBudWxsKSB7XHJcbiAgICAgIG9wdGlvbnMudGFyZ2V0Sm9pbnQgPSBuZXcgT3BlbnRpcC5Kb2ludChvcHRpb25zLnRpcEpvaW50KS5mbGlwKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNob3dUcmlnZ2VycyA9IFtdO1xyXG4gICAgdGhpcy5zaG93VHJpZ2dlcnNXaGVuVmlzaWJsZSA9IFtdO1xyXG4gICAgdGhpcy5oaWRlVHJpZ2dlcnMgPSBbXTtcclxuICAgIGlmIChvcHRpb25zLnNob3dPbiAmJiBvcHRpb25zLnNob3dPbiAhPT0gXCJjcmVhdGlvblwiKSB7XHJcbiAgICAgIHRoaXMuc2hvd1RyaWdnZXJzLnB1c2goe1xyXG4gICAgICAgIGVsZW1lbnQ6IHRoaXMudHJpZ2dlckVsZW1lbnQsXHJcbiAgICAgICAgZXZlbnQ6IG9wdGlvbnMuc2hvd09uXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuYWpheENhY2hlICE9IG51bGwpIHtcclxuICAgICAgb3B0aW9ucy5jYWNoZSA9IG9wdGlvbnMuYWpheENhY2hlO1xyXG4gICAgICBkZWxldGUgb3B0aW9ucy5hamF4Q2FjaGU7XHJcbiAgICB9XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5ib3VuZCA9IHt9O1xyXG4gICAgX3JlZjIgPSBbXCJwcmVwYXJlVG9TaG93XCIsIFwicHJlcGFyZVRvSGlkZVwiLCBcInNob3dcIiwgXCJoaWRlXCIsIFwicmVwb3NpdGlvblwiXTtcclxuICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYyLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xyXG4gICAgICBtZXRob2RUb0JpbmQgPSBfcmVmMltfal07XHJcbiAgICAgIHRoaXMuYm91bmRbbWV0aG9kVG9CaW5kXSA9IChmdW5jdGlvbihtZXRob2RUb0JpbmQpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXNbbWV0aG9kVG9CaW5kXS5hcHBseShfdGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9KShtZXRob2RUb0JpbmQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hZGFwdGVyLmRvbVJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICBfdGhpcy5hY3RpdmF0ZSgpO1xyXG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5zaG93T24gPT09IFwiY3JlYXRpb25cIikge1xyXG4gICAgICAgIHJldHVybiBfdGhpcy5wcmVwYXJlVG9TaG93KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX3NldHVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaGlkZU9uLCBoaWRlVHJpZ2dlciwgaGlkZVRyaWdnZXJFbGVtZW50LCBpLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XHJcbiAgICB0aGlzLmRlYnVnKFwiU2V0dGluZyB1cCB0aGUgdG9vbHRpcC5cIik7XHJcbiAgICB0aGlzLl9idWlsZENvbnRhaW5lcigpO1xyXG4gICAgdGhpcy5oaWRlVHJpZ2dlcnMgPSBbXTtcclxuICAgIF9yZWYgPSB0aGlzLm9wdGlvbnMuaGlkZVRyaWdnZXJzO1xyXG4gICAgZm9yIChpID0gX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgaSA9ICsrX2kpIHtcclxuICAgICAgaGlkZVRyaWdnZXIgPSBfcmVmW2ldO1xyXG4gICAgICBoaWRlVHJpZ2dlckVsZW1lbnQgPSBudWxsO1xyXG4gICAgICBoaWRlT24gPSB0aGlzLm9wdGlvbnMuaGlkZU9uIGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzLm9wdGlvbnMuaGlkZU9uW2ldIDogdGhpcy5vcHRpb25zLmhpZGVPbjtcclxuICAgICAgaWYgKHR5cGVvZiBoaWRlVHJpZ2dlciA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHN3aXRjaCAoaGlkZVRyaWdnZXIpIHtcclxuICAgICAgICAgIGNhc2UgXCJ0cmlnZ2VyXCI6XHJcbiAgICAgICAgICAgIGhpZGVPbiA9IGhpZGVPbiB8fCBcIm1vdXNlb3V0XCI7XHJcbiAgICAgICAgICAgIGhpZGVUcmlnZ2VyRWxlbWVudCA9IHRoaXMudHJpZ2dlckVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcInRpcFwiOlxyXG4gICAgICAgICAgICBoaWRlT24gPSBoaWRlT24gfHwgXCJtb3VzZW92ZXJcIjtcclxuICAgICAgICAgICAgaGlkZVRyaWdnZXJFbGVtZW50ID0gdGhpcy5jb250YWluZXI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcInRhcmdldFwiOlxyXG4gICAgICAgICAgICBoaWRlT24gPSBoaWRlT24gfHwgXCJtb3VzZW92ZXJcIjtcclxuICAgICAgICAgICAgaGlkZVRyaWdnZXJFbGVtZW50ID0gdGhpcy5vcHRpb25zLnRhcmdldDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwiY2xvc2VCdXR0b25cIjpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGhpZGUgdHJpZ2dlcjogXCIgKyBoaWRlVHJpZ2dlciArIFwiLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGlkZU9uID0gaGlkZU9uIHx8IFwibW91c2VvdmVyXCI7XHJcbiAgICAgICAgaGlkZVRyaWdnZXJFbGVtZW50ID0gdGhpcy5hZGFwdGVyLndyYXAoaGlkZVRyaWdnZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChoaWRlVHJpZ2dlckVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmhpZGVUcmlnZ2Vycy5wdXNoKHtcclxuICAgICAgICAgIGVsZW1lbnQ6IGhpZGVUcmlnZ2VyRWxlbWVudCxcclxuICAgICAgICAgIGV2ZW50OiBoaWRlT24sXHJcbiAgICAgICAgICBvcmlnaW5hbDogaGlkZVRyaWdnZXJcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3JlZjEgPSB0aGlzLmhpZGVUcmlnZ2VycztcclxuICAgIF9yZXN1bHRzID0gW107XHJcbiAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcclxuICAgICAgaGlkZVRyaWdnZXIgPSBfcmVmMVtfal07XHJcbiAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5zaG93VHJpZ2dlcnNXaGVuVmlzaWJsZS5wdXNoKHtcclxuICAgICAgICBlbGVtZW50OiBoaWRlVHJpZ2dlci5lbGVtZW50LFxyXG4gICAgICAgIGV2ZW50OiBcIm1vdXNlb3ZlclwiXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfcmVzdWx0cztcclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5fYnVpbGRDb250YWluZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5hZGFwdGVyLmNyZWF0ZShcIjxkaXYgaWQ9XFxcIm9wZW50aXAtXCIgKyB0aGlzLmlkICsgXCJcXFwiIGNsYXNzPVxcXCJcIiArIHRoaXNbXCJjbGFzc1wiXS5jb250YWluZXIgKyBcIiBcIiArIHRoaXNbXCJjbGFzc1wiXS5oaWRkZW4gKyBcIiBcIiArIHRoaXNbXCJjbGFzc1wiXS5zdHlsZVByZWZpeCArIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgKyBcIlxcXCI+PC9kaXY+XCIpO1xyXG4gICAgdGhpcy5hZGFwdGVyLmNzcyh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXHJcbiAgICB9KTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWpheCkge1xyXG4gICAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXNbXCJjbGFzc1wiXS5sb2FkaW5nKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZml4ZWQpIHtcclxuICAgICAgdGhpcy5hZGFwdGVyLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzW1wiY2xhc3NcIl0uZml4ZWQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93RWZmZWN0KSB7XHJcbiAgICAgIHRoaXMuYWRhcHRlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgXCJcIiArIHRoaXNbXCJjbGFzc1wiXS5zaG93RWZmZWN0UHJlZml4ICsgdGhpcy5vcHRpb25zLnNob3dFZmZlY3QpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlRWZmZWN0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0uaGlkZUVmZmVjdFByZWZpeCArIHRoaXMub3B0aW9ucy5oaWRlRWZmZWN0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5fYnVpbGRFbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGhlYWRlckVsZW1lbnQsIHRpdGxlRWxlbWVudDtcclxuICAgIHRoaXMudG9vbHRpcEVsZW1lbnQgPSB0aGlzLmFkYXB0ZXIuY3JlYXRlKFwiPGRpdiBjbGFzcz1cXFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0ub3BlbnRpcCArIFwiXFxcIj48ZGl2IGNsYXNzPVxcXCJcIiArIHRoaXNbXCJjbGFzc1wiXS5oZWFkZXIgKyBcIlxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0uY29udGVudCArIFwiXFxcIj48L2Rpdj48L2Rpdj5cIik7XHJcbiAgICB0aGlzLmJhY2tncm91bmRDYW52YXMgPSB0aGlzLmFkYXB0ZXIud3JhcChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcclxuICAgIHRoaXMuYWRhcHRlci5jc3ModGhpcy5iYWNrZ3JvdW5kQ2FudmFzLCB7XHJcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcclxuICAgIH0pO1xyXG4gICAgaWYgKHR5cGVvZiBHX3ZtbENhbnZhc01hbmFnZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgR192bWxDYW52YXNNYW5hZ2VyICE9PSBudWxsKSB7XHJcbiAgICAgIEdfdm1sQ2FudmFzTWFuYWdlci5pbml0RWxlbWVudCh0aGlzLmFkYXB0ZXIudW53cmFwKHRoaXMuYmFja2dyb3VuZENhbnZhcykpO1xyXG4gICAgfVxyXG4gICAgaGVhZGVyRWxlbWVudCA9IHRoaXMuYWRhcHRlci5maW5kKHRoaXMudG9vbHRpcEVsZW1lbnQsIFwiLlwiICsgdGhpc1tcImNsYXNzXCJdLmhlYWRlcik7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpdGxlKSB7XHJcbiAgICAgIHRpdGxlRWxlbWVudCA9IHRoaXMuYWRhcHRlci5jcmVhdGUoXCI8aDE+PC9oMT5cIik7XHJcbiAgICAgIHRoaXMuYWRhcHRlci51cGRhdGUodGl0bGVFbGVtZW50LCB0aGlzLm9wdGlvbnMudGl0bGUsIHRoaXMub3B0aW9ucy5lc2NhcGVUaXRsZSk7XHJcbiAgICAgIHRoaXMuYWRhcHRlci5hcHBlbmQoaGVhZGVyRWxlbWVudCwgdGl0bGVFbGVtZW50KTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWpheCAmJiAhdGhpcy5sb2FkZWQpIHtcclxuICAgICAgdGhpcy5hZGFwdGVyLmFwcGVuZCh0aGlzLnRvb2x0aXBFbGVtZW50LCB0aGlzLmFkYXB0ZXIuY3JlYXRlKFwiPGRpdiBjbGFzcz1cXFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0ubG9hZGluZ0luZGljYXRvciArIFwiXFxcIj48c3Bhbj7ihrs8L3NwYW4+PC9kaXY+XCIpKTtcclxuICAgIH1cclxuICAgIGlmIChfX2luZGV4T2YuY2FsbCh0aGlzLm9wdGlvbnMuaGlkZVRyaWdnZXJzLCBcImNsb3NlQnV0dG9uXCIpID49IDApIHtcclxuICAgICAgdGhpcy5jbG9zZUJ1dHRvbkVsZW1lbnQgPSB0aGlzLmFkYXB0ZXIuY3JlYXRlKFwiPGEgaHJlZj1cXFwiamF2YXNjcmlwdDp1bmRlZmluZWQ7XFxcIiBjbGFzcz1cXFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0uY2xvc2UgKyBcIlxcXCI+PHNwYW4+Q2xvc2U8L3NwYW4+PC9hPlwiKTtcclxuICAgICAgdGhpcy5hZGFwdGVyLmFwcGVuZChoZWFkZXJFbGVtZW50LCB0aGlzLmNsb3NlQnV0dG9uRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkYXB0ZXIuYXBwZW5kKHRoaXMuY29udGFpbmVyLCB0aGlzLmJhY2tncm91bmRDYW52YXMpO1xyXG4gICAgdGhpcy5hZGFwdGVyLmFwcGVuZCh0aGlzLmNvbnRhaW5lciwgdGhpcy50b29sdGlwRWxlbWVudCk7XHJcbiAgICB0aGlzLmFkYXB0ZXIuYXBwZW5kKGRvY3VtZW50LmJvZHksIHRoaXMuY29udGFpbmVyKTtcclxuICAgIHRoaXMuX25ld0NvbnRlbnQgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXMucmVkcmF3ID0gdHJ1ZTtcclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xyXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcclxuICAgIHRoaXMuX25ld0NvbnRlbnQgPSB0cnVlO1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICB0aGlzLl9jb250ZW50RnVuY3Rpb24gPSB0aGlzLmNvbnRlbnQ7XHJcbiAgICAgIHRoaXMuY29udGVudCA9IFwiXCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9jb250ZW50RnVuY3Rpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMudmlzaWJsZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlRWxlbWVudENvbnRlbnQoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5fdXBkYXRlRWxlbWVudENvbnRlbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjb250ZW50RGl2O1xyXG4gICAgaWYgKHRoaXMuX25ld0NvbnRlbnQgfHwgKCF0aGlzLm9wdGlvbnMuY2FjaGUgJiYgdGhpcy5fY29udGVudEZ1bmN0aW9uKSkge1xyXG4gICAgICBjb250ZW50RGl2ID0gdGhpcy5hZGFwdGVyLmZpbmQodGhpcy5jb250YWluZXIsIFwiLlwiICsgdGhpc1tcImNsYXNzXCJdLmNvbnRlbnQpO1xyXG4gICAgICBpZiAoY29udGVudERpdiAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRGdW5jdGlvbikge1xyXG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV4ZWN1dGluZyBjb250ZW50IGZ1bmN0aW9uLlwiKTtcclxuICAgICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuX2NvbnRlbnRGdW5jdGlvbih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGFwdGVyLnVwZGF0ZShjb250ZW50RGl2LCB0aGlzLmNvbnRlbnQsIHRoaXMub3B0aW9ucy5lc2NhcGVDb250ZW50KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9uZXdDb250ZW50ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zdG9yZUFuZExvY2tEaW1lbnNpb25zKCk7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBvc2l0aW9uKCk7XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX3N0b3JlQW5kTG9ja0RpbWVuc2lvbnMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBwcmV2RGltZW5zaW9uO1xyXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBwcmV2RGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb25zO1xyXG4gICAgdGhpcy5hZGFwdGVyLmNzcyh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICB3aWR0aDogXCJhdXRvXCIsXHJcbiAgICAgIGxlZnQ6IFwiMHB4XCIsXHJcbiAgICAgIHRvcDogXCIwcHhcIlxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB0aGlzLmFkYXB0ZXIuZGltZW5zaW9ucyh0aGlzLmNvbnRhaW5lcik7XHJcbiAgICB0aGlzLmRpbWVuc2lvbnMud2lkdGggKz0gMTtcclxuICAgIHRoaXMuYWRhcHRlci5jc3ModGhpcy5jb250YWluZXIsIHtcclxuICAgICAgd2lkdGg6IFwiXCIgKyB0aGlzLmRpbWVuc2lvbnMud2lkdGggKyBcInB4XCIsXHJcbiAgICAgIHRvcDogXCJcIiArIHRoaXMuY3VycmVudFBvc2l0aW9uLnRvcCArIFwicHhcIixcclxuICAgICAgbGVmdDogXCJcIiArIHRoaXMuY3VycmVudFBvc2l0aW9uLmxlZnQgKyBcInB4XCJcclxuICAgIH0pO1xyXG4gICAgaWYgKCF0aGlzLl9kaW1lbnNpb25zRXF1YWwodGhpcy5kaW1lbnNpb25zLCBwcmV2RGltZW5zaW9uKSkge1xyXG4gICAgICB0aGlzLnJlZHJhdyA9IHRydWU7XHJcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3KCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZXR1cE9ic2VydmVycyhcImhpZGRlblwiLCBcImhpZGluZ1wiKTtcclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmRlYnVnKFwiRGVhY3RpdmF0aW5nIHRvb2x0aXAuXCIpO1xyXG4gICAgdGhpcy5oaWRlKCk7XHJcbiAgICByZXR1cm4gdGhpcy5fc2V0dXBPYnNlcnZlcnMoXCItc2hvd2luZ1wiLCBcIi12aXNpYmxlXCIsIFwiLWhpZGRlblwiLCBcIi1oaWRpbmdcIik7XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX3NldHVwT2JzZXJ2ZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb2JzZXJ2ZU9yU3RvcCwgcmVtb3ZlT2JzZXJ2ZXIsIHN0YXRlLCBzdGF0ZXMsIHRyaWdnZXIsIF9pLCBfaiwgX2ssIF9sLCBfbGVuLCBfbGVuMSwgX2xlbjIsIF9sZW4zLCBfcmVmLCBfcmVmMSwgX3JlZjIsXHJcbiAgICAgIF90aGlzID0gdGhpcztcclxuICAgIHN0YXRlcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XHJcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHN0YXRlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xyXG4gICAgICBzdGF0ZSA9IHN0YXRlc1tfaV07XHJcbiAgICAgIHJlbW92ZU9ic2VydmVyID0gZmFsc2U7XHJcbiAgICAgIGlmIChzdGF0ZS5jaGFyQXQoMCkgPT09IFwiLVwiKSB7XHJcbiAgICAgICAgcmVtb3ZlT2JzZXJ2ZXIgPSB0cnVlO1xyXG4gICAgICAgIHN0YXRlID0gc3RhdGUuc3Vic3RyKDEpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRPYnNlcnZlcnNbc3RhdGVdID09PSAhcmVtb3ZlT2JzZXJ2ZXIpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmN1cnJlbnRPYnNlcnZlcnNbc3RhdGVdID0gIXJlbW92ZU9ic2VydmVyO1xyXG4gICAgICBvYnNlcnZlT3JTdG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MsIF9yZWYsIF9yZWYxO1xyXG4gICAgICAgIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xyXG4gICAgICAgIGlmIChyZW1vdmVPYnNlcnZlcikge1xyXG4gICAgICAgICAgcmV0dXJuIChfcmVmID0gX3RoaXMuYWRhcHRlcikuc3RvcE9ic2VydmluZy5hcHBseShfcmVmLCBhcmdzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIChfcmVmMSA9IF90aGlzLmFkYXB0ZXIpLm9ic2VydmUuYXBwbHkoX3JlZjEsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgc3dpdGNoIChzdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgXCJzaG93aW5nXCI6XHJcbiAgICAgICAgICBfcmVmID0gdGhpcy5oaWRlVHJpZ2dlcnM7XHJcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xyXG4gICAgICAgICAgICB0cmlnZ2VyID0gX3JlZltfal07XHJcbiAgICAgICAgICAgIG9ic2VydmVPclN0b3AodHJpZ2dlci5lbGVtZW50LCB0cmlnZ2VyLmV2ZW50LCB0aGlzLmJvdW5kLnByZXBhcmVUb0hpZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgb2JzZXJ2ZU9yU3RvcCgoZG9jdW1lbnQub25yZXNpemUgIT0gbnVsbCA/IGRvY3VtZW50IDogd2luZG93KSwgXCJyZXNpemVcIiwgdGhpcy5ib3VuZC5yZXBvc2l0aW9uKTtcclxuICAgICAgICAgIG9ic2VydmVPclN0b3Aod2luZG93LCBcInNjcm9sbFwiLCB0aGlzLmJvdW5kLnJlcG9zaXRpb24pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInZpc2libGVcIjpcclxuICAgICAgICAgIF9yZWYxID0gdGhpcy5zaG93VHJpZ2dlcnNXaGVuVmlzaWJsZTtcclxuICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IF9yZWYxLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xyXG4gICAgICAgICAgICB0cmlnZ2VyID0gX3JlZjFbX2tdO1xyXG4gICAgICAgICAgICBvYnNlcnZlT3JTdG9wKHRyaWdnZXIuZWxlbWVudCwgdHJpZ2dlci5ldmVudCwgdGhpcy5ib3VuZC5wcmVwYXJlVG9TaG93KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJoaWRpbmdcIjpcclxuICAgICAgICAgIF9yZWYyID0gdGhpcy5zaG93VHJpZ2dlcnM7XHJcbiAgICAgICAgICBmb3IgKF9sID0gMCwgX2xlbjMgPSBfcmVmMi5sZW5ndGg7IF9sIDwgX2xlbjM7IF9sKyspIHtcclxuICAgICAgICAgICAgdHJpZ2dlciA9IF9yZWYyW19sXTtcclxuICAgICAgICAgICAgb2JzZXJ2ZU9yU3RvcCh0cmlnZ2VyLmVsZW1lbnQsIHRyaWdnZXIuZXZlbnQsIHRoaXMuYm91bmQucHJlcGFyZVRvU2hvdyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdGF0ZTogXCIgKyBzdGF0ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLnByZXBhcmVUb1Nob3cgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX2Fib3J0SGlkaW5nKCk7XHJcbiAgICB0aGlzLl9hYm9ydFNob3dpbmcoKTtcclxuICAgIGlmICh0aGlzLnZpc2libGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5kZWJ1ZyhcIlNob3dpbmcgaW4gXCIgKyB0aGlzLm9wdGlvbnMuZGVsYXkgKyBcInMuXCIpO1xyXG4gICAgaWYgKHRoaXMuY29udGFpbmVyID09IG51bGwpIHtcclxuICAgICAgdGhpcy5fc2V0dXAoKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXApIHtcclxuICAgICAgT3BlbnRpcC5fYWJvcnRTaG93aW5nR3JvdXAodGhpcy5vcHRpb25zLmdyb3VwLCB0aGlzKTtcclxuICAgIH1cclxuICAgIHRoaXMucHJlcGFyaW5nVG9TaG93ID0gdHJ1ZTtcclxuICAgIHRoaXMuX3NldHVwT2JzZXJ2ZXJzKFwiLWhpZGRlblwiLCBcIi1oaWRpbmdcIiwgXCJzaG93aW5nXCIpO1xyXG4gICAgdGhpcy5fZm9sbG93TW91c2VQb3NpdGlvbigpO1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5maXhlZCAmJiAhdGhpcy5vcHRpb25zLnRhcmdldCkge1xyXG4gICAgICB0aGlzLmluaXRpYWxNb3VzZVBvc2l0aW9uID0gbW91c2VQb3NpdGlvbjtcclxuICAgIH1cclxuICAgIHRoaXMucmVwb3NpdGlvbigpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3Nob3dUaW1lb3V0SWQgPSB0aGlzLnNldFRpbWVvdXQodGhpcy5ib3VuZC5zaG93LCB0aGlzLm9wdGlvbnMuZGVsYXkgfHwgMCk7XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHRoaXMuX2Fib3J0SGlkaW5nKCk7XHJcbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX2NsZWFyVGltZW91dHMoKTtcclxuICAgIGlmICghdGhpcy5fdHJpZ2dlckVsZW1lbnRFeGlzdHMoKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZWFjdGl2YXRlKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmRlYnVnKFwiU2hvd2luZyBub3cuXCIpO1xyXG4gICAgaWYgKHRoaXMuY29udGFpbmVyID09IG51bGwpIHtcclxuICAgICAgdGhpcy5fc2V0dXAoKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXApIHtcclxuICAgICAgT3BlbnRpcC5faGlkZUdyb3VwKHRoaXMub3B0aW9ucy5ncm91cCwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgdGhpcy5wcmVwYXJpbmdUb1Nob3cgPSBmYWxzZTtcclxuICAgIGlmICh0aGlzLnRvb2x0aXBFbGVtZW50ID09IG51bGwpIHtcclxuICAgICAgdGhpcy5fYnVpbGRFbGVtZW50cygpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdXBkYXRlRWxlbWVudENvbnRlbnQoKTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWpheCAmJiAoIXRoaXMubG9hZGVkIHx8ICF0aGlzLm9wdGlvbnMuY2FjaGUpKSB7XHJcbiAgICAgIHRoaXMuX2xvYWRBamF4KCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zZWFyY2hBbmRBY3RpdmF0ZUNsb3NlQnV0dG9ucygpO1xyXG4gICAgdGhpcy5fc3RhcnRFbnN1cmVUcmlnZ2VyRWxlbWVudCgpO1xyXG4gICAgdGhpcy5hZGFwdGVyLmNzcyh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICB6SW5kZXg6IE9wZW50aXAubGFzdFpJbmRleCsrXHJcbiAgICB9KTtcclxuICAgIHRoaXMuX3NldHVwT2JzZXJ2ZXJzKFwiLWhpZGRlblwiLCBcIi1oaWRpbmdcIiwgXCItc2hvd2luZ1wiLCBcIi12aXNpYmxlXCIsIFwic2hvd2luZ1wiLCBcInZpc2libGVcIik7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmZpeGVkICYmICF0aGlzLm9wdGlvbnMudGFyZ2V0KSB7XHJcbiAgICAgIHRoaXMuaW5pdGlhbE1vdXNlUG9zaXRpb24gPSBtb3VzZVBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZXBvc2l0aW9uKCk7XHJcbiAgICB0aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXNbXCJjbGFzc1wiXS5oaWRpbmcpO1xyXG4gICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzW1wiY2xhc3NcIl0uaGlkZGVuKTtcclxuICAgIHRoaXMuYWRhcHRlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpc1tcImNsYXNzXCJdLmdvaW5nVG9TaG93KTtcclxuICAgIHRoaXMuc2V0Q3NzM1N0eWxlKHRoaXMuY29udGFpbmVyLCB7XHJcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogXCIwc1wiXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZGVmZXIoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBkZWxheTtcclxuICAgICAgaWYgKCFfdGhpcy52aXNpYmxlIHx8IF90aGlzLnByZXBhcmluZ1RvSGlkZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBfdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKF90aGlzLmNvbnRhaW5lciwgX3RoaXNbXCJjbGFzc1wiXS5nb2luZ1RvU2hvdyk7XHJcbiAgICAgIF90aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoX3RoaXMuY29udGFpbmVyLCBfdGhpc1tcImNsYXNzXCJdLnNob3dpbmcpO1xyXG4gICAgICBkZWxheSA9IDA7XHJcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLnNob3dFZmZlY3QgJiYgX3RoaXMub3B0aW9ucy5zaG93RWZmZWN0RHVyYXRpb24pIHtcclxuICAgICAgICBkZWxheSA9IF90aGlzLm9wdGlvbnMuc2hvd0VmZmVjdER1cmF0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIF90aGlzLnNldENzczNTdHlsZShfdGhpcy5jb250YWluZXIsIHtcclxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IFwiXCIgKyBkZWxheSArIFwic1wiXHJcbiAgICAgIH0pO1xyXG4gICAgICBfdGhpcy5fdmlzaWJpbGl0eVN0YXRlVGltZW91dElkID0gX3RoaXMuc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBfdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKF90aGlzLmNvbnRhaW5lciwgX3RoaXNbXCJjbGFzc1wiXS5zaG93aW5nKTtcclxuICAgICAgICByZXR1cm4gX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhfdGhpcy5jb250YWluZXIsIF90aGlzW1wiY2xhc3NcIl0udmlzaWJsZSk7XHJcbiAgICAgIH0sIGRlbGF5KTtcclxuICAgICAgcmV0dXJuIF90aGlzLl9hY3RpdmF0ZUZpcnN0SW5wdXQoKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuX2RyYXcoKTtcclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5fYWJvcnRTaG93aW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5wcmVwYXJpbmdUb1Nob3cpIHtcclxuICAgICAgdGhpcy5kZWJ1ZyhcIkFib3J0aW5nIHNob3dpbmcuXCIpO1xyXG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXRzKCk7XHJcbiAgICAgIHRoaXMuX3N0b3BGb2xsb3dpbmdNb3VzZVBvc2l0aW9uKCk7XHJcbiAgICAgIHRoaXMucHJlcGFyaW5nVG9TaG93ID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zZXR1cE9ic2VydmVycyhcIi1zaG93aW5nXCIsIFwiLXZpc2libGVcIiwgXCJoaWRpbmdcIiwgXCJoaWRkZW5cIik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUucHJlcGFyZVRvSGlkZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5fYWJvcnRTaG93aW5nKCk7XHJcbiAgICB0aGlzLl9hYm9ydEhpZGluZygpO1xyXG4gICAgaWYgKCF0aGlzLnZpc2libGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5kZWJ1ZyhcIkhpZGluZyBpbiBcIiArIHRoaXMub3B0aW9ucy5oaWRlRGVsYXkgKyBcInNcIik7XHJcbiAgICB0aGlzLnByZXBhcmluZ1RvSGlkZSA9IHRydWU7XHJcbiAgICB0aGlzLl9zZXR1cE9ic2VydmVycyhcIi1zaG93aW5nXCIsIFwidmlzaWJsZVwiLCBcIi1oaWRkZW5cIiwgXCJoaWRpbmdcIik7XHJcbiAgICByZXR1cm4gdGhpcy5faGlkZVRpbWVvdXRJZCA9IHRoaXMuc2V0VGltZW91dCh0aGlzLmJvdW5kLmhpZGUsIHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpO1xyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICB0aGlzLl9hYm9ydFNob3dpbmcoKTtcclxuICAgIGlmICghdGhpcy52aXNpYmxlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX2NsZWFyVGltZW91dHMoKTtcclxuICAgIHRoaXMuZGVidWcoXCJIaWRpbmchXCIpO1xyXG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICB0aGlzLnByZXBhcmluZ1RvSGlkZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fc3RvcEVuc3VyZVRyaWdnZXJFbGVtZW50KCk7XHJcbiAgICB0aGlzLl9zZXR1cE9ic2VydmVycyhcIi1zaG93aW5nXCIsIFwiLXZpc2libGVcIiwgXCItaGlkaW5nXCIsIFwiLWhpZGRlblwiLCBcImhpZGluZ1wiLCBcImhpZGRlblwiKTtcclxuICAgIGlmICghdGhpcy5vcHRpb25zLmZpeGVkKSB7XHJcbiAgICAgIHRoaXMuX3N0b3BGb2xsb3dpbmdNb3VzZVBvc2l0aW9uKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpc1tcImNsYXNzXCJdLnZpc2libGUpO1xyXG4gICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzW1wiY2xhc3NcIl0uc2hvd2luZyk7XHJcbiAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXNbXCJjbGFzc1wiXS5nb2luZ1RvSGlkZSk7XHJcbiAgICB0aGlzLnNldENzczNTdHlsZSh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IFwiMHNcIlxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5kZWZlcihmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGhpZGVEZWxheTtcclxuICAgICAgX3RoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhfdGhpcy5jb250YWluZXIsIF90aGlzW1wiY2xhc3NcIl0uZ29pbmdUb0hpZGUpO1xyXG4gICAgICBfdGhpcy5hZGFwdGVyLmFkZENsYXNzKF90aGlzLmNvbnRhaW5lciwgX3RoaXNbXCJjbGFzc1wiXS5oaWRpbmcpO1xyXG4gICAgICBoaWRlRGVsYXkgPSAwO1xyXG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5oaWRlRWZmZWN0ICYmIF90aGlzLm9wdGlvbnMuaGlkZUVmZmVjdER1cmF0aW9uKSB7XHJcbiAgICAgICAgaGlkZURlbGF5ID0gX3RoaXMub3B0aW9ucy5oaWRlRWZmZWN0RHVyYXRpb247XHJcbiAgICAgIH1cclxuICAgICAgX3RoaXMuc2V0Q3NzM1N0eWxlKF90aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogXCJcIiArIGhpZGVEZWxheSArIFwic1wiXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gX3RoaXMuX3Zpc2liaWxpdHlTdGF0ZVRpbWVvdXRJZCA9IF90aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX3RoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhfdGhpcy5jb250YWluZXIsIF90aGlzW1wiY2xhc3NcIl0uaGlkaW5nKTtcclxuICAgICAgICBfdGhpcy5hZGFwdGVyLmFkZENsYXNzKF90aGlzLmNvbnRhaW5lciwgX3RoaXNbXCJjbGFzc1wiXS5oaWRkZW4pO1xyXG4gICAgICAgIF90aGlzLnNldENzczNTdHlsZShfdGhpcy5jb250YWluZXIsIHtcclxuICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogXCIwc1wiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucmVtb3ZlRWxlbWVudHNPbkhpZGUpIHtcclxuICAgICAgICAgIF90aGlzLmRlYnVnKFwiUmVtb3ZpbmcgSFRNTCBlbGVtZW50cy5cIik7XHJcbiAgICAgICAgICBfdGhpcy5hZGFwdGVyLnJlbW92ZShfdGhpcy5jb250YWluZXIpO1xyXG4gICAgICAgICAgZGVsZXRlIF90aGlzLmNvbnRhaW5lcjtcclxuICAgICAgICAgIHJldHVybiBkZWxldGUgX3RoaXMudG9vbHRpcEVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBoaWRlRGVsYXkpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX2Fib3J0SGlkaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5wcmVwYXJpbmdUb0hpZGUpIHtcclxuICAgICAgdGhpcy5kZWJ1ZyhcIkFib3J0aW5nIGhpZGluZy5cIik7XHJcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dHMoKTtcclxuICAgICAgdGhpcy5wcmVwYXJpbmdUb0hpZGUgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRoaXMuX3NldHVwT2JzZXJ2ZXJzKFwiLWhpZGluZ1wiLCBcInNob3dpbmdcIiwgXCJ2aXNpYmxlXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLnJlcG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBwb3NpdGlvbiwgc3RlbSwgX3JlZixcclxuICAgICAgX3RoaXMgPSB0aGlzO1xyXG4gICAgcG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKCk7XHJcbiAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBzdGVtID0gdGhpcy5vcHRpb25zLnN0ZW07XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5JblZpZXdwb3J0KSB7XHJcbiAgICAgIF9yZWYgPSB0aGlzLl9lbnN1cmVWaWV3cG9ydENvbnRhaW5tZW50KHBvc2l0aW9uKSwgcG9zaXRpb24gPSBfcmVmLnBvc2l0aW9uLCBzdGVtID0gX3JlZi5zdGVtO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uc0VxdWFsKHBvc2l0aW9uLCB0aGlzLmN1cnJlbnRQb3NpdGlvbikpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoIXRoaXMub3B0aW9ucy5zdGVtIHx8IHN0ZW0uZXFsKHRoaXMuY3VycmVudFN0ZW0pKSkge1xyXG4gICAgICB0aGlzLnJlZHJhdyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgdGhpcy5jdXJyZW50U3RlbSA9IHN0ZW07XHJcbiAgICB0aGlzLl9kcmF3KCk7XHJcbiAgICB0aGlzLmFkYXB0ZXIuY3NzKHRoaXMuY29udGFpbmVyLCB7XHJcbiAgICAgIGxlZnQ6IFwiXCIgKyBwb3NpdGlvbi5sZWZ0ICsgXCJweFwiLFxyXG4gICAgICB0b3A6IFwiXCIgKyBwb3NpdGlvbi50b3AgKyBcInB4XCJcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXMuZGVmZXIoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciByYXdDb250YWluZXIsIHJlZHJhd0ZpeDtcclxuICAgICAgcmF3Q29udGFpbmVyID0gX3RoaXMuYWRhcHRlci51bndyYXAoX3RoaXMuY29udGFpbmVyKTtcclxuICAgICAgcmF3Q29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xyXG4gICAgICByZWRyYXdGaXggPSByYXdDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICByZXR1cm4gcmF3Q29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24odGlwSm9pbnQsIHRhcmdldEpvaW50LCBzdGVtKSB7XHJcbiAgICB2YXIgYWRkaXRpb25hbEhvcml6b250YWwsIGFkZGl0aW9uYWxWZXJ0aWNhbCwgb2Zmc2V0RGlzdGFuY2UsIHBvc2l0aW9uLCBzdGVtTGVuZ3RoLCB0YXJnZXREaW1lbnNpb25zLCB0YXJnZXRQb3NpdGlvbiwgdW53cmFwcGVkVGFyZ2V0LCBfcmVmO1xyXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGlwSm9pbnQgPT0gbnVsbCkge1xyXG4gICAgICB0aXBKb2ludCA9IHRoaXMub3B0aW9ucy50aXBKb2ludDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXRKb2ludCA9PSBudWxsKSB7XHJcbiAgICAgIHRhcmdldEpvaW50ID0gdGhpcy5vcHRpb25zLnRhcmdldEpvaW50O1xyXG4gICAgfVxyXG4gICAgcG9zaXRpb24gPSB7fTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0KSB7XHJcbiAgICAgIHRhcmdldFBvc2l0aW9uID0gdGhpcy5hZGFwdGVyLm9mZnNldCh0aGlzLm9wdGlvbnMudGFyZ2V0KTtcclxuICAgICAgdGFyZ2V0RGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlci5kaW1lbnNpb25zKHRoaXMub3B0aW9ucy50YXJnZXQpO1xyXG4gICAgICBwb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uO1xyXG4gICAgICBpZiAodGFyZ2V0Sm9pbnQucmlnaHQpIHtcclxuICAgICAgICB1bndyYXBwZWRUYXJnZXQgPSB0aGlzLmFkYXB0ZXIudW53cmFwKHRoaXMub3B0aW9ucy50YXJnZXQpO1xyXG4gICAgICAgIGlmICh1bndyYXBwZWRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9IG51bGwpIHtcclxuICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPSB1bndyYXBwZWRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgKyAoKF9yZWYgPSB3aW5kb3cucGFnZVhPZmZzZXQpICE9IG51bGwgPyBfcmVmIDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcG9zaXRpb24ubGVmdCArPSB0YXJnZXREaW1lbnNpb25zLndpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0YXJnZXRKb2ludC5jZW50ZXIpIHtcclxuICAgICAgICBwb3NpdGlvbi5sZWZ0ICs9IE1hdGgucm91bmQodGFyZ2V0RGltZW5zaW9ucy53aWR0aCAvIDIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0YXJnZXRKb2ludC5ib3R0b20pIHtcclxuICAgICAgICBwb3NpdGlvbi50b3AgKz0gdGFyZ2V0RGltZW5zaW9ucy5oZWlnaHQ7XHJcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Sm9pbnQubWlkZGxlKSB7XHJcbiAgICAgICAgcG9zaXRpb24udG9wICs9IE1hdGgucm91bmQodGFyZ2V0RGltZW5zaW9ucy5oZWlnaHQgLyAyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJvcmRlcldpZHRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aXBKb2ludC5sZWZ0KSB7XHJcbiAgICAgICAgICBwb3NpdGlvbi5sZWZ0ICs9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aXBKb2ludC5yaWdodCkge1xyXG4gICAgICAgICAgcG9zaXRpb24ubGVmdCAtPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGlwSm9pbnQudG9wKSB7XHJcbiAgICAgICAgICBwb3NpdGlvbi50b3AgKz0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnRpcEpvaW50LmJvdHRvbSkge1xyXG4gICAgICAgICAgcG9zaXRpb24udG9wIC09IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLmluaXRpYWxNb3VzZVBvc2l0aW9uKSB7XHJcbiAgICAgICAgcG9zaXRpb24gPSB7XHJcbiAgICAgICAgICB0b3A6IHRoaXMuaW5pdGlhbE1vdXNlUG9zaXRpb24ueSxcclxuICAgICAgICAgIGxlZnQ6IHRoaXMuaW5pdGlhbE1vdXNlUG9zaXRpb24ueFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcG9zaXRpb24gPSB7XHJcbiAgICAgICAgICB0b3A6IG1vdXNlUG9zaXRpb24ueSxcclxuICAgICAgICAgIGxlZnQ6IG1vdXNlUG9zaXRpb24ueFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b09mZnNldCkge1xyXG4gICAgICBzdGVtTGVuZ3RoID0gdGhpcy5vcHRpb25zLnN0ZW0gPyB0aGlzLm9wdGlvbnMuc3RlbUxlbmd0aCA6IDA7XHJcbiAgICAgIG9mZnNldERpc3RhbmNlID0gc3RlbUxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuZml4ZWQgPyAyIDogMTA7XHJcbiAgICAgIGFkZGl0aW9uYWxIb3Jpem9udGFsID0gdGlwSm9pbnQubWlkZGxlICYmICF0aGlzLm9wdGlvbnMuZml4ZWQgPyAxNSA6IDA7XHJcbiAgICAgIGFkZGl0aW9uYWxWZXJ0aWNhbCA9IHRpcEpvaW50LmNlbnRlciAmJiAhdGhpcy5vcHRpb25zLmZpeGVkID8gMTUgOiAwO1xyXG4gICAgICBpZiAodGlwSm9pbnQucmlnaHQpIHtcclxuICAgICAgICBwb3NpdGlvbi5sZWZ0IC09IG9mZnNldERpc3RhbmNlICsgYWRkaXRpb25hbEhvcml6b250YWw7XHJcbiAgICAgIH0gZWxzZSBpZiAodGlwSm9pbnQubGVmdCkge1xyXG4gICAgICAgIHBvc2l0aW9uLmxlZnQgKz0gb2Zmc2V0RGlzdGFuY2UgKyBhZGRpdGlvbmFsSG9yaXpvbnRhbDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGlwSm9pbnQuYm90dG9tKSB7XHJcbiAgICAgICAgcG9zaXRpb24udG9wIC09IG9mZnNldERpc3RhbmNlICsgYWRkaXRpb25hbFZlcnRpY2FsO1xyXG4gICAgICB9IGVsc2UgaWYgKHRpcEpvaW50LnRvcCkge1xyXG4gICAgICAgIHBvc2l0aW9uLnRvcCArPSBvZmZzZXREaXN0YW5jZSArIGFkZGl0aW9uYWxWZXJ0aWNhbDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RlbUxlbmd0aCkge1xyXG4gICAgICAgIGlmIChzdGVtID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ZW0gPSB0aGlzLm9wdGlvbnMuc3RlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0ZW0ucmlnaHQpIHtcclxuICAgICAgICAgIHBvc2l0aW9uLmxlZnQgLT0gc3RlbUxlbmd0aDtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0ZW0ubGVmdCkge1xyXG4gICAgICAgICAgcG9zaXRpb24ubGVmdCArPSBzdGVtTGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RlbS5ib3R0b20pIHtcclxuICAgICAgICAgIHBvc2l0aW9uLnRvcCAtPSBzdGVtTGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RlbS50b3ApIHtcclxuICAgICAgICAgIHBvc2l0aW9uLnRvcCArPSBzdGVtTGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9zaXRpb24ubGVmdCArPSB0aGlzLm9wdGlvbnMub2Zmc2V0WzBdO1xyXG4gICAgcG9zaXRpb24udG9wICs9IHRoaXMub3B0aW9ucy5vZmZzZXRbMV07XHJcbiAgICBpZiAodGlwSm9pbnQucmlnaHQpIHtcclxuICAgICAgcG9zaXRpb24ubGVmdCAtPSB0aGlzLmRpbWVuc2lvbnMud2lkdGg7XHJcbiAgICB9IGVsc2UgaWYgKHRpcEpvaW50LmNlbnRlcikge1xyXG4gICAgICBwb3NpdGlvbi5sZWZ0IC09IE1hdGgucm91bmQodGhpcy5kaW1lbnNpb25zLndpZHRoIC8gMik7XHJcbiAgICB9XHJcbiAgICBpZiAodGlwSm9pbnQuYm90dG9tKSB7XHJcbiAgICAgIHBvc2l0aW9uLnRvcCAtPSB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0O1xyXG4gICAgfSBlbHNlIGlmICh0aXBKb2ludC5taWRkbGUpIHtcclxuICAgICAgcG9zaXRpb24udG9wIC09IE1hdGgucm91bmQodGhpcy5kaW1lbnNpb25zLmhlaWdodCAvIDIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLl9lbnN1cmVWaWV3cG9ydENvbnRhaW5tZW50ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHZhciBuZWVkc1JlcG9zaXRpb25pbmcsIG5ld1N0aWNrc091dCwgb3JpZ2luYWxzLCByZXZlcnRlZFgsIHJldmVydGVkWSwgc2Nyb2xsT2Zmc2V0LCBzdGVtLCBzdGlja3NPdXQsIHRhcmdldEpvaW50LCB0aXBKb2ludCwgdmlld3BvcnREaW1lbnNpb25zLCB2aWV3cG9ydFBvc2l0aW9uO1xyXG4gICAgc3RlbSA9IHRoaXMub3B0aW9ucy5zdGVtO1xyXG4gICAgb3JpZ2luYWxzID0ge1xyXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24sXHJcbiAgICAgIHN0ZW06IHN0ZW1cclxuICAgIH07XHJcbiAgICBpZiAoISh0aGlzLnZpc2libGUgJiYgcG9zaXRpb24pKSB7XHJcbiAgICAgIHJldHVybiBvcmlnaW5hbHM7XHJcbiAgICB9XHJcbiAgICBzdGlja3NPdXQgPSB0aGlzLl9zdGlja3NPdXQocG9zaXRpb24pO1xyXG4gICAgaWYgKCEoc3RpY2tzT3V0WzBdIHx8IHN0aWNrc091dFsxXSkpIHtcclxuICAgICAgcmV0dXJuIG9yaWdpbmFscztcclxuICAgIH1cclxuICAgIHRpcEpvaW50ID0gbmV3IE9wZW50aXAuSm9pbnQodGhpcy5vcHRpb25zLnRpcEpvaW50KTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQpIHtcclxuICAgICAgdGFyZ2V0Sm9pbnQgPSBuZXcgT3BlbnRpcC5Kb2ludCh0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQpO1xyXG4gICAgfVxyXG4gICAgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5hZGFwdGVyLnNjcm9sbE9mZnNldCgpO1xyXG4gICAgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5hZGFwdGVyLnZpZXdwb3J0RGltZW5zaW9ucygpO1xyXG4gICAgdmlld3BvcnRQb3NpdGlvbiA9IFtwb3NpdGlvbi5sZWZ0IC0gc2Nyb2xsT2Zmc2V0WzBdLCBwb3NpdGlvbi50b3AgLSBzY3JvbGxPZmZzZXRbMV1dO1xyXG4gICAgbmVlZHNSZXBvc2l0aW9uaW5nID0gZmFsc2U7XHJcbiAgICBpZiAodmlld3BvcnREaW1lbnNpb25zLndpZHRoID49IHRoaXMuZGltZW5zaW9ucy53aWR0aCkge1xyXG4gICAgICBpZiAoc3RpY2tzT3V0WzBdKSB7XHJcbiAgICAgICAgbmVlZHNSZXBvc2l0aW9uaW5nID0gdHJ1ZTtcclxuICAgICAgICBzd2l0Y2ggKHN0aWNrc091dFswXSkge1xyXG4gICAgICAgICAgY2FzZSB0aGlzLlNUSUNLU19PVVRfTEVGVDpcclxuICAgICAgICAgICAgdGlwSm9pbnQuc2V0SG9yaXpvbnRhbChcImxlZnRcIik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQpIHtcclxuICAgICAgICAgICAgICB0YXJnZXRKb2ludC5zZXRIb3Jpem9udGFsKFwicmlnaHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIHRoaXMuU1RJQ0tTX09VVF9SSUdIVDpcclxuICAgICAgICAgICAgdGlwSm9pbnQuc2V0SG9yaXpvbnRhbChcInJpZ2h0XCIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEpvaW50KSB7XHJcbiAgICAgICAgICAgICAgdGFyZ2V0Sm9pbnQuc2V0SG9yaXpvbnRhbChcImxlZnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0ID49IHRoaXMuZGltZW5zaW9ucy5oZWlnaHQpIHtcclxuICAgICAgaWYgKHN0aWNrc091dFsxXSkge1xyXG4gICAgICAgIG5lZWRzUmVwb3NpdGlvbmluZyA9IHRydWU7XHJcbiAgICAgICAgc3dpdGNoIChzdGlja3NPdXRbMV0pIHtcclxuICAgICAgICAgIGNhc2UgdGhpcy5TVElDS1NfT1VUX1RPUDpcclxuICAgICAgICAgICAgdGlwSm9pbnQuc2V0VmVydGljYWwoXCJ0b3BcIik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQpIHtcclxuICAgICAgICAgICAgICB0YXJnZXRKb2ludC5zZXRWZXJ0aWNhbChcImJvdHRvbVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgdGhpcy5TVElDS1NfT1VUX0JPVFRPTTpcclxuICAgICAgICAgICAgdGlwSm9pbnQuc2V0VmVydGljYWwoXCJib3R0b21cIik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQpIHtcclxuICAgICAgICAgICAgICB0YXJnZXRKb2ludC5zZXRWZXJ0aWNhbChcInRvcFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFuZWVkc1JlcG9zaXRpb25pbmcpIHtcclxuICAgICAgcmV0dXJuIG9yaWdpbmFscztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RlbSkge1xyXG4gICAgICBzdGVtID0gdGlwSm9pbnQ7XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24odGlwSm9pbnQsIHRhcmdldEpvaW50LCBzdGVtKTtcclxuICAgIG5ld1N0aWNrc091dCA9IHRoaXMuX3N0aWNrc091dChwb3NpdGlvbik7XHJcbiAgICByZXZlcnRlZFggPSBmYWxzZTtcclxuICAgIHJldmVydGVkWSA9IGZhbHNlO1xyXG4gICAgaWYgKG5ld1N0aWNrc091dFswXSAmJiAobmV3U3RpY2tzT3V0WzBdICE9PSBzdGlja3NPdXRbMF0pKSB7XHJcbiAgICAgIHJldmVydGVkWCA9IHRydWU7XHJcbiAgICAgIHRpcEpvaW50LnNldEhvcml6b250YWwodGhpcy5vcHRpb25zLnRpcEpvaW50Lmhvcml6b250YWwpO1xyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEpvaW50KSB7XHJcbiAgICAgICAgdGFyZ2V0Sm9pbnQuc2V0SG9yaXpvbnRhbCh0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQuaG9yaXpvbnRhbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuZXdTdGlja3NPdXRbMV0gJiYgKG5ld1N0aWNrc091dFsxXSAhPT0gc3RpY2tzT3V0WzFdKSkge1xyXG4gICAgICByZXZlcnRlZFkgPSB0cnVlO1xyXG4gICAgICB0aXBKb2ludC5zZXRWZXJ0aWNhbCh0aGlzLm9wdGlvbnMudGlwSm9pbnQudmVydGljYWwpO1xyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEpvaW50KSB7XHJcbiAgICAgICAgdGFyZ2V0Sm9pbnQuc2V0VmVydGljYWwodGhpcy5vcHRpb25zLnRhcmdldEpvaW50LnZlcnRpY2FsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJldmVydGVkWCAmJiByZXZlcnRlZFkpIHtcclxuICAgICAgcmV0dXJuIG9yaWdpbmFscztcclxuICAgIH1cclxuICAgIGlmIChyZXZlcnRlZFggfHwgcmV2ZXJ0ZWRZKSB7XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RlbSkge1xyXG4gICAgICAgIHN0ZW0gPSB0aXBKb2ludDtcclxuICAgICAgfVxyXG4gICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24odGlwSm9pbnQsIHRhcmdldEpvaW50LCBzdGVtKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgc3RlbTogc3RlbVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5fc3RpY2tzT3V0ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgIHZhciBwb3NpdGlvbk9mZnNldCwgc2Nyb2xsT2Zmc2V0LCBzdGlja3NPdXQsIHZpZXdwb3J0RGltZW5zaW9ucztcclxuICAgIHNjcm9sbE9mZnNldCA9IHRoaXMuYWRhcHRlci5zY3JvbGxPZmZzZXQoKTtcclxuICAgIHZpZXdwb3J0RGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlci52aWV3cG9ydERpbWVuc2lvbnMoKTtcclxuICAgIHBvc2l0aW9uT2Zmc2V0ID0gW3Bvc2l0aW9uLmxlZnQgLSBzY3JvbGxPZmZzZXRbMF0sIHBvc2l0aW9uLnRvcCAtIHNjcm9sbE9mZnNldFsxXV07XHJcbiAgICBzdGlja3NPdXQgPSBbZmFsc2UsIGZhbHNlXTtcclxuICAgIGlmIChwb3NpdGlvbk9mZnNldFswXSA8IDApIHtcclxuICAgICAgc3RpY2tzT3V0WzBdID0gdGhpcy5TVElDS1NfT1VUX0xFRlQ7XHJcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uT2Zmc2V0WzBdICsgdGhpcy5kaW1lbnNpb25zLndpZHRoID4gdmlld3BvcnREaW1lbnNpb25zLndpZHRoKSB7XHJcbiAgICAgIHN0aWNrc091dFswXSA9IHRoaXMuU1RJQ0tTX09VVF9SSUdIVDtcclxuICAgIH1cclxuICAgIGlmIChwb3NpdGlvbk9mZnNldFsxXSA8IDApIHtcclxuICAgICAgc3RpY2tzT3V0WzFdID0gdGhpcy5TVElDS1NfT1VUX1RPUDtcclxuICAgIH0gZWxzZSBpZiAocG9zaXRpb25PZmZzZXRbMV0gKyB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0ID4gdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCkge1xyXG4gICAgICBzdGlja3NPdXRbMV0gPSB0aGlzLlNUSUNLU19PVVRfQk9UVE9NO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0aWNrc091dDtcclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGJhY2tncm91bmRDYW52YXMsIGJ1bGdlLCBjYW52YXNEaW1lbnNpb25zLCBjYW52YXNQb3NpdGlvbiwgY2xvc2VCdXR0b24sIGNsb3NlQnV0dG9uSW5uZXIsIGNsb3NlQnV0dG9uT3V0ZXIsIGN0eCwgZHJhd0Nvcm5lciwgZHJhd0xpbmUsIGhiLCBwb3NpdGlvbiwgc3RlbUJhc2UsIHN0ZW1MZW5ndGgsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3JlZjIsXHJcbiAgICAgIF90aGlzID0gdGhpcztcclxuICAgIGlmICghKHRoaXMuYmFja2dyb3VuZENhbnZhcyAmJiB0aGlzLnJlZHJhdykpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5kZWJ1ZyhcIkRyYXdpbmcgYmFja2dyb3VuZC5cIik7XHJcbiAgICB0aGlzLnJlZHJhdyA9IGZhbHNlO1xyXG4gICAgaWYgKHRoaXMuY3VycmVudFN0ZW0pIHtcclxuICAgICAgX3JlZiA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXTtcclxuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XHJcbiAgICAgICAgcG9zaXRpb24gPSBfcmVmW19pXTtcclxuICAgICAgICB0aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3ModGhpcy5jb250YWluZXIsIFwic3RlbS1cIiArIHBvc2l0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIFwic3RlbS1cIiArIHRoaXMuY3VycmVudFN0ZW0uaG9yaXpvbnRhbCk7XHJcbiAgICAgIHRoaXMuYWRhcHRlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgXCJzdGVtLVwiICsgdGhpcy5jdXJyZW50U3RlbS52ZXJ0aWNhbCk7XHJcbiAgICB9XHJcbiAgICBjbG9zZUJ1dHRvbklubmVyID0gWzAsIDBdO1xyXG4gICAgY2xvc2VCdXR0b25PdXRlciA9IFswLCAwXTtcclxuICAgIGlmIChfX2luZGV4T2YuY2FsbCh0aGlzLm9wdGlvbnMuaGlkZVRyaWdnZXJzLCBcImNsb3NlQnV0dG9uXCIpID49IDApIHtcclxuICAgICAgY2xvc2VCdXR0b24gPSBuZXcgT3BlbnRpcC5Kb2ludCgoKF9yZWYxID0gdGhpcy5jdXJyZW50U3RlbSkgIT0gbnVsbCA/IF9yZWYxLnRvU3RyaW5nKCkgOiB2b2lkIDApID09PSBcInRvcCByaWdodFwiID8gXCJ0b3AgbGVmdFwiIDogXCJ0b3AgcmlnaHRcIik7XHJcbiAgICAgIGNsb3NlQnV0dG9uSW5uZXIgPSBbdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uUmFkaXVzICsgdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uT2Zmc2V0WzBdLCB0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25SYWRpdXMgKyB0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25PZmZzZXRbMV1dO1xyXG4gICAgICBjbG9zZUJ1dHRvbk91dGVyID0gW3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvblJhZGl1cyAtIHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFswXSwgdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uUmFkaXVzIC0gdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uT2Zmc2V0WzFdXTtcclxuICAgIH1cclxuICAgIGNhbnZhc0RpbWVuc2lvbnMgPSB0aGlzLmFkYXB0ZXIuY2xvbmUodGhpcy5kaW1lbnNpb25zKTtcclxuICAgIGNhbnZhc1Bvc2l0aW9uID0gWzAsIDBdO1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCkge1xyXG4gICAgICBjYW52YXNEaW1lbnNpb25zLndpZHRoICs9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCAqIDI7XHJcbiAgICAgIGNhbnZhc0RpbWVuc2lvbnMuaGVpZ2h0ICs9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCAqIDI7XHJcbiAgICAgIGNhbnZhc1Bvc2l0aW9uWzBdIC09IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcclxuICAgICAgY2FudmFzUG9zaXRpb25bMV0gLT0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaGFkb3cpIHtcclxuICAgICAgY2FudmFzRGltZW5zaW9ucy53aWR0aCArPSB0aGlzLm9wdGlvbnMuc2hhZG93Qmx1ciAqIDI7XHJcbiAgICAgIGNhbnZhc0RpbWVuc2lvbnMud2lkdGggKz0gTWF0aC5tYXgoMCwgdGhpcy5vcHRpb25zLnNoYWRvd09mZnNldFswXSAtIHRoaXMub3B0aW9ucy5zaGFkb3dCbHVyICogMik7XHJcbiAgICAgIGNhbnZhc0RpbWVuc2lvbnMuaGVpZ2h0ICs9IHRoaXMub3B0aW9ucy5zaGFkb3dCbHVyICogMjtcclxuICAgICAgY2FudmFzRGltZW5zaW9ucy5oZWlnaHQgKz0gTWF0aC5tYXgoMCwgdGhpcy5vcHRpb25zLnNoYWRvd09mZnNldFsxXSAtIHRoaXMub3B0aW9ucy5zaGFkb3dCbHVyICogMik7XHJcbiAgICAgIGNhbnZhc1Bvc2l0aW9uWzBdIC09IE1hdGgubWF4KDAsIHRoaXMub3B0aW9ucy5zaGFkb3dCbHVyIC0gdGhpcy5vcHRpb25zLnNoYWRvd09mZnNldFswXSk7XHJcbiAgICAgIGNhbnZhc1Bvc2l0aW9uWzFdIC09IE1hdGgubWF4KDAsIHRoaXMub3B0aW9ucy5zaGFkb3dCbHVyIC0gdGhpcy5vcHRpb25zLnNoYWRvd09mZnNldFsxXSk7XHJcbiAgICB9XHJcbiAgICBidWxnZSA9IHtcclxuICAgICAgbGVmdDogMCxcclxuICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgIHRvcDogMCxcclxuICAgICAgYm90dG9tOiAwXHJcbiAgICB9O1xyXG4gICAgaWYgKHRoaXMuY3VycmVudFN0ZW0pIHtcclxuICAgICAgaWYgKHRoaXMuY3VycmVudFN0ZW0ubGVmdCkge1xyXG4gICAgICAgIGJ1bGdlLmxlZnQgPSB0aGlzLm9wdGlvbnMuc3RlbUxlbmd0aDtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRTdGVtLnJpZ2h0KSB7XHJcbiAgICAgICAgYnVsZ2UucmlnaHQgPSB0aGlzLm9wdGlvbnMuc3RlbUxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5jdXJyZW50U3RlbS50b3ApIHtcclxuICAgICAgICBidWxnZS50b3AgPSB0aGlzLm9wdGlvbnMuc3RlbUxlbmd0aDtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRTdGVtLmJvdHRvbSkge1xyXG4gICAgICAgIGJ1bGdlLmJvdHRvbSA9IHRoaXMub3B0aW9ucy5zdGVtTGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoY2xvc2VCdXR0b24pIHtcclxuICAgICAgaWYgKGNsb3NlQnV0dG9uLmxlZnQpIHtcclxuICAgICAgICBidWxnZS5sZWZ0ID0gTWF0aC5tYXgoYnVsZ2UubGVmdCwgY2xvc2VCdXR0b25PdXRlclswXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2xvc2VCdXR0b24ucmlnaHQpIHtcclxuICAgICAgICBidWxnZS5yaWdodCA9IE1hdGgubWF4KGJ1bGdlLnJpZ2h0LCBjbG9zZUJ1dHRvbk91dGVyWzBdKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2xvc2VCdXR0b24udG9wKSB7XHJcbiAgICAgICAgYnVsZ2UudG9wID0gTWF0aC5tYXgoYnVsZ2UudG9wLCBjbG9zZUJ1dHRvbk91dGVyWzFdKTtcclxuICAgICAgfSBlbHNlIGlmIChjbG9zZUJ1dHRvbi5ib3R0b20pIHtcclxuICAgICAgICBidWxnZS5ib3R0b20gPSBNYXRoLm1heChidWxnZS5ib3R0b20sIGNsb3NlQnV0dG9uT3V0ZXJbMV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjYW52YXNEaW1lbnNpb25zLndpZHRoICs9IGJ1bGdlLmxlZnQgKyBidWxnZS5yaWdodDtcclxuICAgIGNhbnZhc0RpbWVuc2lvbnMuaGVpZ2h0ICs9IGJ1bGdlLnRvcCArIGJ1bGdlLmJvdHRvbTtcclxuICAgIGNhbnZhc1Bvc2l0aW9uWzBdIC09IGJ1bGdlLmxlZnQ7XHJcbiAgICBjYW52YXNQb3NpdGlvblsxXSAtPSBidWxnZS50b3A7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50U3RlbSAmJiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcclxuICAgICAgX3JlZjIgPSB0aGlzLl9nZXRQYXRoU3RlbU1lYXN1cmVzKHRoaXMub3B0aW9ucy5zdGVtQmFzZSwgdGhpcy5vcHRpb25zLnN0ZW1MZW5ndGgsIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCksIHN0ZW1MZW5ndGggPSBfcmVmMi5zdGVtTGVuZ3RoLCBzdGVtQmFzZSA9IF9yZWYyLnN0ZW1CYXNlO1xyXG4gICAgfVxyXG4gICAgYmFja2dyb3VuZENhbnZhcyA9IHRoaXMuYWRhcHRlci51bndyYXAodGhpcy5iYWNrZ3JvdW5kQ2FudmFzKTtcclxuICAgIGJhY2tncm91bmRDYW52YXMud2lkdGggPSBjYW52YXNEaW1lbnNpb25zLndpZHRoO1xyXG4gICAgYmFja2dyb3VuZENhbnZhcy5oZWlnaHQgPSBjYW52YXNEaW1lbnNpb25zLmhlaWdodDtcclxuICAgIHRoaXMuYWRhcHRlci5jc3ModGhpcy5iYWNrZ3JvdW5kQ2FudmFzLCB7XHJcbiAgICAgIHdpZHRoOiBcIlwiICsgYmFja2dyb3VuZENhbnZhcy53aWR0aCArIFwicHhcIixcclxuICAgICAgaGVpZ2h0OiBcIlwiICsgYmFja2dyb3VuZENhbnZhcy5oZWlnaHQgKyBcInB4XCIsXHJcbiAgICAgIGxlZnQ6IFwiXCIgKyBjYW52YXNQb3NpdGlvblswXSArIFwicHhcIixcclxuICAgICAgdG9wOiBcIlwiICsgY2FudmFzUG9zaXRpb25bMV0gKyBcInB4XCJcclxuICAgIH0pO1xyXG4gICAgY3R4ID0gYmFja2dyb3VuZENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBiYWNrZ3JvdW5kQ2FudmFzLndpZHRoLCBiYWNrZ3JvdW5kQ2FudmFzLmhlaWdodCk7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fZ2V0Q29sb3IoY3R4LCB0aGlzLmRpbWVuc2lvbnMsIHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLCB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZEdyYWRpZW50SG9yaXpvbnRhbCk7XHJcbiAgICBjdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XHJcbiAgICBjdHgubWl0ZXJMaW1pdCA9IDUwMDtcclxuICAgIGhiID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoIC8gMjtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcclxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5vcHRpb25zLmJvcmRlckNvbG9yO1xyXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RlbUxlbmd0aCA9IHRoaXMub3B0aW9ucy5zdGVtTGVuZ3RoO1xyXG4gICAgICBzdGVtQmFzZSA9IHRoaXMub3B0aW9ucy5zdGVtQmFzZTtcclxuICAgIH1cclxuICAgIGlmIChzdGVtQmFzZSA9PSBudWxsKSB7XHJcbiAgICAgIHN0ZW1CYXNlID0gMDtcclxuICAgIH1cclxuICAgIGRyYXdMaW5lID0gZnVuY3Rpb24obGVuZ3RoLCBzdGVtLCBmaXJzdCkge1xyXG4gICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICBjdHgubW92ZVRvKE1hdGgubWF4KHN0ZW1CYXNlLCBfdGhpcy5vcHRpb25zLmJvcmRlclJhZGl1cywgY2xvc2VCdXR0b25Jbm5lclswXSkgKyAxIC0gaGIsIC1oYik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0ZW0pIHtcclxuICAgICAgICBjdHgubGluZVRvKGxlbmd0aCAvIDIgLSBzdGVtQmFzZSAvIDIsIC1oYik7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhsZW5ndGggLyAyLCAtc3RlbUxlbmd0aCAtIGhiKTtcclxuICAgICAgICByZXR1cm4gY3R4LmxpbmVUbyhsZW5ndGggLyAyICsgc3RlbUJhc2UgLyAyLCAtaGIpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgZHJhd0Nvcm5lciA9IGZ1bmN0aW9uKHN0ZW0sIGNsb3NlQnV0dG9uLCBpKSB7XHJcbiAgICAgIHZhciBhbmdsZTEsIGFuZ2xlMiwgaW5uZXJXaWR0aCwgb2Zmc2V0O1xyXG4gICAgICBpZiAoc3RlbSkge1xyXG4gICAgICAgIGN0eC5saW5lVG8oLXN0ZW1CYXNlICsgaGIsIDAgLSBoYik7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhzdGVtTGVuZ3RoICsgaGIsIC1zdGVtTGVuZ3RoIC0gaGIpO1xyXG4gICAgICAgIHJldHVybiBjdHgubGluZVRvKGhiLCBzdGVtQmFzZSAtIGhiKTtcclxuICAgICAgfSBlbHNlIGlmIChjbG9zZUJ1dHRvbikge1xyXG4gICAgICAgIG9mZnNldCA9IF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25PZmZzZXQ7XHJcbiAgICAgICAgaW5uZXJXaWR0aCA9IGNsb3NlQnV0dG9uSW5uZXJbMF07XHJcbiAgICAgICAgaWYgKGkgJSAyICE9PSAwKSB7XHJcbiAgICAgICAgICBvZmZzZXQgPSBbb2Zmc2V0WzFdLCBvZmZzZXRbMF1dO1xyXG4gICAgICAgICAgaW5uZXJXaWR0aCA9IGNsb3NlQnV0dG9uSW5uZXJbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFuZ2xlMSA9IE1hdGguYWNvcyhvZmZzZXRbMV0gLyBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uUmFkaXVzKTtcclxuICAgICAgICBhbmdsZTIgPSBNYXRoLmFjb3Mob2Zmc2V0WzBdIC8gX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvblJhZGl1cyk7XHJcbiAgICAgICAgY3R4LmxpbmVUbygtaW5uZXJXaWR0aCArIGhiLCAtaGIpO1xyXG4gICAgICAgIHJldHVybiBjdHguYXJjKGhiIC0gb2Zmc2V0WzBdLCAtaGIgKyBvZmZzZXRbMV0sIF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25SYWRpdXMsIC0oTWF0aC5QSSAvIDIgKyBhbmdsZTEpLCBhbmdsZTIsIGZhbHNlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdHgubGluZVRvKC1fdGhpcy5vcHRpb25zLmJvcmRlclJhZGl1cyArIGhiLCAtaGIpO1xyXG4gICAgICAgIHJldHVybiBjdHgucXVhZHJhdGljQ3VydmVUbyhoYiwgLWhiLCBoYiwgX3RoaXMub3B0aW9ucy5ib3JkZXJSYWRpdXMgLSBoYik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBjdHgudHJhbnNsYXRlKC1jYW52YXNQb3NpdGlvblswXSwgLWNhbnZhc1Bvc2l0aW9uWzFdKTtcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBjb3JuZXJTdGVtLCBpLCBsaW5lTGVuZ3RoLCBsaW5lU3RlbSwgcG9zaXRpb25JZHgsIHBvc2l0aW9uWCwgcG9zaXRpb25ZLCByb3RhdGlvbiwgX2osIF9yZWYzLCBfcmVzdWx0cztcclxuICAgICAgX3Jlc3VsdHMgPSBbXTtcclxuICAgICAgZm9yIChpID0gX2ogPSAwLCBfcmVmMyA9IE9wZW50aXAucG9zaXRpb25zLmxlbmd0aCAvIDI7IDAgPD0gX3JlZjMgPyBfaiA8IF9yZWYzIDogX2ogPiBfcmVmMzsgaSA9IDAgPD0gX3JlZjMgPyArK19qIDogLS1faikge1xyXG4gICAgICAgIHBvc2l0aW9uSWR4ID0gaSAqIDI7XHJcbiAgICAgICAgcG9zaXRpb25YID0gaSA9PT0gMCB8fCBpID09PSAzID8gMCA6IF90aGlzLmRpbWVuc2lvbnMud2lkdGg7XHJcbiAgICAgICAgcG9zaXRpb25ZID0gaSA8IDIgPyAwIDogX3RoaXMuZGltZW5zaW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgcm90YXRpb24gPSAoTWF0aC5QSSAvIDIpICogaTtcclxuICAgICAgICBsaW5lTGVuZ3RoID0gaSAlIDIgPT09IDAgPyBfdGhpcy5kaW1lbnNpb25zLndpZHRoIDogX3RoaXMuZGltZW5zaW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgbGluZVN0ZW0gPSBuZXcgT3BlbnRpcC5Kb2ludChPcGVudGlwLnBvc2l0aW9uc1twb3NpdGlvbklkeF0pO1xyXG4gICAgICAgIGNvcm5lclN0ZW0gPSBuZXcgT3BlbnRpcC5Kb2ludChPcGVudGlwLnBvc2l0aW9uc1twb3NpdGlvbklkeCArIDFdKTtcclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUocG9zaXRpb25YLCBwb3NpdGlvblkpO1xyXG4gICAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xyXG4gICAgICAgIGRyYXdMaW5lKGxpbmVMZW5ndGgsIGxpbmVTdGVtLmVxbChfdGhpcy5jdXJyZW50U3RlbSksIGkgPT09IDApO1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUobGluZUxlbmd0aCwgMCk7XHJcbiAgICAgICAgZHJhd0Nvcm5lcihjb3JuZXJTdGVtLmVxbChfdGhpcy5jdXJyZW50U3RlbSksIGNvcm5lclN0ZW0uZXFsKGNsb3NlQnV0dG9uKSwgaSk7XHJcbiAgICAgICAgX3Jlc3VsdHMucHVzaChjdHgucmVzdG9yZSgpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XHJcbiAgICB9KSgpO1xyXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhZG93KSB7XHJcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMub3B0aW9ucy5zaGFkb3dDb2xvcjtcclxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLm9wdGlvbnMuc2hhZG93Qmx1cjtcclxuICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLm9wdGlvbnMuc2hhZG93T2Zmc2V0WzBdO1xyXG4gICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMub3B0aW9ucy5zaGFkb3dPZmZzZXRbMV07XHJcbiAgICB9XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcclxuICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIGlmIChjbG9zZUJ1dHRvbikge1xyXG4gICAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjcm9zc0NlbnRlciwgY3Jvc3NIZWlnaHQsIGNyb3NzV2lkdGgsIGhjcywgbGlua0NlbnRlcjtcclxuICAgICAgICBjcm9zc1dpZHRoID0gY3Jvc3NIZWlnaHQgPSBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uUmFkaXVzICogMjtcclxuICAgICAgICBpZiAoY2xvc2VCdXR0b24udG9TdHJpbmcoKSA9PT0gXCJ0b3AgcmlnaHRcIikge1xyXG4gICAgICAgICAgbGlua0NlbnRlciA9IFtfdGhpcy5kaW1lbnNpb25zLndpZHRoIC0gX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFswXSwgX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFsxXV07XHJcbiAgICAgICAgICBjcm9zc0NlbnRlciA9IFtsaW5rQ2VudGVyWzBdICsgaGIsIGxpbmtDZW50ZXJbMV0gLSBoYl07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxpbmtDZW50ZXIgPSBbX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFswXSwgX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFsxXV07XHJcbiAgICAgICAgICBjcm9zc0NlbnRlciA9IFtsaW5rQ2VudGVyWzBdIC0gaGIsIGxpbmtDZW50ZXJbMV0gLSBoYl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC50cmFuc2xhdGUoY3Jvc3NDZW50ZXJbMF0sIGNyb3NzQ2VudGVyWzFdKTtcclxuICAgICAgICBoY3MgPSBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uQ3Jvc3NTaXplIC8gMjtcclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uQ3Jvc3NDb2xvcjtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbkNyb3NzTGluZVdpZHRoO1xyXG4gICAgICAgIGN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oLWhjcywgLWhjcyk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhoY3MsIGhjcyk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubW92ZVRvKGhjcywgLWhjcyk7XHJcbiAgICAgICAgY3R4LmxpbmVUbygtaGNzLCBoY3MpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcy5hZGFwdGVyLmNzcyhfdGhpcy5jbG9zZUJ1dHRvbkVsZW1lbnQsIHtcclxuICAgICAgICAgIGxlZnQ6IFwiXCIgKyAobGlua0NlbnRlclswXSAtIGhjcyAtIF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25MaW5rT3ZlcnNjYW4pICsgXCJweFwiLFxyXG4gICAgICAgICAgdG9wOiBcIlwiICsgKGxpbmtDZW50ZXJbMV0gLSBoY3MgLSBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uTGlua092ZXJzY2FuKSArIFwicHhcIixcclxuICAgICAgICAgIHdpZHRoOiBcIlwiICsgKF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25Dcm9zc1NpemUgKyBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uTGlua092ZXJzY2FuICogMikgKyBcInB4XCIsXHJcbiAgICAgICAgICBoZWlnaHQ6IFwiXCIgKyAoX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbkNyb3NzU2l6ZSArIF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25MaW5rT3ZlcnNjYW4gKiAyKSArIFwicHhcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLl9nZXRQYXRoU3RlbU1lYXN1cmVzID0gZnVuY3Rpb24ob3V0ZXJTdGVtQmFzZSwgb3V0ZXJTdGVtTGVuZ3RoLCBib3JkZXJXaWR0aCkge1xyXG4gICAgdmFyIGFuZ2xlLCBkaXN0YW5jZUJldHdlZW5UaXBzLCBoYWxmQW5nbGUsIGhiLCByaG9tYnVzU2lkZSwgc3RlbUJhc2UsIHN0ZW1MZW5ndGg7XHJcbiAgICBoYiA9IGJvcmRlcldpZHRoIC8gMjtcclxuICAgIGhhbGZBbmdsZSA9IE1hdGguYXRhbigob3V0ZXJTdGVtQmFzZSAvIDIpIC8gb3V0ZXJTdGVtTGVuZ3RoKTtcclxuICAgIGFuZ2xlID0gaGFsZkFuZ2xlICogMjtcclxuICAgIHJob21idXNTaWRlID0gaGIgLyBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICBkaXN0YW5jZUJldHdlZW5UaXBzID0gMiAqIHJob21idXNTaWRlICogTWF0aC5jb3MoaGFsZkFuZ2xlKTtcclxuICAgIHN0ZW1MZW5ndGggPSBoYiArIG91dGVyU3RlbUxlbmd0aCAtIGRpc3RhbmNlQmV0d2VlblRpcHM7XHJcbiAgICBpZiAoc3RlbUxlbmd0aCA8IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29ycnkgYnV0IHlvdXIgc3RlbUxlbmd0aCAvIHN0ZW1CYXNlIHJhdGlvIGlzIHN0cmFuZ2UuXCIpO1xyXG4gICAgfVxyXG4gICAgc3RlbUJhc2UgPSAoTWF0aC50YW4oaGFsZkFuZ2xlKSAqIHN0ZW1MZW5ndGgpICogMjtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0ZW1MZW5ndGg6IHN0ZW1MZW5ndGgsXHJcbiAgICAgIHN0ZW1CYXNlOiBzdGVtQmFzZVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5fZ2V0Q29sb3IgPSBmdW5jdGlvbihjdHgsIGRpbWVuc2lvbnMsIGNvbG9yLCBob3Jpem9udGFsKSB7XHJcbiAgICB2YXIgY29sb3JTdG9wLCBncmFkaWVudCwgaSwgX2ksIF9sZW47XHJcbiAgICBpZiAoaG9yaXpvbnRhbCA9PSBudWxsKSB7XHJcbiAgICAgIGhvcml6b250YWwgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgfVxyXG4gICAgaWYgKGhvcml6b250YWwpIHtcclxuICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgZGltZW5zaW9ucy53aWR0aCwgMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBkaW1lbnNpb25zLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSBjb2xvci5sZW5ndGg7IF9pIDwgX2xlbjsgaSA9ICsrX2kpIHtcclxuICAgICAgY29sb3JTdG9wID0gY29sb3JbaV07XHJcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChjb2xvclN0b3BbMF0sIGNvbG9yU3RvcFsxXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ3JhZGllbnQ7XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX3NlYXJjaEFuZEFjdGl2YXRlQ2xvc2VCdXR0b25zID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZWxlbWVudCwgX2ksIF9sZW4sIF9yZWY7XHJcbiAgICBfcmVmID0gdGhpcy5hZGFwdGVyLmZpbmRBbGwodGhpcy5jb250YWluZXIsIFwiLlwiICsgdGhpc1tcImNsYXNzXCJdLmNsb3NlKTtcclxuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xyXG4gICAgICBlbGVtZW50ID0gX3JlZltfaV07XHJcbiAgICAgIHRoaXMuaGlkZVRyaWdnZXJzLnB1c2goe1xyXG4gICAgICAgIGVsZW1lbnQ6IHRoaXMuYWRhcHRlci53cmFwKGVsZW1lbnQpLFxyXG4gICAgICAgIGV2ZW50OiBcImNsaWNrXCJcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jdXJyZW50T2JzZXJ2ZXJzLnNob3dpbmcpIHtcclxuICAgICAgdGhpcy5fc2V0dXBPYnNlcnZlcnMoXCItc2hvd2luZ1wiLCBcInNob3dpbmdcIik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jdXJyZW50T2JzZXJ2ZXJzLnZpc2libGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3NldHVwT2JzZXJ2ZXJzKFwiLXZpc2libGVcIiwgXCJ2aXNpYmxlXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLl9hY3RpdmF0ZUZpcnN0SW5wdXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpbnB1dDtcclxuICAgIGlucHV0ID0gdGhpcy5hZGFwdGVyLnVud3JhcCh0aGlzLmFkYXB0ZXIuZmluZCh0aGlzLmNvbnRhaW5lciwgXCJpbnB1dCwgdGV4dGFyZWFcIikpO1xyXG4gICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0eXBlb2YgaW5wdXQuZm9jdXMgPT09IFwiZnVuY3Rpb25cIiA/IGlucHV0LmZvY3VzKCkgOiB2b2lkIDAgOiB2b2lkIDA7XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX2ZvbGxvd01vdXNlUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5vcHRpb25zLmZpeGVkKSB7XHJcbiAgICAgIHJldHVybiBPcGVudGlwLl9vYnNlcnZlTW91c2VQb3NpdGlvbih0aGlzLmJvdW5kLnJlcG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLl9zdG9wRm9sbG93aW5nTW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZml4ZWQpIHtcclxuICAgICAgcmV0dXJuIE9wZW50aXAuX3N0b3BPYnNlcnZpbmdNb3VzZVBvc2l0aW9uKHRoaXMuYm91bmQucmVwb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX2NsZWFyU2hvd1RpbWVvdXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbWVvdXRJZCk7XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX2NsZWFySGlkZVRpbWVvdXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVvdXRJZCk7XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX2NsZWFyVGltZW91dHMgPSBmdW5jdGlvbigpIHtcclxuICAgIGNsZWFyVGltZW91dCh0aGlzLl92aXNpYmlsaXR5U3RhdGVUaW1lb3V0SWQpO1xyXG4gICAgdGhpcy5fY2xlYXJTaG93VGltZW91dCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuX2NsZWFySGlkZVRpbWVvdXQoKTtcclxuICB9O1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5fdHJpZ2dlckVsZW1lbnRFeGlzdHMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBlbDtcclxuICAgIGVsID0gdGhpcy5hZGFwdGVyLnVud3JhcCh0aGlzLnRyaWdnZXJFbGVtZW50KTtcclxuICAgIHdoaWxlIChlbC5wYXJlbnROb2RlKSB7XHJcbiAgICAgIGlmIChlbC5wYXJlbnROb2RlLnRhZ05hbWUgPT09IFwiQk9EWVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLl9sb2FkQWpheCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcclxuICAgIHRoaXMubG9hZGluZyA9IHRydWU7XHJcbiAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXNbXCJjbGFzc1wiXS5sb2FkaW5nKTtcclxuICAgIHRoaXMuc2V0Q29udGVudChcIlwiKTtcclxuICAgIHRoaXMuZGVidWcoXCJMb2FkaW5nIGNvbnRlbnQgZnJvbSBcIiArIHRoaXMub3B0aW9ucy5hamF4KTtcclxuICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuYWpheCh7XHJcbiAgICAgIHVybDogdGhpcy5vcHRpb25zLmFqYXgsXHJcbiAgICAgIG1ldGhvZDogdGhpcy5vcHRpb25zLmFqYXhNZXRob2QsXHJcbiAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24ocmVzcG9uc2VUZXh0KSB7XHJcbiAgICAgICAgX3RoaXMuZGVidWcoXCJMb2FkaW5nIHN1Y2Nlc3NmdWwuXCIpO1xyXG4gICAgICAgIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoX3RoaXMuY29udGFpbmVyLCBfdGhpc1tcImNsYXNzXCJdLmxvYWRpbmcpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcy5zZXRDb250ZW50KHJlc3BvbnNlVGV4dCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2U7XHJcbiAgICAgICAgbWVzc2FnZSA9IF90aGlzLm9wdGlvbnMuYWpheEVycm9yTWVzc2FnZTtcclxuICAgICAgICBfdGhpcy5kZWJ1ZyhtZXNzYWdlLCBlcnJvcik7XHJcbiAgICAgICAgX3RoaXMuc2V0Q29udGVudChtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhfdGhpcy5jb250YWluZXIsIF90aGlzW1wiY2xhc3NcIl0uYWpheEVycm9yKTtcclxuICAgICAgfSxcclxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX3RoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhfdGhpcy5jb250YWluZXIsIF90aGlzW1wiY2xhc3NcIl0ubG9hZGluZyk7XHJcbiAgICAgICAgX3RoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuX3NlYXJjaEFuZEFjdGl2YXRlQ2xvc2VCdXR0b25zKCk7XHJcbiAgICAgICAgX3RoaXMuX2FjdGl2YXRlRmlyc3RJbnB1dCgpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcy5yZXBvc2l0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLl9lbnN1cmVUcmlnZ2VyRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLl90cmlnZ2VyRWxlbWVudEV4aXN0cygpKSB7XHJcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fc3RvcEVuc3VyZVRyaWdnZXJFbGVtZW50KCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgT3BlbnRpcC5wcm90b3R5cGUuX2Vuc3VyZVRyaWdnZXJFbGVtZW50SW50ZXJ2YWwgPSAxMDAwO1xyXG5cclxuICBPcGVudGlwLnByb3RvdHlwZS5fc3RhcnRFbnN1cmVUcmlnZ2VyRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHJldHVybiB0aGlzLl9lbnN1cmVUcmlnZ2VyRWxlbWVudFRpbWVvdXRJZCA9IHNldEludGVydmFsKChmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIF90aGlzLl9lbnN1cmVUcmlnZ2VyRWxlbWVudCgpO1xyXG4gICAgfSksIHRoaXMuX2Vuc3VyZVRyaWdnZXJFbGVtZW50SW50ZXJ2YWwpO1xyXG4gIH07XHJcblxyXG4gIE9wZW50aXAucHJvdG90eXBlLl9zdG9wRW5zdXJlVHJpZ2dlckVsZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBjbGVhckludGVydmFsKHRoaXMuX2Vuc3VyZVRyaWdnZXJFbGVtZW50VGltZW91dElkKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gT3BlbnRpcDtcclxuXHJcbn0pKCk7XHJcblxyXG52ZW5kb3JzID0gW1wia2h0bWxcIiwgXCJtc1wiLCBcIm9cIiwgXCJtb3pcIiwgXCJ3ZWJraXRcIl07XHJcblxyXG5PcGVudGlwLnByb3RvdHlwZS5zZXRDc3MzU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZXMpIHtcclxuICB2YXIgcHJvcCwgdmFsdWUsIHZlbmRvciwgdmVuZG9yUHJvcCwgX3Jlc3VsdHM7XHJcbiAgZWxlbWVudCA9IHRoaXMuYWRhcHRlci51bndyYXAoZWxlbWVudCk7XHJcbiAgX3Jlc3VsdHMgPSBbXTtcclxuICBmb3IgKHByb3AgaW4gc3R5bGVzKSB7XHJcbiAgICBpZiAoIV9faGFzUHJvcC5jYWxsKHN0eWxlcywgcHJvcCkpIGNvbnRpbnVlO1xyXG4gICAgdmFsdWUgPSBzdHlsZXNbcHJvcF07XHJcbiAgICBpZiAoZWxlbWVudC5zdHlsZVtwcm9wXSAhPSBudWxsKSB7XHJcbiAgICAgIF9yZXN1bHRzLnB1c2goZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHMxO1xyXG4gICAgICAgIF9yZXN1bHRzMSA9IFtdO1xyXG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdmVuZG9ycy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xyXG4gICAgICAgICAgdmVuZG9yID0gdmVuZG9yc1tfaV07XHJcbiAgICAgICAgICB2ZW5kb3JQcm9wID0gXCJcIiArICh0aGlzLnVjZmlyc3QodmVuZG9yKSkgKyAodGhpcy51Y2ZpcnN0KHByb3ApKTtcclxuICAgICAgICAgIGlmIChlbGVtZW50LnN0eWxlW3ZlbmRvclByb3BdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2goZWxlbWVudC5zdHlsZVt2ZW5kb3JQcm9wXSA9IHZhbHVlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHZvaWQgMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfcmVzdWx0czE7XHJcbiAgICAgIH0pLmNhbGwodGhpcykpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gX3Jlc3VsdHM7XHJcbn07XHJcblxyXG5PcGVudGlwLnByb3RvdHlwZS5kZWZlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICByZXR1cm4gc2V0VGltZW91dChmdW5jLCAwKTtcclxufTtcclxuXHJcbk9wZW50aXAucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbihmdW5jLCBzZWNvbmRzKSB7XHJcbiAgcmV0dXJuIHNldFRpbWVvdXQoZnVuYywgc2Vjb25kcyA/IHNlY29uZHMgKiAxMDAwIDogMCk7XHJcbn07XHJcblxyXG5PcGVudGlwLnByb3RvdHlwZS51Y2ZpcnN0ID0gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgaWYgKHN0cmluZyA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gXCJcIjtcclxuICB9XHJcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcclxufTtcclxuXHJcbk9wZW50aXAucHJvdG90eXBlLmRhc2hlcml6ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xyXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihfLCBjaGFyYWN0ZXIpIHtcclxuICAgIHJldHVybiBcIi1cIiArIChjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5tb3VzZVBvc2l0aW9uT2JzZXJ2ZXJzID0gW107XHJcblxyXG5tb3VzZVBvc2l0aW9uID0ge1xyXG4gIHg6IDAsXHJcbiAgeTogMFxyXG59O1xyXG5cclxubW91c2VNb3ZlZCA9IGZ1bmN0aW9uKGUpIHtcclxuICB2YXIgb2JzZXJ2ZXIsIF9pLCBfbGVuLCBfcmVzdWx0cztcclxuICBtb3VzZVBvc2l0aW9uID0gT3BlbnRpcC5hZGFwdGVyLm1vdXNlUG9zaXRpb24oZSk7XHJcbiAgX3Jlc3VsdHMgPSBbXTtcclxuICBmb3IgKF9pID0gMCwgX2xlbiA9IG1vdXNlUG9zaXRpb25PYnNlcnZlcnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcclxuICAgIG9ic2VydmVyID0gbW91c2VQb3NpdGlvbk9ic2VydmVyc1tfaV07XHJcbiAgICBfcmVzdWx0cy5wdXNoKG9ic2VydmVyKCkpO1xyXG4gIH1cclxuICByZXR1cm4gX3Jlc3VsdHM7XHJcbn07XHJcblxyXG5PcGVudGlwLmZvbGxvd01vdXNlUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gT3BlbnRpcC5hZGFwdGVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlZCk7XHJcbn07XHJcblxyXG5PcGVudGlwLl9vYnNlcnZlTW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uKG9ic2VydmVyKSB7XHJcbiAgcmV0dXJuIG1vdXNlUG9zaXRpb25PYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XHJcbn07XHJcblxyXG5PcGVudGlwLl9zdG9wT2JzZXJ2aW5nTW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uKHJlbW92ZU9ic2VydmVyKSB7XHJcbiAgdmFyIG9ic2VydmVyO1xyXG4gIHJldHVybiBtb3VzZVBvc2l0aW9uT2JzZXJ2ZXJzID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcclxuICAgIF9yZXN1bHRzID0gW107XHJcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG1vdXNlUG9zaXRpb25PYnNlcnZlcnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcclxuICAgICAgb2JzZXJ2ZXIgPSBtb3VzZVBvc2l0aW9uT2JzZXJ2ZXJzW19pXTtcclxuICAgICAgaWYgKG9ic2VydmVyICE9PSByZW1vdmVPYnNlcnZlcikge1xyXG4gICAgICAgIF9yZXN1bHRzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX3Jlc3VsdHM7XHJcbiAgfSkoKTtcclxufTtcclxuXHJcbk9wZW50aXAuSm9pbnQgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gIGZ1bmN0aW9uIEpvaW50KHBvaW50ZXJTdHJpbmcpIHtcclxuICAgIGlmIChwb2ludGVyU3RyaW5nID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHBvaW50ZXJTdHJpbmcgaW5zdGFuY2VvZiBPcGVudGlwLkpvaW50KSB7XHJcbiAgICAgIHBvaW50ZXJTdHJpbmcgPSBwb2ludGVyU3RyaW5nLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNldChwb2ludGVyU3RyaW5nKTtcclxuICAgIHRoaXM7XHJcblxyXG4gIH1cclxuXHJcbiAgSm9pbnQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHN0cmluZykge1xyXG4gICAgc3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB0aGlzLnNldEhvcml6b250YWwoc3RyaW5nKTtcclxuICAgIHRoaXMuc2V0VmVydGljYWwoc3RyaW5nKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEpvaW50LnByb3RvdHlwZS5zZXRIb3Jpem9udGFsID0gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICB2YXIgaSwgdmFsaWQsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZXN1bHRzO1xyXG4gICAgdmFsaWQgPSBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl07XHJcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHZhbGlkLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XHJcbiAgICAgIGkgPSB2YWxpZFtfaV07XHJcbiAgICAgIGlmICh+c3RyaW5nLmluZGV4T2YoaSkpIHtcclxuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLmhvcml6b250YWwgPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLmhvcml6b250YWwgPSBcImNlbnRlclwiO1xyXG4gICAgfVxyXG4gICAgX3Jlc3VsdHMgPSBbXTtcclxuICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IHZhbGlkLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xyXG4gICAgICBpID0gdmFsaWRbX2pdO1xyXG4gICAgICBfcmVzdWx0cy5wdXNoKHRoaXNbaV0gPSB0aGlzLmhvcml6b250YWwgPT09IGkgPyBpIDogdm9pZCAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfcmVzdWx0cztcclxuICB9O1xyXG5cclxuICBKb2ludC5wcm90b3R5cGUuc2V0VmVydGljYWwgPSBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgIHZhciBpLCB2YWxpZCwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3Jlc3VsdHM7XHJcbiAgICB2YWxpZCA9IFtcInRvcFwiLCBcIm1pZGRsZVwiLCBcImJvdHRvbVwiXTtcclxuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdmFsaWQubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcclxuICAgICAgaSA9IHZhbGlkW19pXTtcclxuICAgICAgaWYgKH5zdHJpbmcuaW5kZXhPZihpKSkge1xyXG4gICAgICAgIHRoaXMudmVydGljYWwgPSBpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLnZlcnRpY2FsID09IG51bGwpIHtcclxuICAgICAgdGhpcy52ZXJ0aWNhbCA9IFwibWlkZGxlXCI7XHJcbiAgICB9XHJcbiAgICBfcmVzdWx0cyA9IFtdO1xyXG4gICAgZm9yIChfaiA9IDAsIF9sZW4xID0gdmFsaWQubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XHJcbiAgICAgIGkgPSB2YWxpZFtfal07XHJcbiAgICAgIF9yZXN1bHRzLnB1c2godGhpc1tpXSA9IHRoaXMudmVydGljYWwgPT09IGkgPyBpIDogdm9pZCAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfcmVzdWx0cztcclxuICB9O1xyXG5cclxuICBKb2ludC5wcm90b3R5cGUuZXFsID0gZnVuY3Rpb24ocG9pbnRlcikge1xyXG4gICAgcmV0dXJuIChwb2ludGVyICE9IG51bGwpICYmIHRoaXMuaG9yaXpvbnRhbCA9PT0gcG9pbnRlci5ob3Jpem9udGFsICYmIHRoaXMudmVydGljYWwgPT09IHBvaW50ZXIudmVydGljYWw7XHJcbiAgfTtcclxuXHJcbiAgSm9pbnQucHJvdG90eXBlLmZsaXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBmbGlwcGVkSW5kZXgsIHBvc2l0aW9uSWR4O1xyXG4gICAgcG9zaXRpb25JZHggPSBPcGVudGlwLnBvc2l0aW9uW3RoaXMudG9TdHJpbmcodHJ1ZSldO1xyXG4gICAgZmxpcHBlZEluZGV4ID0gKHBvc2l0aW9uSWR4ICsgNCkgJSA4O1xyXG4gICAgdGhpcy5zZXQoT3BlbnRpcC5wb3NpdGlvbnNbZmxpcHBlZEluZGV4XSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBKb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihjYW1lbGl6ZWQpIHtcclxuICAgIHZhciBob3Jpem9udGFsLCB2ZXJ0aWNhbDtcclxuICAgIGlmIChjYW1lbGl6ZWQgPT0gbnVsbCkge1xyXG4gICAgICBjYW1lbGl6ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHZlcnRpY2FsID0gdGhpcy52ZXJ0aWNhbCA9PT0gXCJtaWRkbGVcIiA/IFwiXCIgOiB0aGlzLnZlcnRpY2FsO1xyXG4gICAgaG9yaXpvbnRhbCA9IHRoaXMuaG9yaXpvbnRhbCA9PT0gXCJjZW50ZXJcIiA/IFwiXCIgOiB0aGlzLmhvcml6b250YWw7XHJcbiAgICBpZiAodmVydGljYWwgJiYgaG9yaXpvbnRhbCkge1xyXG4gICAgICBpZiAoY2FtZWxpemVkKSB7XHJcbiAgICAgICAgaG9yaXpvbnRhbCA9IE9wZW50aXAucHJvdG90eXBlLnVjZmlyc3QoaG9yaXpvbnRhbCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaG9yaXpvbnRhbCA9IFwiIFwiICsgaG9yaXpvbnRhbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiXCIgKyB2ZXJ0aWNhbCArIGhvcml6b250YWw7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEpvaW50O1xyXG5cclxufSkoKTtcclxuXHJcbk9wZW50aXAucHJvdG90eXBlLl9wb3NpdGlvbnNFcXVhbCA9IGZ1bmN0aW9uKHBvc0EsIHBvc0IpIHtcclxuICByZXR1cm4gKHBvc0EgIT0gbnVsbCkgJiYgKHBvc0IgIT0gbnVsbCkgJiYgcG9zQS5sZWZ0ID09PSBwb3NCLmxlZnQgJiYgcG9zQS50b3AgPT09IHBvc0IudG9wO1xyXG59O1xyXG5cclxuT3BlbnRpcC5wcm90b3R5cGUuX2RpbWVuc2lvbnNFcXVhbCA9IGZ1bmN0aW9uKGRpbUEsIGRpbUIpIHtcclxuICByZXR1cm4gKGRpbUEgIT0gbnVsbCkgJiYgKGRpbUIgIT0gbnVsbCkgJiYgZGltQS53aWR0aCA9PT0gZGltQi53aWR0aCAmJiBkaW1BLmhlaWdodCA9PT0gZGltQi5oZWlnaHQ7XHJcbn07XHJcblxyXG5PcGVudGlwLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBhcmdzO1xyXG4gIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xyXG4gIGlmIChPcGVudGlwLmRlYnVnICYmICgodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZSAhPT0gbnVsbCA/IGNvbnNvbGUuZGVidWcgOiB2b2lkIDApICE9IG51bGwpKSB7XHJcbiAgICBhcmdzLnVuc2hpZnQoXCIjXCIgKyB0aGlzLmlkICsgXCIgfFwiKTtcclxuICAgIHJldHVybiBjb25zb2xlLmRlYnVnLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gIH1cclxufTtcclxuXHJcbk9wZW50aXAuZmluZEVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGFkYXB0ZXIsIGNvbnRlbnQsIGVsZW1lbnQsIG9wdGlvbk5hbWUsIG9wdGlvblZhbHVlLCBvcHRpb25zLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XHJcbiAgYWRhcHRlciA9IE9wZW50aXAuYWRhcHRlcjtcclxuICBfcmVmID0gYWRhcHRlci5maW5kQWxsKGRvY3VtZW50LmJvZHksIFwiW2RhdGEtb3RdXCIpO1xyXG4gIF9yZXN1bHRzID0gW107XHJcbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XHJcbiAgICBlbGVtZW50ID0gX3JlZltfaV07XHJcbiAgICBvcHRpb25zID0ge307XHJcbiAgICBjb250ZW50ID0gYWRhcHRlci5kYXRhKGVsZW1lbnQsIFwib3RcIik7XHJcbiAgICBpZiAoY29udGVudCA9PT0gXCJcIiB8fCBjb250ZW50ID09PSBcInRydWVcIiB8fCBjb250ZW50ID09PSBcInllc1wiKSB7XHJcbiAgICAgIGNvbnRlbnQgPSBhZGFwdGVyLmF0dHIoZWxlbWVudCwgXCJ0aXRsZVwiKTtcclxuICAgICAgYWRhcHRlci5hdHRyKGVsZW1lbnQsIFwidGl0bGVcIiwgXCJcIik7XHJcbiAgICB9XHJcbiAgICBjb250ZW50ID0gY29udGVudCB8fCBcIlwiO1xyXG4gICAgZm9yIChvcHRpb25OYW1lIGluIE9wZW50aXAuc3R5bGVzLnN0YW5kYXJkKSB7XHJcbiAgICAgIG9wdGlvblZhbHVlID0gYWRhcHRlci5kYXRhKGVsZW1lbnQsIFwib3RcIiArIChPcGVudGlwLnByb3RvdHlwZS51Y2ZpcnN0KG9wdGlvbk5hbWUpKSk7XHJcbiAgICAgIGlmIChvcHRpb25WYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvblZhbHVlID09PSBcInllc1wiIHx8IG9wdGlvblZhbHVlID09PSBcInRydWVcIiB8fCBvcHRpb25WYWx1ZSA9PT0gXCJvblwiKSB7XHJcbiAgICAgICAgICBvcHRpb25WYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25WYWx1ZSA9PT0gXCJub1wiIHx8IG9wdGlvblZhbHVlID09PSBcImZhbHNlXCIgfHwgb3B0aW9uVmFsdWUgPT09IFwib2ZmXCIpIHtcclxuICAgICAgICAgIG9wdGlvblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSBvcHRpb25WYWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Jlc3VsdHMucHVzaChuZXcgT3BlbnRpcChlbGVtZW50LCBjb250ZW50LCBvcHRpb25zKSk7XHJcbiAgfVxyXG4gIHJldHVybiBfcmVzdWx0cztcclxufTtcclxuXHJcbk9wZW50aXAudmVyc2lvbiA9IFwiMi40LjZcIjtcclxuXHJcbk9wZW50aXAuZGVidWcgPSBmYWxzZTtcclxuXHJcbk9wZW50aXAubGFzdElkID0gMDtcclxuXHJcbk9wZW50aXAubGFzdFpJbmRleCA9IDEwMDtcclxuXHJcbk9wZW50aXAudGlwcyA9IFtdO1xyXG5cclxuT3BlbnRpcC5fYWJvcnRTaG93aW5nR3JvdXAgPSBmdW5jdGlvbihncm91cCwgb3JpZ2luYXRpbmdPcGVudGlwKSB7XHJcbiAgdmFyIG9wZW50aXAsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcclxuICBfcmVmID0gT3BlbnRpcC50aXBzO1xyXG4gIF9yZXN1bHRzID0gW107XHJcbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XHJcbiAgICBvcGVudGlwID0gX3JlZltfaV07XHJcbiAgICBpZiAob3BlbnRpcCAhPT0gb3JpZ2luYXRpbmdPcGVudGlwICYmIG9wZW50aXAub3B0aW9ucy5ncm91cCA9PT0gZ3JvdXApIHtcclxuICAgICAgX3Jlc3VsdHMucHVzaChvcGVudGlwLl9hYm9ydFNob3dpbmcoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBfcmVzdWx0cztcclxufTtcclxuXHJcbk9wZW50aXAuX2hpZGVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcmlnaW5hdGluZ09wZW50aXApIHtcclxuICB2YXIgb3BlbnRpcCwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xyXG4gIF9yZWYgPSBPcGVudGlwLnRpcHM7XHJcbiAgX3Jlc3VsdHMgPSBbXTtcclxuICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcclxuICAgIG9wZW50aXAgPSBfcmVmW19pXTtcclxuICAgIGlmIChvcGVudGlwICE9PSBvcmlnaW5hdGluZ09wZW50aXAgJiYgb3BlbnRpcC5vcHRpb25zLmdyb3VwID09PSBncm91cCkge1xyXG4gICAgICBfcmVzdWx0cy5wdXNoKG9wZW50aXAuaGlkZSgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIF9yZXN1bHRzO1xyXG59O1xyXG5cclxuT3BlbnRpcC5hZGFwdGVycyA9IHt9O1xyXG5cclxuT3BlbnRpcC5hZGFwdGVyID0gbnVsbDtcclxuXHJcbmZpcnN0QWRhcHRlciA9IHRydWU7XHJcblxyXG5PcGVudGlwLmFkZEFkYXB0ZXIgPSBmdW5jdGlvbihhZGFwdGVyKSB7XHJcbiAgT3BlbnRpcC5hZGFwdGVyc1thZGFwdGVyLm5hbWVdID0gYWRhcHRlcjtcclxuICBpZiAoZmlyc3RBZGFwdGVyKSB7XHJcbiAgICBPcGVudGlwLmFkYXB0ZXIgPSBhZGFwdGVyO1xyXG4gICAgYWRhcHRlci5kb21SZWFkeShPcGVudGlwLmZpbmRFbGVtZW50cyk7XHJcbiAgICBhZGFwdGVyLmRvbVJlYWR5KE9wZW50aXAuZm9sbG93TW91c2VQb3NpdGlvbik7XHJcbiAgICByZXR1cm4gZmlyc3RBZGFwdGVyID0gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuT3BlbnRpcC5wb3NpdGlvbnMgPSBbXCJ0b3BcIiwgXCJ0b3BSaWdodFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tUmlnaHRcIiwgXCJib3R0b21cIiwgXCJib3R0b21MZWZ0XCIsIFwibGVmdFwiLCBcInRvcExlZnRcIl07XHJcblxyXG5PcGVudGlwLnBvc2l0aW9uID0ge307XHJcblxyXG5fcmVmID0gT3BlbnRpcC5wb3NpdGlvbnM7XHJcbmZvciAoaSA9IF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XHJcbiAgcG9zaXRpb24gPSBfcmVmW2ldO1xyXG4gIE9wZW50aXAucG9zaXRpb25bcG9zaXRpb25dID0gaTtcclxufVxyXG5cclxuT3BlbnRpcC5zdHlsZXMgPSB7XHJcbiAgc3RhbmRhcmQ6IHtcclxuICAgIFwiZXh0ZW5kc1wiOiBudWxsLFxyXG4gICAgdGl0bGU6IHZvaWQgMCxcclxuICAgIGVzY2FwZVRpdGxlOiB0cnVlLFxyXG4gICAgZXNjYXBlQ29udGVudDogZmFsc2UsXHJcbiAgICBjbGFzc05hbWU6IFwic3RhbmRhcmRcIixcclxuICAgIHN0ZW06IHRydWUsXHJcbiAgICBkZWxheTogbnVsbCxcclxuICAgIGhpZGVEZWxheTogMC4xLFxyXG4gICAgZml4ZWQ6IGZhbHNlLFxyXG4gICAgc2hvd09uOiBcIm1vdXNlb3ZlclwiLFxyXG4gICAgaGlkZVRyaWdnZXI6IFwidHJpZ2dlclwiLFxyXG4gICAgaGlkZVRyaWdnZXJzOiBbXSxcclxuICAgIGhpZGVPbjogbnVsbCxcclxuICAgIHJlbW92ZUVsZW1lbnRzT25IaWRlOiBmYWxzZSxcclxuICAgIG9mZnNldDogWzAsIDBdLFxyXG4gICAgY29udGFpbkluVmlld3BvcnQ6IHRydWUsXHJcbiAgICBhdXRvT2Zmc2V0OiB0cnVlLFxyXG4gICAgc2hvd0VmZmVjdDogXCJhcHBlYXJcIixcclxuICAgIGhpZGVFZmZlY3Q6IFwiZmFkZVwiLFxyXG4gICAgc2hvd0VmZmVjdER1cmF0aW9uOiAwLjMsXHJcbiAgICBoaWRlRWZmZWN0RHVyYXRpb246IDAuMixcclxuICAgIHN0ZW1MZW5ndGg6IDUsXHJcbiAgICBzdGVtQmFzZTogOCxcclxuICAgIHRpcEpvaW50OiBcInRvcCBsZWZ0XCIsXHJcbiAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICB0YXJnZXRKb2ludDogbnVsbCxcclxuICAgIGNhY2hlOiB0cnVlLFxyXG4gICAgYWpheDogZmFsc2UsXHJcbiAgICBhamF4TWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgYWpheEVycm9yTWVzc2FnZTogXCJUaGVyZSB3YXMgYSBwcm9ibGVtIGRvd25sb2FkaW5nIHRoZSBjb250ZW50LlwiLFxyXG4gICAgZ3JvdXA6IG51bGwsXHJcbiAgICBzdHlsZTogbnVsbCxcclxuICAgIGJhY2tncm91bmQ6IFwiI2ZmZjE4ZlwiLFxyXG4gICAgYmFja2dyb3VuZEdyYWRpZW50SG9yaXpvbnRhbDogZmFsc2UsXHJcbiAgICBjbG9zZUJ1dHRvbk9mZnNldDogWzUsIDVdLFxyXG4gICAgY2xvc2VCdXR0b25SYWRpdXM6IDcsXHJcbiAgICBjbG9zZUJ1dHRvbkNyb3NzU2l6ZTogNCxcclxuICAgIGNsb3NlQnV0dG9uQ3Jvc3NDb2xvcjogXCIjZDJjMzViXCIsXHJcbiAgICBjbG9zZUJ1dHRvbkNyb3NzTGluZVdpZHRoOiAxLjUsXHJcbiAgICBjbG9zZUJ1dHRvbkxpbmtPdmVyc2NhbjogNixcclxuICAgIGJvcmRlclJhZGl1czogNSxcclxuICAgIGJvcmRlcldpZHRoOiAxLFxyXG4gICAgYm9yZGVyQ29sb3I6IFwiI2YyZTM3YlwiLFxyXG4gICAgc2hhZG93OiB0cnVlLFxyXG4gICAgc2hhZG93Qmx1cjogMTAsXHJcbiAgICBzaGFkb3dPZmZzZXQ6IFszLCAzXSxcclxuICAgIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC4xKVwiXHJcbiAgfSxcclxuICBnbGFzczoge1xyXG4gICAgXCJleHRlbmRzXCI6IFwic3RhbmRhcmRcIixcclxuICAgIGNsYXNzTmFtZTogXCJnbGFzc1wiLFxyXG4gICAgYmFja2dyb3VuZDogW1swLCBcInJnYmEoMjUyLCAyNTIsIDI1MiwgMC44KVwiXSwgWzAuNSwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOClcIl0sIFswLjUsIFwicmdiYSgyNTAsIDI1MCwgMjUwLCAwLjkpXCJdLCBbMSwgXCJyZ2JhKDI0NSwgMjQ1LCAyNDUsIDAuOSlcIl1dLFxyXG4gICAgYm9yZGVyQ29sb3I6IFwiI2VlZVwiLFxyXG4gICAgY2xvc2VCdXR0b25Dcm9zc0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC4yKVwiLFxyXG4gICAgYm9yZGVyUmFkaXVzOiAxNSxcclxuICAgIGNsb3NlQnV0dG9uUmFkaXVzOiAxMCxcclxuICAgIGNsb3NlQnV0dG9uT2Zmc2V0OiBbOCwgOF1cclxuICB9LFxyXG4gIGRhcms6IHtcclxuICAgIFwiZXh0ZW5kc1wiOiBcInN0YW5kYXJkXCIsXHJcbiAgICBjbGFzc05hbWU6IFwiZGFya1wiLFxyXG4gICAgYm9yZGVyUmFkaXVzOiAxMyxcclxuICAgIGJvcmRlckNvbG9yOiBcIiM0NDRcIixcclxuICAgIGNsb3NlQnV0dG9uQ3Jvc3NDb2xvcjogXCJyZ2JhKDI0MCwgMjQwLCAyNDAsIDEpXCIsXHJcbiAgICBzaGFkb3dDb2xvcjogXCJyZ2JhKDAsIDAsIDAsIDAuMylcIixcclxuICAgIHNoYWRvd09mZnNldDogWzIsIDJdLFxyXG4gICAgYmFja2dyb3VuZDogW1swLCBcInJnYmEoMzAsIDMwLCAzMCwgMC43KVwiXSwgWzAuNSwgXCJyZ2JhKDMwLCAzMCwgMzAsIDAuOClcIl0sIFswLjUsIFwicmdiYSgxMCwgMTAsIDEwLCAwLjgpXCJdLCBbMSwgXCJyZ2JhKDEwLCAxMCwgMTAsIDAuOSlcIl1dXHJcbiAgfSxcclxuICBhbGVydDoge1xyXG4gICAgXCJleHRlbmRzXCI6IFwic3RhbmRhcmRcIixcclxuICAgIGNsYXNzTmFtZTogXCJhbGVydFwiLFxyXG4gICAgYm9yZGVyUmFkaXVzOiAxLFxyXG4gICAgYm9yZGVyQ29sb3I6IFwiI0FFMEQxMVwiLFxyXG4gICAgY2xvc2VCdXR0b25Dcm9zc0NvbG9yOiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMSlcIixcclxuICAgIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC4zKVwiLFxyXG4gICAgc2hhZG93T2Zmc2V0OiBbMiwgMl0sXHJcbiAgICBiYWNrZ3JvdW5kOiBbWzAsIFwicmdiYSgyMDMsIDE1LCAxOSwgMC43KVwiXSwgWzAuNSwgXCJyZ2JhKDIwMywgMTUsIDE5LCAwLjgpXCJdLCBbMC41LCBcInJnYmEoMTg5LCAxNCwgMTgsIDAuOClcIl0sIFsxLCBcInJnYmEoMTc5LCAxNCwgMTcsIDAuOSlcIl1dXHJcbiAgfVxyXG59O1xyXG5cclxuT3BlbnRpcC5kZWZhdWx0U3R5bGUgPSBcInN0YW5kYXJkXCI7XHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUgIT09IG51bGwpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IE9wZW50aXA7XHJcbn0gZWxzZSB7XHJcbiAgd2luZG93Lk9wZW50aXAgPSBPcGVudGlwO1xyXG59XHJcblxyXG5cclxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjQuMFxyXG52YXIgX19zbGljZSA9IFtdLnNsaWNlO1xyXG5cclxuKGZ1bmN0aW9uKCQpIHtcclxuICB2YXIgQWRhcHRlcjtcclxuICAkLmZuLm9wZW50aXAgPSBmdW5jdGlvbihjb250ZW50LCB0aXRsZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBPcGVudGlwKHRoaXMsIGNvbnRlbnQsIHRpdGxlLCBvcHRpb25zKTtcclxuICB9O1xyXG4gIEFkYXB0ZXIgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gQWRhcHRlcigpIHt9XHJcblxyXG4gICAgQWRhcHRlci5wcm90b3R5cGUubmFtZSA9IFwianF1ZXJ5XCI7XHJcblxyXG4gICAgQWRhcHRlci5wcm90b3R5cGUuZG9tUmVhZHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gJChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG5cclxuICAgIEFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGh0bWwpIHtcclxuICAgICAgcmV0dXJuICQoaHRtbCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEFkYXB0ZXIucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xyXG4gICAgICBpZiAoZWxlbWVudC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGlwbGUgZWxlbWVudHMgcHJvdmlkZWQuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiAkKGVsZW1lbnQpWzBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS50YWdOYW1lID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy51bndyYXAoZWxlbWVudCkudGFnTmFtZTtcclxuICAgIH07XHJcblxyXG4gICAgQWRhcHRlci5wcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgYXJncywgZWxlbWVudCwgX3JlZjtcclxuICAgICAgZWxlbWVudCA9IGFyZ3VtZW50c1swXSwgYXJncyA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XHJcbiAgICAgIHJldHVybiAoX3JlZiA9ICQoZWxlbWVudCkpLmF0dHIuYXBwbHkoX3JlZiwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEFkYXB0ZXIucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGFyZ3MsIGVsZW1lbnQsIF9yZWY7XHJcbiAgICAgIGVsZW1lbnQgPSBhcmd1bWVudHNbMF0sIGFyZ3MgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xyXG4gICAgICByZXR1cm4gKF9yZWYgPSAkKGVsZW1lbnQpKS5kYXRhLmFwcGx5KF9yZWYsIGFyZ3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IpIHtcclxuICAgICAgcmV0dXJuICQoZWxlbWVudCkuZmluZChzZWxlY3RvcikuZ2V0KDApO1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5maW5kQWxsID0gZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IpIHtcclxuICAgICAgcmV0dXJuICQoZWxlbWVudCkuZmluZChzZWxlY3Rvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEFkYXB0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNvbnRlbnQsIGVzY2FwZSkge1xyXG4gICAgICBlbGVtZW50ID0gJChlbGVtZW50KTtcclxuICAgICAgaWYgKGVzY2FwZSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50LnRleHQoY29udGVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaHRtbChjb250ZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihlbGVtZW50LCBjaGlsZCkge1xyXG4gICAgICByZXR1cm4gJChlbGVtZW50KS5hcHBlbmQoY2hpbGQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiAkKGVsZW1lbnQpLnJlbW92ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICByZXR1cm4gJChlbGVtZW50KS5hZGRDbGFzcyhjbGFzc05hbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICByZXR1cm4gJChlbGVtZW50KS5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgIHJldHVybiAkKGVsZW1lbnQpLmNzcyhwcm9wZXJ0aWVzKTtcclxuICAgIH07XHJcblxyXG4gICAgQWRhcHRlci5wcm90b3R5cGUuZGltZW5zaW9ucyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogJChlbGVtZW50KS5vdXRlcldpZHRoKCksXHJcbiAgICAgICAgaGVpZ2h0OiAkKGVsZW1lbnQpLm91dGVySGVpZ2h0KClcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgQWRhcHRlci5wcm90b3R5cGUuc2Nyb2xsT2Zmc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBbd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCwgd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BdO1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS52aWV3cG9ydERpbWVuc2lvbnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5tb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICBpZiAoZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBlLnBhZ2VYLFxyXG4gICAgICAgIHk6IGUucGFnZVlcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgQWRhcHRlci5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICB2YXIgb2Zmc2V0O1xyXG4gICAgICBvZmZzZXQgPSAkKGVsZW1lbnQpLm9mZnNldCgpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0LFxyXG4gICAgICAgIHRvcDogb2Zmc2V0LnRvcFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBvYnNlcnZlcikge1xyXG4gICAgICByZXR1cm4gJChlbGVtZW50KS5iaW5kKGV2ZW50TmFtZSwgb2JzZXJ2ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBBZGFwdGVyLnByb3RvdHlwZS5zdG9wT2JzZXJ2aW5nID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBvYnNlcnZlcikge1xyXG4gICAgICByZXR1cm4gJChlbGVtZW50KS51bmJpbmQoZXZlbnROYW1lLCBvYnNlcnZlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEFkYXB0ZXIucHJvdG90eXBlLmFqYXggPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgIHZhciBfcmVmLCBfcmVmMTtcclxuICAgICAgaWYgKG9wdGlvbnMudXJsID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB1cmwgcHJvdmlkZWRcIik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICQuYWpheCh7XHJcbiAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcclxuICAgICAgICB0eXBlOiAoX3JlZiA9IChfcmVmMSA9IG9wdGlvbnMubWV0aG9kKSAhPSBudWxsID8gX3JlZjEudG9VcHBlckNhc2UoKSA6IHZvaWQgMCkgIT0gbnVsbCA/IF9yZWYgOiBcIkdFVFwiXHJcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24oY29udGVudCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5vblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMub25TdWNjZXNzKGNvbnRlbnQpIDogdm9pZCAwO1xyXG4gICAgICB9KS5mYWlsKGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMub25FcnJvciA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5vbkVycm9yKFwiU2VydmVyIHJlc3BvbmRlZCB3aXRoIHN0YXR1cyBcIiArIHJlcXVlc3Quc3RhdHVzKSA6IHZvaWQgMDtcclxuICAgICAgfSkuYWx3YXlzKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5vbkNvbXBsZXRlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLm9uQ29tcGxldGUoKSA6IHZvaWQgMDtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEFkYXB0ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgb2JqZWN0KTtcclxuICAgIH07XHJcblxyXG4gICAgQWRhcHRlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBzb3VyY2VzLCB0YXJnZXQ7XHJcbiAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSwgc291cmNlcyA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XHJcbiAgICAgIHJldHVybiAkLmV4dGVuZC5hcHBseSgkLCBbdGFyZ2V0XS5jb25jYXQoX19zbGljZS5jYWxsKHNvdXJjZXMpKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBBZGFwdGVyO1xyXG5cclxuICB9KSgpO1xyXG4gIHJldHVybiBPcGVudGlwLmFkZEFkYXB0ZXIobmV3IEFkYXB0ZXIpO1xyXG59KShqUXVlcnkpO1xyXG5cclxuXHJcbi8vIE1vZGlmaWVkIGJ5IE1hdGlhcyBNZW5vIHRvIHdvcmsgaW4gSUU4LlxyXG4vLyBJIHJlbW92ZWQgdGhlIGxpbmUgMzEyLCBhcyBwcm9wb3NlZCBieSBzb21lb25lIG9uIHRoZSBnb29nbGUgZm9ydW0uXHJcblxyXG4vLyBDb3B5cmlnaHQgMjAwNiBHb29nbGUgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcblxyXG5cclxuLy8gS25vd24gSXNzdWVzOlxyXG4vL1xyXG4vLyAqIFBhdHRlcm5zIGFyZSBub3QgaW1wbGVtZW50ZWQuXHJcbi8vICogUmFkaWFsIGdyYWRpZW50IGFyZSBub3QgaW1wbGVtZW50ZWQuIFRoZSBWTUwgdmVyc2lvbiBvZiB0aGVzZSBsb29rIHZlcnlcclxuLy8gICBkaWZmZXJlbnQgZnJvbSB0aGUgY2FudmFzIG9uZS5cclxuLy8gKiBDbGlwcGluZyBwYXRocyBhcmUgbm90IGltcGxlbWVudGVkLlxyXG4vLyAqIENvb3Jkc2l6ZS4gVGhlIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlIGhhdmUgaGlnaGVyIHByaW9yaXR5IHRoYW4gdGhlXHJcbi8vICAgd2lkdGggYW5kIGhlaWdodCBzdHlsZSB2YWx1ZXMgd2hpY2ggaXNuJ3QgY29ycmVjdC5cclxuLy8gKiBQYWludGluZyBtb2RlIGlzbid0IGltcGxlbWVudGVkLlxyXG4vLyAqIENhbnZhcyB3aWR0aC9oZWlnaHQgc2hvdWxkIGlzIHVzaW5nIGNvbnRlbnQtYm94IGJ5IGRlZmF1bHQuIElFIGluXHJcbi8vICAgUXVpcmtzIG1vZGUgd2lsbCBkcmF3IHRoZSBjYW52YXMgdXNpbmcgYm9yZGVyLWJveC4gRWl0aGVyIGNoYW5nZSB5b3VyXHJcbi8vICAgZG9jdHlwZSB0byBIVE1MNVxyXG4vLyAgIChodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrLyN0aGUtZG9jdHlwZSlcclxuLy8gICBvciB1c2UgQm94IFNpemluZyBCZWhhdmlvciBmcm9tIFdlYkZYXHJcbi8vICAgKGh0dHA6Ly93ZWJmeC5lYWUubmV0L2RodG1sL2JveHNpemluZy9ib3hzaXppbmcuaHRtbClcclxuLy8gKiBOb24gdW5pZm9ybSBzY2FsaW5nIGRvZXMgbm90IGNvcnJlY3RseSBzY2FsZSBzdHJva2VzLlxyXG4vLyAqIE9wdGltaXplLiBUaGVyZSBpcyBhbHdheXMgcm9vbSBmb3Igc3BlZWQgaW1wcm92ZW1lbnRzLlxyXG5cclxuLy8gT25seSBhZGQgdGhpcyBjb2RlIGlmIHdlIGRvIG5vdCBhbHJlYWR5IGhhdmUgYSBjYW52YXMgaW1wbGVtZW50YXRpb25cclxuaWYgKCFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KSB7XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gIC8vIGFsaWFzIHNvbWUgZnVuY3Rpb25zIHRvIG1ha2UgKGNvbXBpbGVkKSBjb2RlIHNob3J0ZXJcclxuICB2YXIgbSA9IE1hdGg7XHJcbiAgdmFyIG1yID0gbS5yb3VuZDtcclxuICB2YXIgbXMgPSBtLnNpbjtcclxuICB2YXIgbWMgPSBtLmNvcztcclxuICB2YXIgYWJzID0gbS5hYnM7XHJcbiAgdmFyIHNxcnQgPSBtLnNxcnQ7XHJcblxyXG4gIC8vIHRoaXMgaXMgdXNlZCBmb3Igc3ViIHBpeGVsIHByZWNpc2lvblxyXG4gIHZhciBaID0gMTA7XHJcbiAgdmFyIFoyID0gWiAvIDI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVudGlvbiBpcyBhc3NpZ25lZCB0byB0aGUgPGNhbnZhcz4gZWxlbWVudHMgYXMgZWxlbWVudC5nZXRDb250ZXh0KCkuXHJcbiAgICogQHRoaXMge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF99XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRleHRfIHx8XHJcbiAgICAgICAgKHRoaXMuY29udGV4dF8gPSBuZXcgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXyh0aGlzKSk7XHJcbiAgfVxyXG5cclxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmRzIGEgZnVuY3Rpb24gdG8gYW4gb2JqZWN0LiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gd2lsbCBhbHdheXMgdXNlIHRoZVxyXG4gICAqIHBhc3NlZCBpbiB7QGNvZGUgb2JqfSBhcyB7QGNvZGUgdGhpc30uXHJcbiAgICpcclxuICAgKiBFeGFtcGxlOlxyXG4gICAqXHJcbiAgICogICBnID0gYmluZChmLCBvYmosIGEsIGIpXHJcbiAgICogICBnKGMsIGQpIC8vIHdpbGwgZG8gZi5jYWxsKG9iaiwgYSwgYiwgYywgZClcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRvIGJpbmQgdGhlIG9iamVjdCB0b1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0aGF0IHNob3VsZCBhY3QgYXMgdGhpcyB3aGVuIHRoZSBmdW5jdGlvblxyXG4gICAqICAgICBpcyBjYWxsZWRcclxuICAgKiBAcGFyYW0geyp9IHZhcl9hcmdzIFJlc3QgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsXHJcbiAgICogICAgIGFyZ3VtZW50cyB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWRcclxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gdGhhdCBoYXMgYm91bmQgdGhpc1xyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGJpbmQoZiwgb2JqLCB2YXJfYXJncykge1xyXG4gICAgdmFyIGEgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBmLmFwcGx5KG9iaiwgYS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgdmFyIEdfdm1sQ2FudmFzTWFuYWdlcl8gPSB7XHJcbiAgICBpbml0OiBmdW5jdGlvbihvcHRfZG9jKSB7XHJcbiAgICAgIGlmICgvTVNJRS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lm9wZXJhKSB7XHJcbiAgICAgICAgdmFyIGRvYyA9IG9wdF9kb2MgfHwgZG9jdW1lbnQ7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgZWxlbWVudCBzbyB0aGF0IElFIHdpbGwgYWxsb3cgY2FudmFzIGVsZW1lbnRzIHRvIGJlXHJcbiAgICAgICAgLy8gcmVjb2duaXplZC5cclxuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgZG9jLmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBiaW5kKHRoaXMuaW5pdF8sIHRoaXMsIGRvYykpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRfOiBmdW5jdGlvbihkb2MpIHtcclxuICAgICAgLy8gY3JlYXRlIHhtbG5zXHJcbiAgICAgIGlmICghZG9jLm5hbWVzcGFjZXNbJ2dfdm1sXyddKSB7XHJcbiAgICAgICAgZG9jLm5hbWVzcGFjZXMuYWRkKCdnX3ZtbF8nLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnI2RlZmF1bHQjVk1MJyk7XHJcblxyXG4gICAgICB9XHJcbiAgICAgIGlmICghZG9jLm5hbWVzcGFjZXNbJ2dfb18nXSkge1xyXG4gICAgICAgIGRvYy5uYW1lc3BhY2VzLmFkZCgnZ19vXycsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpvZmZpY2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnI2RlZmF1bHQjVk1MJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldHVwIGRlZmF1bHQgQ1NTLiAgT25seSBhZGQgb25lIHN0eWxlIHNoZWV0IHBlciBkb2N1bWVudFxyXG4gICAgICBpZiAoIWRvYy5zdHlsZVNoZWV0c1snZXhfY2FudmFzXyddKSB7XHJcbiAgICAgICAgdmFyIHNzID0gZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKTtcclxuICAgICAgICBzcy5vd25pbmdFbGVtZW50LmlkID0gJ2V4X2NhbnZhc18nO1xyXG4gICAgICAgIHNzLmNzc1RleHQgPSAnY2FudmFze2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjsnICtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBzaXplIGlzIDMwMHgxNTAgaW4gR2Vja28gYW5kIE9wZXJhXHJcbiAgICAgICAgICAgICd0ZXh0LWFsaWduOmxlZnQ7d2lkdGg6MzAwcHg7aGVpZ2h0OjE1MHB4fScgK1xyXG4gICAgICAgICAgICAnZ192bWxfXFxcXDoqe2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpfScgK1xyXG4gICAgICAgICAgICAnZ19vX1xcXFw6KntiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKX0nO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmluZCBhbGwgY2FudmFzIGVsZW1lbnRzXHJcbiAgICAgIHZhciBlbHMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NhbnZhcycpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuaW5pdEVsZW1lbnQoZWxzW2ldKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1YmxpYyBpbml0aWFsaXplcyBhIGNhbnZhcyBlbGVtZW50IHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgY2FudmFzXHJcbiAgICAgKiBlbGVtZW50IGZyb20gbm93IG9uLiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJlZm9yZSB0aGUgcGFnZSBpc1xyXG4gICAgICogbG9hZGVkIGJ1dCBpZiB5b3UgYXJlIGNyZWF0aW5nIGVsZW1lbnRzIHVzaW5nIGNyZWF0ZUVsZW1lbnQgeW91IG5lZWQgdG9cclxuICAgICAqIG1ha2Ugc3VyZSB0aGlzIGlzIGNhbGxlZCBvbiB0aGUgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBjYW52YXMgZWxlbWVudCB0byBpbml0aWFsaXplLlxyXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGluaXRFbGVtZW50OiBmdW5jdGlvbihlbCkge1xyXG4gICAgICBpZiAoIWVsLmdldENvbnRleHQpIHtcclxuXHJcbiAgICAgICAgZWwuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBmYWxsYmFjayBjb250ZW50LiBUaGVyZSBpcyBubyB3YXkgdG8gaGlkZSB0ZXh0IG5vZGVzIHNvIHdlXHJcbiAgICAgICAgLy8ganVzdCByZW1vdmUgYWxsIGNoaWxkTm9kZXMuIFdlIGNvdWxkIGhpZGUgYWxsIGVsZW1lbnRzIGFuZCByZW1vdmVcclxuICAgICAgICAvLyB0ZXh0IG5vZGVzIGJ1dCB3aG8gcmVhbGx5IGNhcmVzIGFib3V0IHRoZSBmYWxsYmFjayBjb250ZW50LlxyXG4gICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xyXG5cclxuICAgICAgICAvLyBkbyBub3QgdXNlIGlubGluZSBmdW5jdGlvbiBiZWNhdXNlIHRoYXQgd2lsbCBsZWFrIG1lbW9yeVxyXG4gICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgb25Qcm9wZXJ0eUNoYW5nZSk7XHJcbiAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29ucmVzaXplJywgb25SZXNpemUpO1xyXG5cclxuICAgICAgICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIGlmIChhdHRycy53aWR0aCAmJiBhdHRycy53aWR0aC5zcGVjaWZpZWQpIHtcclxuICAgICAgICAgIC8vIFRPRE86IHVzZSBydW50aW1lU3R5bGUgYW5kIGNvb3Jkc2l6ZVxyXG4gICAgICAgICAgLy8gZWwuZ2V0Q29udGV4dCgpLnNldFdpZHRoXyhhdHRycy53aWR0aC5ub2RlVmFsdWUpO1xyXG4gICAgICAgICAgZWwuc3R5bGUud2lkdGggPSBhdHRycy53aWR0aC5ub2RlVmFsdWUgKyAncHgnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbC53aWR0aCA9IGVsLmNsaWVudFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXR0cnMuaGVpZ2h0ICYmIGF0dHJzLmhlaWdodC5zcGVjaWZpZWQpIHtcclxuICAgICAgICAgIC8vIFRPRE86IHVzZSBydW50aW1lU3R5bGUgYW5kIGNvb3Jkc2l6ZVxyXG4gICAgICAgICAgLy8gZWwuZ2V0Q29udGV4dCgpLnNldEhlaWdodF8oYXR0cnMuaGVpZ2h0Lm5vZGVWYWx1ZSk7XHJcbiAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBhdHRycy5oZWlnaHQubm9kZVZhbHVlICsgJ3B4JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZWwuaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2VsLmdldENvbnRleHQoKS5zZXRDb29yZHNpemVfKClcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZWw7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gb25Qcm9wZXJ0eUNoYW5nZShlKSB7XHJcbiAgICB2YXIgZWwgPSBlLnNyY0VsZW1lbnQ7XHJcblxyXG4gICAgc3dpdGNoIChlLnByb3BlcnR5TmFtZSkge1xyXG4gICAgICBjYXNlICd3aWR0aCc6XHJcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSBlbC5hdHRyaWJ1dGVzLndpZHRoLm5vZGVWYWx1ZSArICdweCc7XHJcbiAgICAgICAgZWwuZ2V0Q29udGV4dCgpLmNsZWFyUmVjdCgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdoZWlnaHQnOlxyXG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGVsLmF0dHJpYnV0ZXMuaGVpZ2h0Lm5vZGVWYWx1ZSArICdweCc7XHJcbiAgICAgICAgZWwuZ2V0Q29udGV4dCgpLmNsZWFyUmVjdCgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25SZXNpemUoZSkge1xyXG4gICAgdmFyIGVsID0gZS5zcmNFbGVtZW50O1xyXG4gICAgaWYgKGVsLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgZWwuZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9ICBlbC5jbGllbnRXaWR0aCArICdweCc7XHJcbiAgICAgIGVsLmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0ICsgJ3B4JztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEdfdm1sQ2FudmFzTWFuYWdlcl8uaW5pdCgpO1xyXG5cclxuICAvLyBwcmVjb21wdXRlIFwiMDBcIiB0byBcIkZGXCJcclxuICB2YXIgZGVjMmhleCA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XHJcbiAgICAgIGRlYzJoZXhbaSAqIDE2ICsgal0gPSBpLnRvU3RyaW5nKDE2KSArIGoudG9TdHJpbmcoMTYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlTWF0cml4SWRlbnRpdHkoKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBbMSwgMCwgMF0sXHJcbiAgICAgIFswLCAxLCAwXSxcclxuICAgICAgWzAsIDAsIDFdXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWF0cml4TXVsdGlwbHkobTEsIG0yKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gY3JlYXRlTWF0cml4SWRlbnRpdHkoKTtcclxuXHJcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDM7IHgrKykge1xyXG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDM7IHkrKykge1xyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG5cclxuICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IDM7IHorKykge1xyXG4gICAgICAgICAgc3VtICs9IG0xW3hdW3pdICogbTJbel1beV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHRbeF1beV0gPSBzdW07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb3B5U3RhdGUobzEsIG8yKSB7XHJcbiAgICBvMi5maWxsU3R5bGUgICAgID0gbzEuZmlsbFN0eWxlO1xyXG4gICAgbzIubGluZUNhcCAgICAgICA9IG8xLmxpbmVDYXA7XHJcbiAgICBvMi5saW5lSm9pbiAgICAgID0gbzEubGluZUpvaW47XHJcbiAgICBvMi5saW5lV2lkdGggICAgID0gbzEubGluZVdpZHRoO1xyXG4gICAgbzIubWl0ZXJMaW1pdCAgICA9IG8xLm1pdGVyTGltaXQ7XHJcbiAgICBvMi5zaGFkb3dCbHVyICAgID0gbzEuc2hhZG93Qmx1cjtcclxuICAgIG8yLnNoYWRvd0NvbG9yICAgPSBvMS5zaGFkb3dDb2xvcjtcclxuICAgIG8yLnNoYWRvd09mZnNldFggPSBvMS5zaGFkb3dPZmZzZXRYO1xyXG4gICAgbzIuc2hhZG93T2Zmc2V0WSA9IG8xLnNoYWRvd09mZnNldFk7XHJcbiAgICBvMi5zdHJva2VTdHlsZSAgID0gbzEuc3Ryb2tlU3R5bGU7XHJcbiAgICBvMi5nbG9iYWxBbHBoYSAgID0gbzEuZ2xvYmFsQWxwaGE7XHJcbiAgICBvMi5hcmNTY2FsZVhfICAgID0gbzEuYXJjU2NhbGVYXztcclxuICAgIG8yLmFyY1NjYWxlWV8gICAgPSBvMS5hcmNTY2FsZVlfO1xyXG4gICAgbzIubGluZVNjYWxlXyAgICA9IG8xLmxpbmVTY2FsZV87XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcm9jZXNzU3R5bGUoc3R5bGVTdHJpbmcpIHtcclxuICAgIHZhciBzdHIsIGFscGhhID0gMTtcclxuXHJcbiAgICBzdHlsZVN0cmluZyA9IFN0cmluZyhzdHlsZVN0cmluZyk7XHJcbiAgICBpZiAoc3R5bGVTdHJpbmcuc3Vic3RyaW5nKDAsIDMpID09ICdyZ2InKSB7XHJcbiAgICAgIHZhciBzdGFydCA9IHN0eWxlU3RyaW5nLmluZGV4T2YoJygnLCAzKTtcclxuICAgICAgdmFyIGVuZCA9IHN0eWxlU3RyaW5nLmluZGV4T2YoJyknLCBzdGFydCArIDEpO1xyXG4gICAgICB2YXIgZ3V0cyA9IHN0eWxlU3RyaW5nLnN1YnN0cmluZyhzdGFydCArIDEsIGVuZCkuc3BsaXQoJywnKTtcclxuXHJcbiAgICAgIHN0ciA9ICcjJztcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgICBzdHIgKz0gZGVjMmhleFtOdW1iZXIoZ3V0c1tpXSldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZ3V0cy5sZW5ndGggPT0gNCAmJiBzdHlsZVN0cmluZy5zdWJzdHIoMywgMSkgPT0gJ2EnKSB7XHJcbiAgICAgICAgYWxwaGEgPSBndXRzWzNdO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdHIgPSBzdHlsZVN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge2NvbG9yOiBzdHIsIGFscGhhOiBhbHBoYX07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcm9jZXNzTGluZUNhcChsaW5lQ2FwKSB7XHJcbiAgICBzd2l0Y2ggKGxpbmVDYXApIHtcclxuICAgICAgY2FzZSAnYnV0dCc6XHJcbiAgICAgICAgcmV0dXJuICdmbGF0JztcclxuICAgICAgY2FzZSAncm91bmQnOlxyXG4gICAgICAgIHJldHVybiAncm91bmQnO1xyXG4gICAgICBjYXNlICdzcXVhcmUnOlxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAnc3F1YXJlJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgaW50ZXJmYWNlIGFzIGRlc2NyaWJlZCBieVxyXG4gICAqIHRoZSBXSEFUV0cuXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3VyZmFjZUVsZW1lbnQgVGhlIGVsZW1lbnQgdGhhdCB0aGUgMkQgY29udGV4dCBzaG91bGRcclxuICAgKiBiZSBhc3NvY2lhdGVkIHdpdGhcclxuICAgKi9cclxuICBmdW5jdGlvbiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRfKHN1cmZhY2VFbGVtZW50KSB7XHJcbiAgICB0aGlzLm1fID0gY3JlYXRlTWF0cml4SWRlbnRpdHkoKTtcclxuXHJcbiAgICB0aGlzLm1TdGFja18gPSBbXTtcclxuICAgIHRoaXMuYVN0YWNrXyA9IFtdO1xyXG4gICAgdGhpcy5jdXJyZW50UGF0aF8gPSBbXTtcclxuXHJcbiAgICAvLyBDYW52YXMgY29udGV4dCBwcm9wZXJ0aWVzXHJcbiAgICB0aGlzLnN0cm9rZVN0eWxlID0gJyMwMDAnO1xyXG4gICAgdGhpcy5maWxsU3R5bGUgPSAnIzAwMCc7XHJcblxyXG4gICAgdGhpcy5saW5lV2lkdGggPSAxO1xyXG4gICAgdGhpcy5saW5lSm9pbiA9ICdtaXRlcic7XHJcbiAgICB0aGlzLmxpbmVDYXAgPSAnYnV0dCc7XHJcbiAgICB0aGlzLm1pdGVyTGltaXQgPSBaICogMTtcclxuICAgIHRoaXMuZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgdGhpcy5jYW52YXMgPSBzdXJmYWNlRWxlbWVudDtcclxuXHJcbiAgICB2YXIgZWwgPSBzdXJmYWNlRWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgZWwuc3R5bGUud2lkdGggPSAgc3VyZmFjZUVsZW1lbnQuY2xpZW50V2lkdGggKyAncHgnO1xyXG4gICAgZWwuc3R5bGUuaGVpZ2h0ID0gc3VyZmFjZUVsZW1lbnQuY2xpZW50SGVpZ2h0ICsgJ3B4JztcclxuICAgIC8vIGVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICBzdXJmYWNlRWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XHJcblxyXG4gICAgdGhpcy5lbGVtZW50XyA9IGVsO1xyXG4gICAgdGhpcy5hcmNTY2FsZVhfID0gMTtcclxuICAgIHRoaXMuYXJjU2NhbGVZXyA9IDE7XHJcbiAgICB0aGlzLmxpbmVTY2FsZV8gPSAxO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNvbnRleHRQcm90b3R5cGUgPSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRfLnByb3RvdHlwZTtcclxuICBjb250ZXh0UHJvdG90eXBlLmNsZWFyUmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5lbGVtZW50Xy5pbm5lckhUTUwgPSAnJztcclxuICB9O1xyXG5cclxuICBjb250ZXh0UHJvdG90eXBlLmJlZ2luUGF0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gVE9ETzogQnJhbmNoIGN1cnJlbnQgbWF0cml4IHNvIHRoYXQgc2F2ZS9yZXN0b3JlIGhhcyBubyBlZmZlY3RcclxuICAgIC8vICAgICAgIGFzIHBlciBzYWZhcmkgZG9jcy5cclxuICAgIHRoaXMuY3VycmVudFBhdGhfID0gW107XHJcbiAgfTtcclxuXHJcbiAgY29udGV4dFByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbihhWCwgYVkpIHtcclxuICAgIHZhciBwID0gdGhpcy5nZXRDb29yZHNfKGFYLCBhWSk7XHJcbiAgICB0aGlzLmN1cnJlbnRQYXRoXy5wdXNoKHt0eXBlOiAnbW92ZVRvJywgeDogcC54LCB5OiBwLnl9KTtcclxuICAgIHRoaXMuY3VycmVudFhfID0gcC54O1xyXG4gICAgdGhpcy5jdXJyZW50WV8gPSBwLnk7XHJcbiAgfTtcclxuXHJcbiAgY29udGV4dFByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbihhWCwgYVkpIHtcclxuICAgIHZhciBwID0gdGhpcy5nZXRDb29yZHNfKGFYLCBhWSk7XHJcbiAgICB0aGlzLmN1cnJlbnRQYXRoXy5wdXNoKHt0eXBlOiAnbGluZVRvJywgeDogcC54LCB5OiBwLnl9KTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRYXyA9IHAueDtcclxuICAgIHRoaXMuY3VycmVudFlfID0gcC55O1xyXG4gIH07XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGFDUDF4LCBhQ1AxeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ1AyeCwgYUNQMnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVgsIGFZKSB7XHJcbiAgICB2YXIgcCA9IHRoaXMuZ2V0Q29vcmRzXyhhWCwgYVkpO1xyXG4gICAgdmFyIGNwMSA9IHRoaXMuZ2V0Q29vcmRzXyhhQ1AxeCwgYUNQMXkpO1xyXG4gICAgdmFyIGNwMiA9IHRoaXMuZ2V0Q29vcmRzXyhhQ1AyeCwgYUNQMnkpO1xyXG4gICAgYmV6aWVyQ3VydmVUbyh0aGlzLCBjcDEsIGNwMiwgcCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGFscmVhZHkgZml4ZWQgY29yZGluYXRlcy5cclxuICBmdW5jdGlvbiBiZXppZXJDdXJ2ZVRvKHNlbGYsIGNwMSwgY3AyLCBwKSB7XHJcbiAgICBzZWxmLmN1cnJlbnRQYXRoXy5wdXNoKHtcclxuICAgICAgdHlwZTogJ2JlemllckN1cnZlVG8nLFxyXG4gICAgICBjcDF4OiBjcDEueCxcclxuICAgICAgY3AxeTogY3AxLnksXHJcbiAgICAgIGNwMng6IGNwMi54LFxyXG4gICAgICBjcDJ5OiBjcDIueSxcclxuICAgICAgeDogcC54LFxyXG4gICAgICB5OiBwLnlcclxuICAgIH0pO1xyXG4gICAgc2VsZi5jdXJyZW50WF8gPSBwLng7XHJcbiAgICBzZWxmLmN1cnJlbnRZXyA9IHAueTtcclxuICB9XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKGFDUHgsIGFDUHksIGFYLCBhWSkge1xyXG4gICAgLy8gdGhlIGZvbGxvd2luZyBpcyBsaWZ0ZWQgYWxtb3N0IGRpcmVjdGx5IGZyb21cclxuICAgIC8vIGh0dHA6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9DYW52YXNfdHV0b3JpYWw6RHJhd2luZ19zaGFwZXNcclxuXHJcbiAgICB2YXIgY3AgPSB0aGlzLmdldENvb3Jkc18oYUNQeCwgYUNQeSk7XHJcbiAgICB2YXIgcCA9IHRoaXMuZ2V0Q29vcmRzXyhhWCwgYVkpO1xyXG5cclxuICAgIHZhciBjcDEgPSB7XHJcbiAgICAgIHg6IHRoaXMuY3VycmVudFhfICsgMi4wIC8gMy4wICogKGNwLnggLSB0aGlzLmN1cnJlbnRYXyksXHJcbiAgICAgIHk6IHRoaXMuY3VycmVudFlfICsgMi4wIC8gMy4wICogKGNwLnkgLSB0aGlzLmN1cnJlbnRZXylcclxuICAgIH07XHJcbiAgICB2YXIgY3AyID0ge1xyXG4gICAgICB4OiBjcDEueCArIChwLnggLSB0aGlzLmN1cnJlbnRYXykgLyAzLjAsXHJcbiAgICAgIHk6IGNwMS55ICsgKHAueSAtIHRoaXMuY3VycmVudFlfKSAvIDMuMFxyXG4gICAgfTtcclxuXHJcbiAgICBiZXppZXJDdXJ2ZVRvKHRoaXMsIGNwMSwgY3AyLCBwKTtcclxuICB9O1xyXG5cclxuICBjb250ZXh0UHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uKGFYLCBhWSwgYVJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UpIHtcclxuICAgIGFSYWRpdXMgKj0gWjtcclxuICAgIHZhciBhcmNUeXBlID0gYUNsb2Nrd2lzZSA/ICdhdCcgOiAnd2EnO1xyXG5cclxuICAgIHZhciB4U3RhcnQgPSBhWCArIG1jKGFTdGFydEFuZ2xlKSAqIGFSYWRpdXMgLSBaMjtcclxuICAgIHZhciB5U3RhcnQgPSBhWSArIG1zKGFTdGFydEFuZ2xlKSAqIGFSYWRpdXMgLSBaMjtcclxuXHJcbiAgICB2YXIgeEVuZCA9IGFYICsgbWMoYUVuZEFuZ2xlKSAqIGFSYWRpdXMgLSBaMjtcclxuICAgIHZhciB5RW5kID0gYVkgKyBtcyhhRW5kQW5nbGUpICogYVJhZGl1cyAtIFoyO1xyXG5cclxuICAgIC8vIElFIHdvbid0IHJlbmRlciBhcmNoZXMgZHJhd24gY291bnRlciBjbG9ja3dpc2UgaWYgeFN0YXJ0ID09IHhFbmQuXHJcbiAgICBpZiAoeFN0YXJ0ID09IHhFbmQgJiYgIWFDbG9ja3dpc2UpIHtcclxuICAgICAgeFN0YXJ0ICs9IDAuMTI1OyAvLyBPZmZzZXQgeFN0YXJ0IGJ5IDEvODAgb2YgYSBwaXhlbC4gVXNlIHNvbWV0aGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGluIGJpbmFyeVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBwID0gdGhpcy5nZXRDb29yZHNfKGFYLCBhWSk7XHJcbiAgICB2YXIgcFN0YXJ0ID0gdGhpcy5nZXRDb29yZHNfKHhTdGFydCwgeVN0YXJ0KTtcclxuICAgIHZhciBwRW5kID0gdGhpcy5nZXRDb29yZHNfKHhFbmQsIHlFbmQpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudFBhdGhfLnB1c2goe3R5cGU6IGFyY1R5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHAueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcC55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IGFSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHhTdGFydDogcFN0YXJ0LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHlTdGFydDogcFN0YXJ0LnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHhFbmQ6IHBFbmQueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgeUVuZDogcEVuZC55fSk7XHJcblxyXG4gIH07XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKGFYLCBhWSwgYVdpZHRoLCBhSGVpZ2h0KSB7XHJcbiAgICB0aGlzLm1vdmVUbyhhWCwgYVkpO1xyXG4gICAgdGhpcy5saW5lVG8oYVggKyBhV2lkdGgsIGFZKTtcclxuICAgIHRoaXMubGluZVRvKGFYICsgYVdpZHRoLCBhWSArIGFIZWlnaHQpO1xyXG4gICAgdGhpcy5saW5lVG8oYVgsIGFZICsgYUhlaWdodCk7XHJcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xyXG4gIH07XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUuc3Ryb2tlUmVjdCA9IGZ1bmN0aW9uKGFYLCBhWSwgYVdpZHRoLCBhSGVpZ2h0KSB7XHJcbiAgICB2YXIgb2xkUGF0aCA9IHRoaXMuY3VycmVudFBhdGhfO1xyXG4gICAgdGhpcy5iZWdpblBhdGgoKTtcclxuXHJcbiAgICB0aGlzLm1vdmVUbyhhWCwgYVkpO1xyXG4gICAgdGhpcy5saW5lVG8oYVggKyBhV2lkdGgsIGFZKTtcclxuICAgIHRoaXMubGluZVRvKGFYICsgYVdpZHRoLCBhWSArIGFIZWlnaHQpO1xyXG4gICAgdGhpcy5saW5lVG8oYVgsIGFZICsgYUhlaWdodCk7XHJcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xyXG4gICAgdGhpcy5zdHJva2UoKTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRQYXRoXyA9IG9sZFBhdGg7XHJcbiAgfTtcclxuXHJcbiAgY29udGV4dFByb3RvdHlwZS5maWxsUmVjdCA9IGZ1bmN0aW9uKGFYLCBhWSwgYVdpZHRoLCBhSGVpZ2h0KSB7XHJcbiAgICB2YXIgb2xkUGF0aCA9IHRoaXMuY3VycmVudFBhdGhfO1xyXG4gICAgdGhpcy5iZWdpblBhdGgoKTtcclxuXHJcbiAgICB0aGlzLm1vdmVUbyhhWCwgYVkpO1xyXG4gICAgdGhpcy5saW5lVG8oYVggKyBhV2lkdGgsIGFZKTtcclxuICAgIHRoaXMubGluZVRvKGFYICsgYVdpZHRoLCBhWSArIGFIZWlnaHQpO1xyXG4gICAgdGhpcy5saW5lVG8oYVgsIGFZICsgYUhlaWdodCk7XHJcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xyXG4gICAgdGhpcy5maWxsKCk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50UGF0aF8gPSBvbGRQYXRoO1xyXG4gIH07XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUuY3JlYXRlTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbihhWDAsIGFZMCwgYVgxLCBhWTEpIHtcclxuICAgIHZhciBncmFkaWVudCA9IG5ldyBDYW52YXNHcmFkaWVudF8oJ2dyYWRpZW50Jyk7XHJcbiAgICBncmFkaWVudC54MF8gPSBhWDA7XHJcbiAgICBncmFkaWVudC55MF8gPSBhWTA7XHJcbiAgICBncmFkaWVudC54MV8gPSBhWDE7XHJcbiAgICBncmFkaWVudC55MV8gPSBhWTE7XHJcbiAgICByZXR1cm4gZ3JhZGllbnQ7XHJcbiAgfTtcclxuXHJcbiAgY29udGV4dFByb3RvdHlwZS5jcmVhdGVSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKGFYMCwgYVkwLCBhUjAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFYMSwgYVkxLCBhUjEpIHtcclxuICAgIHZhciBncmFkaWVudCA9IG5ldyBDYW52YXNHcmFkaWVudF8oJ2dyYWRpZW50cmFkaWFsJyk7XHJcbiAgICBncmFkaWVudC54MF8gPSBhWDA7XHJcbiAgICBncmFkaWVudC55MF8gPSBhWTA7XHJcbiAgICBncmFkaWVudC5yMF8gPSBhUjA7XHJcbiAgICBncmFkaWVudC54MV8gPSBhWDE7XHJcbiAgICBncmFkaWVudC55MV8gPSBhWTE7XHJcbiAgICBncmFkaWVudC5yMV8gPSBhUjE7XHJcbiAgICByZXR1cm4gZ3JhZGllbnQ7XHJcbiAgfTtcclxuXHJcbiAgY29udGV4dFByb3RvdHlwZS5kcmF3SW1hZ2UgPSBmdW5jdGlvbihpbWFnZSwgdmFyX2FyZ3MpIHtcclxuICAgIHZhciBkeCwgZHksIGR3LCBkaCwgc3gsIHN5LCBzdywgc2g7XHJcblxyXG4gICAgLy8gdG8gZmluZCB0aGUgb3JpZ2luYWwgd2lkdGggd2Ugb3ZlcmlkZSB0aGUgd2lkdGggYW5kIGhlaWdodFxyXG4gICAgdmFyIG9sZFJ1bnRpbWVXaWR0aCA9IGltYWdlLnJ1bnRpbWVTdHlsZS53aWR0aDtcclxuICAgIHZhciBvbGRSdW50aW1lSGVpZ2h0ID0gaW1hZ2UucnVudGltZVN0eWxlLmhlaWdodDtcclxuICAgIGltYWdlLnJ1bnRpbWVTdHlsZS53aWR0aCA9ICdhdXRvJztcclxuICAgIGltYWdlLnJ1bnRpbWVTdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcblxyXG4gICAgLy8gZ2V0IHRoZSBvcmlnaW5hbCBzaXplXHJcbiAgICB2YXIgdyA9IGltYWdlLndpZHRoO1xyXG4gICAgdmFyIGggPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG4gICAgLy8gYW5kIHJlbW92ZSBvdmVyaWRlc1xyXG4gICAgaW1hZ2UucnVudGltZVN0eWxlLndpZHRoID0gb2xkUnVudGltZVdpZHRoO1xyXG4gICAgaW1hZ2UucnVudGltZVN0eWxlLmhlaWdodCA9IG9sZFJ1bnRpbWVIZWlnaHQ7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xyXG4gICAgICBkeCA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgZHkgPSBhcmd1bWVudHNbMl07XHJcbiAgICAgIHN4ID0gc3kgPSAwO1xyXG4gICAgICBzdyA9IGR3ID0gdztcclxuICAgICAgc2ggPSBkaCA9IGg7XHJcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gNSkge1xyXG4gICAgICBkeCA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgZHkgPSBhcmd1bWVudHNbMl07XHJcbiAgICAgIGR3ID0gYXJndW1lbnRzWzNdO1xyXG4gICAgICBkaCA9IGFyZ3VtZW50c1s0XTtcclxuICAgICAgc3ggPSBzeSA9IDA7XHJcbiAgICAgIHN3ID0gdztcclxuICAgICAgc2ggPSBoO1xyXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDkpIHtcclxuICAgICAgc3ggPSBhcmd1bWVudHNbMV07XHJcbiAgICAgIHN5ID0gYXJndW1lbnRzWzJdO1xyXG4gICAgICBzdyA9IGFyZ3VtZW50c1szXTtcclxuICAgICAgc2ggPSBhcmd1bWVudHNbNF07XHJcbiAgICAgIGR4ID0gYXJndW1lbnRzWzVdO1xyXG4gICAgICBkeSA9IGFyZ3VtZW50c1s2XTtcclxuICAgICAgZHcgPSBhcmd1bWVudHNbN107XHJcbiAgICAgIGRoID0gYXJndW1lbnRzWzhdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cycpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkID0gdGhpcy5nZXRDb29yZHNfKGR4LCBkeSk7XHJcblxyXG4gICAgdmFyIHcyID0gc3cgLyAyO1xyXG4gICAgdmFyIGgyID0gc2ggLyAyO1xyXG5cclxuICAgIHZhciB2bWxTdHIgPSBbXTtcclxuXHJcbiAgICB2YXIgVyA9IDEwO1xyXG4gICAgdmFyIEggPSAxMDtcclxuXHJcbiAgICAvLyBGb3Igc29tZSByZWFzb24gdGhhdCBJJ3ZlIG5vdyBmb3Jnb3R0ZW4sIHVzaW5nIGRpdnMgZGlkbid0IHdvcmtcclxuICAgIHZtbFN0ci5wdXNoKCcgPGdfdm1sXzpncm91cCcsXHJcbiAgICAgICAgICAgICAgICAnIGNvb3Jkc2l6ZT1cIicsIFogKiBXLCAnLCcsIFogKiBILCAnXCInLFxyXG4gICAgICAgICAgICAgICAgJyBjb29yZG9yaWdpbj1cIjAsMFwiJyAsXHJcbiAgICAgICAgICAgICAgICAnIHN0eWxlPVwid2lkdGg6JywgVywgJ3B4O2hlaWdodDonLCBILCAncHg7cG9zaXRpb246YWJzb2x1dGU7Jyk7XHJcblxyXG4gICAgLy8gSWYgZmlsdGVycyBhcmUgbmVjZXNzYXJ5IChyb3RhdGlvbiBleGlzdHMpLCBjcmVhdGUgdGhlbVxyXG4gICAgLy8gZmlsdGVycyBhcmUgYm9nLXNsb3csIHNvIG9ubHkgY3JlYXRlIHRoZW0gaWYgYWJic29sdXRlbHkgbmVjZXNzYXJ5XHJcbiAgICAvLyBUaGUgZm9sbG93aW5nIGNoZWNrIGRvZXNuJ3QgYWNjb3VudCBmb3Igc2tld3MgKHdoaWNoIGRvbid0IGV4aXN0XHJcbiAgICAvLyBpbiB0aGUgY2FudmFzIHNwZWMgKHlldCkgYW55d2F5LlxyXG5cclxuICAgIGlmICh0aGlzLm1fWzBdWzBdICE9IDEgfHwgdGhpcy5tX1swXVsxXSkge1xyXG4gICAgICB2YXIgZmlsdGVyID0gW107XHJcblxyXG4gICAgICAvLyBOb3RlIHRoZSAxMi8yMSByZXZlcnNhbFxyXG4gICAgICBmaWx0ZXIucHVzaCgnTTExPScsIHRoaXMubV9bMF1bMF0sICcsJyxcclxuICAgICAgICAgICAgICAgICAgJ00xMj0nLCB0aGlzLm1fWzFdWzBdLCAnLCcsXHJcbiAgICAgICAgICAgICAgICAgICdNMjE9JywgdGhpcy5tX1swXVsxXSwgJywnLFxyXG4gICAgICAgICAgICAgICAgICAnTTIyPScsIHRoaXMubV9bMV1bMV0sICcsJyxcclxuICAgICAgICAgICAgICAgICAgJ0R4PScsIG1yKGQueCAvIFopLCAnLCcsXHJcbiAgICAgICAgICAgICAgICAgICdEeT0nLCBtcihkLnkgLyBaKSwgJycpO1xyXG5cclxuICAgICAgLy8gQm91bmRpbmcgYm94IGNhbGN1bGF0aW9uIChuZWVkIHRvIG1pbmltaXplIGRpc3BsYXllZCBhcmVhIHNvIHRoYXRcclxuICAgICAgLy8gZmlsdGVycyBkb24ndCB3YXN0ZSB0aW1lIG9uIHVudXNlZCBwaXhlbHMuXHJcbiAgICAgIHZhciBtYXggPSBkO1xyXG4gICAgICB2YXIgYzIgPSB0aGlzLmdldENvb3Jkc18oZHggKyBkdywgZHkpO1xyXG4gICAgICB2YXIgYzMgPSB0aGlzLmdldENvb3Jkc18oZHgsIGR5ICsgZGgpO1xyXG4gICAgICB2YXIgYzQgPSB0aGlzLmdldENvb3Jkc18oZHggKyBkdywgZHkgKyBkaCk7XHJcblxyXG4gICAgICBtYXgueCA9IG0ubWF4KG1heC54LCBjMi54LCBjMy54LCBjNC54KTtcclxuICAgICAgbWF4LnkgPSBtLm1heChtYXgueSwgYzIueSwgYzMueSwgYzQueSk7XHJcblxyXG4gICAgICB2bWxTdHIucHVzaCgncGFkZGluZzowICcsIG1yKG1heC54IC8gWiksICdweCAnLCBtcihtYXgueSAvIFopLFxyXG4gICAgICAgICAgICAgICAgICAncHggMDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeCgnLFxyXG4gICAgICAgICAgICAgICAgICBmaWx0ZXIuam9pbignJyksIFwiLCBzaXppbmdtZXRob2Q9J2NsaXAnKTtcIilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZtbFN0ci5wdXNoKCd0b3A6JywgbXIoZC55IC8gWiksICdweDtsZWZ0OicsIG1yKGQueCAvIFopLCAncHg7Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdm1sU3RyLnB1c2goJyBcIj4nICxcclxuICAgICAgICAgICAgICAgICc8Z192bWxfOmltYWdlIHNyYz1cIicsIGltYWdlLnNyYywgJ1wiJyxcclxuICAgICAgICAgICAgICAgICcgc3R5bGU9XCJ3aWR0aDonLCBaICogZHcsICdweDsnLFxyXG4gICAgICAgICAgICAgICAgJyBoZWlnaHQ6JywgWiAqIGRoLCAncHg7XCInLFxyXG4gICAgICAgICAgICAgICAgJyBjcm9wbGVmdD1cIicsIHN4IC8gdywgJ1wiJyxcclxuICAgICAgICAgICAgICAgICcgY3JvcHRvcD1cIicsIHN5IC8gaCwgJ1wiJyxcclxuICAgICAgICAgICAgICAgICcgY3JvcHJpZ2h0PVwiJywgKHcgLSBzeCAtIHN3KSAvIHcsICdcIicsXHJcbiAgICAgICAgICAgICAgICAnIGNyb3Bib3R0b209XCInLCAoaCAtIHN5IC0gc2gpIC8gaCwgJ1wiJyxcclxuICAgICAgICAgICAgICAgICcgLz4nLFxyXG4gICAgICAgICAgICAgICAgJzwvZ192bWxfOmdyb3VwPicpO1xyXG5cclxuICAgIHRoaXMuZWxlbWVudF8uaW5zZXJ0QWRqYWNlbnRIVE1MKCdCZWZvcmVFbmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bWxTdHIuam9pbignJykpO1xyXG4gIH07XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUuc3Ryb2tlID0gZnVuY3Rpb24oYUZpbGwpIHtcclxuICAgIHZhciBsaW5lU3RyID0gW107XHJcbiAgICB2YXIgbGluZU9wZW4gPSBmYWxzZTtcclxuICAgIHZhciBhID0gcHJvY2Vzc1N0eWxlKGFGaWxsID8gdGhpcy5maWxsU3R5bGUgOiB0aGlzLnN0cm9rZVN0eWxlKTtcclxuICAgIHZhciBjb2xvciA9IGEuY29sb3I7XHJcbiAgICB2YXIgb3BhY2l0eSA9IGEuYWxwaGEgKiB0aGlzLmdsb2JhbEFscGhhO1xyXG5cclxuICAgIHZhciBXID0gMTA7XHJcbiAgICB2YXIgSCA9IDEwO1xyXG5cclxuICAgIGxpbmVTdHIucHVzaCgnPGdfdm1sXzpzaGFwZScsXHJcbiAgICAgICAgICAgICAgICAgJyBmaWxsZWQ9XCInLCAhIWFGaWxsLCAnXCInLFxyXG4gICAgICAgICAgICAgICAgICcgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDonLCBXLCAncHg7aGVpZ2h0OicsIEgsICdweDtcIicsXHJcbiAgICAgICAgICAgICAgICAgJyBjb29yZG9yaWdpbj1cIjAgMFwiIGNvb3Jkc2l6ZT1cIicsIFogKiBXLCAnICcsIFogKiBILCAnXCInLFxyXG4gICAgICAgICAgICAgICAgICcgc3Ryb2tlZD1cIicsICFhRmlsbCwgJ1wiJyxcclxuICAgICAgICAgICAgICAgICAnIHBhdGg9XCInKTtcclxuXHJcbiAgICB2YXIgbmV3U2VxID0gZmFsc2U7XHJcbiAgICB2YXIgbWluID0ge3g6IG51bGwsIHk6IG51bGx9O1xyXG4gICAgdmFyIG1heCA9IHt4OiBudWxsLCB5OiBudWxsfTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY3VycmVudFBhdGhfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBwID0gdGhpcy5jdXJyZW50UGF0aF9baV07XHJcbiAgICAgIHZhciBjO1xyXG5cclxuICAgICAgc3dpdGNoIChwLnR5cGUpIHtcclxuICAgICAgICBjYXNlICdtb3ZlVG8nOlxyXG4gICAgICAgICAgYyA9IHA7XHJcbiAgICAgICAgICBsaW5lU3RyLnB1c2goJyBtICcsIG1yKHAueCksICcsJywgbXIocC55KSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdsaW5lVG8nOlxyXG4gICAgICAgICAgbGluZVN0ci5wdXNoKCcgbCAnLCBtcihwLngpLCAnLCcsIG1yKHAueSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnY2xvc2UnOlxyXG4gICAgICAgICAgbGluZVN0ci5wdXNoKCcgeCAnKTtcclxuICAgICAgICAgIHAgPSBudWxsO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYmV6aWVyQ3VydmVUbyc6XHJcbiAgICAgICAgICBsaW5lU3RyLnB1c2goJyBjICcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbXIocC5jcDF4KSwgJywnLCBtcihwLmNwMXkpLCAnLCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbXIocC5jcDJ4KSwgJywnLCBtcihwLmNwMnkpLCAnLCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbXIocC54KSwgJywnLCBtcihwLnkpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2F0JzpcclxuICAgICAgICBjYXNlICd3YSc6XHJcbiAgICAgICAgICBsaW5lU3RyLnB1c2goJyAnLCBwLnR5cGUsICcgJyxcclxuICAgICAgICAgICAgICAgICAgICAgICBtcihwLnggLSB0aGlzLmFyY1NjYWxlWF8gKiBwLnJhZGl1cyksICcsJyxcclxuICAgICAgICAgICAgICAgICAgICAgICBtcihwLnkgLSB0aGlzLmFyY1NjYWxlWV8gKiBwLnJhZGl1cyksICcgJyxcclxuICAgICAgICAgICAgICAgICAgICAgICBtcihwLnggKyB0aGlzLmFyY1NjYWxlWF8gKiBwLnJhZGl1cyksICcsJyxcclxuICAgICAgICAgICAgICAgICAgICAgICBtcihwLnkgKyB0aGlzLmFyY1NjYWxlWV8gKiBwLnJhZGl1cyksICcgJyxcclxuICAgICAgICAgICAgICAgICAgICAgICBtcihwLnhTdGFydCksICcsJywgbXIocC55U3RhcnQpLCAnICcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbXIocC54RW5kKSwgJywnLCBtcihwLnlFbmQpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLy8gVE9ETzogRm9sbG93aW5nIGlzIGJyb2tlbiBmb3IgY3VydmVzIGR1ZSB0b1xyXG4gICAgICAvLyAgICAgICBtb3ZlIHRvIHByb3BlciBwYXRocy5cclxuXHJcbiAgICAgIC8vIEZpZ3VyZSBvdXQgZGltZW5zaW9ucyBzbyB3ZSBjYW4gZG8gZ3JhZGllbnQgZmlsbHNcclxuICAgICAgLy8gcHJvcGVybHlcclxuICAgICAgaWYgKHApIHtcclxuICAgICAgICBpZiAobWluLnggPT0gbnVsbCB8fCBwLnggPCBtaW4ueCkge1xyXG4gICAgICAgICAgbWluLnggPSBwLng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXgueCA9PSBudWxsIHx8IHAueCA+IG1heC54KSB7XHJcbiAgICAgICAgICBtYXgueCA9IHAueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pbi55ID09IG51bGwgfHwgcC55IDwgbWluLnkpIHtcclxuICAgICAgICAgIG1pbi55ID0gcC55O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4LnkgPT0gbnVsbCB8fCBwLnkgPiBtYXgueSkge1xyXG4gICAgICAgICAgbWF4LnkgPSBwLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsaW5lU3RyLnB1c2goJyBcIj4nKTtcclxuXHJcbiAgICBpZiAoIWFGaWxsKSB7XHJcbiAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmxpbmVTY2FsZV8gKiB0aGlzLmxpbmVXaWR0aDtcclxuXHJcbiAgICAgIC8vIFZNTCBjYW5ub3QgY29ycmVjdGx5IHJlbmRlciBhIGxpbmUgaWYgdGhlIHdpZHRoIGlzIGxlc3MgdGhhbiAxcHguXHJcbiAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgZGlsdXRlIHRoZSBjb2xvciB0byBtYWtlIHRoZSBsaW5lIGxvb2sgdGhpbm5lci5cclxuICAgICAgaWYgKGxpbmVXaWR0aCA8IDEpIHtcclxuICAgICAgICBvcGFjaXR5ICo9IGxpbmVXaWR0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGluZVN0ci5wdXNoKFxyXG4gICAgICAgICc8Z192bWxfOnN0cm9rZScsXHJcbiAgICAgICAgJyBvcGFjaXR5PVwiJywgb3BhY2l0eSwgJ1wiJyxcclxuICAgICAgICAnIGpvaW5zdHlsZT1cIicsIHRoaXMubGluZUpvaW4sICdcIicsXHJcbiAgICAgICAgJyBtaXRlcmxpbWl0PVwiJywgdGhpcy5taXRlckxpbWl0LCAnXCInLFxyXG4gICAgICAgICcgZW5kY2FwPVwiJywgcHJvY2Vzc0xpbmVDYXAodGhpcy5saW5lQ2FwKSwgJ1wiJyxcclxuICAgICAgICAnIHdlaWdodD1cIicsIGxpbmVXaWR0aCwgJ3B4XCInLFxyXG4gICAgICAgICcgY29sb3I9XCInLCBjb2xvciwgJ1wiIC8+J1xyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5maWxsU3R5bGUgPT0gJ29iamVjdCcpIHtcclxuICAgICAgdmFyIGZpbGxTdHlsZSA9IHRoaXMuZmlsbFN0eWxlO1xyXG4gICAgICB2YXIgYW5nbGUgPSAwO1xyXG4gICAgICB2YXIgZm9jdXMgPSB7eDogMCwgeTogMH07XHJcblxyXG4gICAgICAvLyBhZGRpdGlvbmFsIG9mZnNldFxyXG4gICAgICB2YXIgc2hpZnQgPSAwO1xyXG4gICAgICAvLyBzY2FsZSBmYWN0b3IgZm9yIG9mZnNldFxyXG4gICAgICB2YXIgZXhwYW5zaW9uID0gMTtcclxuXHJcbiAgICAgIGlmIChmaWxsU3R5bGUudHlwZV8gPT0gJ2dyYWRpZW50Jykge1xyXG4gICAgICAgIHZhciB4MCA9IGZpbGxTdHlsZS54MF8gLyB0aGlzLmFyY1NjYWxlWF87XHJcbiAgICAgICAgdmFyIHkwID0gZmlsbFN0eWxlLnkwXyAvIHRoaXMuYXJjU2NhbGVZXztcclxuICAgICAgICB2YXIgeDEgPSBmaWxsU3R5bGUueDFfIC8gdGhpcy5hcmNTY2FsZVhfO1xyXG4gICAgICAgIHZhciB5MSA9IGZpbGxTdHlsZS55MV8gLyB0aGlzLmFyY1NjYWxlWV87XHJcbiAgICAgICAgdmFyIHAwID0gdGhpcy5nZXRDb29yZHNfKHgwLCB5MCk7XHJcbiAgICAgICAgdmFyIHAxID0gdGhpcy5nZXRDb29yZHNfKHgxLCB5MSk7XHJcbiAgICAgICAgdmFyIGR4ID0gcDEueCAtIHAwLng7XHJcbiAgICAgICAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XHJcbiAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKGR4LCBkeSkgKiAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgICAvLyBUaGUgYW5nbGUgc2hvdWxkIGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci5cclxuICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XHJcbiAgICAgICAgICBhbmdsZSArPSAzNjA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBWZXJ5IHNtYWxsIGFuZ2xlcyBwcm9kdWNlIGFuIHVuZXhwZWN0ZWQgcmVzdWx0IGJlY2F1c2UgdGhleSBhcmVcclxuICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gYSBzY2llbnRpZmljIG5vdGF0aW9uIHN0cmluZy5cclxuICAgICAgICBpZiAoYW5nbGUgPCAxZS02KSB7XHJcbiAgICAgICAgICBhbmdsZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBwMCA9IHRoaXMuZ2V0Q29vcmRzXyhmaWxsU3R5bGUueDBfLCBmaWxsU3R5bGUueTBfKTtcclxuICAgICAgICB2YXIgd2lkdGggID0gbWF4LnggLSBtaW4ueDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gbWF4LnkgLSBtaW4ueTtcclxuICAgICAgICBmb2N1cyA9IHtcclxuICAgICAgICAgIHg6IChwMC54IC0gbWluLngpIC8gd2lkdGgsXHJcbiAgICAgICAgICB5OiAocDAueSAtIG1pbi55KSAvIGhlaWdodFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHdpZHRoICAvPSB0aGlzLmFyY1NjYWxlWF8gKiBaO1xyXG4gICAgICAgIGhlaWdodCAvPSB0aGlzLmFyY1NjYWxlWV8gKiBaO1xyXG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBtLm1heCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBzaGlmdCA9IDIgKiBmaWxsU3R5bGUucjBfIC8gZGltZW5zaW9uO1xyXG4gICAgICAgIGV4cGFuc2lvbiA9IDIgKiBmaWxsU3R5bGUucjFfIC8gZGltZW5zaW9uIC0gc2hpZnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdlIG5lZWQgdG8gc29ydCB0aGUgY29sb3Igc3RvcHMgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IG9mZnNldCxcclxuICAgICAgLy8gb3RoZXJ3aXNlIElFIHdvbid0IGludGVycHJldCBpdCBjb3JyZWN0bHkuXHJcbiAgICAgIHZhciBzdG9wcyA9IGZpbGxTdHlsZS5jb2xvcnNfO1xyXG4gICAgICBzdG9wcy5zb3J0KGZ1bmN0aW9uKGNzMSwgY3MyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNzMS5vZmZzZXQgLSBjczIub2Zmc2V0O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciBsZW5ndGggPSBzdG9wcy5sZW5ndGg7XHJcbiAgICAgIHZhciBjb2xvcjEgPSBzdG9wc1swXS5jb2xvcjtcclxuICAgICAgdmFyIGNvbG9yMiA9IHN0b3BzW2xlbmd0aCAtIDFdLmNvbG9yO1xyXG4gICAgICB2YXIgb3BhY2l0eTEgPSBzdG9wc1swXS5hbHBoYSAqIHRoaXMuZ2xvYmFsQWxwaGE7XHJcbiAgICAgIHZhciBvcGFjaXR5MiA9IHN0b3BzW2xlbmd0aCAtIDFdLmFscGhhICogdGhpcy5nbG9iYWxBbHBoYTtcclxuXHJcbiAgICAgIHZhciBjb2xvcnMgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XHJcbiAgICAgICAgY29sb3JzLnB1c2goc3RvcC5vZmZzZXQgKiBleHBhbnNpb24gKyBzaGlmdCArICcgJyArIHN0b3AuY29sb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBXaGVuIGNvbG9ycyBhdHRyaWJ1dGUgaXMgdXNlZCwgdGhlIG1lYW5pbmdzIG9mIG9wYWNpdHkgYW5kIG86b3BhY2l0eTJcclxuICAgICAgLy8gYXJlIHJldmVyc2VkLlxyXG4gICAgICBsaW5lU3RyLnB1c2goJzxnX3ZtbF86ZmlsbCB0eXBlPVwiJywgZmlsbFN0eWxlLnR5cGVfLCAnXCInLFxyXG4gICAgICAgICAgICAgICAgICAgJyBtZXRob2Q9XCJub25lXCIgZm9jdXM9XCIxMDAlXCInLFxyXG4gICAgICAgICAgICAgICAgICAgJyBjb2xvcj1cIicsIGNvbG9yMSwgJ1wiJyxcclxuICAgICAgICAgICAgICAgICAgICcgY29sb3IyPVwiJywgY29sb3IyLCAnXCInLFxyXG4gICAgICAgICAgICAgICAgICAgJyBjb2xvcnM9XCInLCBjb2xvcnMuam9pbignLCcpLCAnXCInLFxyXG4gICAgICAgICAgICAgICAgICAgJyBvcGFjaXR5PVwiJywgb3BhY2l0eTIsICdcIicsXHJcbiAgICAgICAgICAgICAgICAgICAnIGdfb186b3BhY2l0eTI9XCInLCBvcGFjaXR5MSwgJ1wiJyxcclxuICAgICAgICAgICAgICAgICAgICcgYW5nbGU9XCInLCBhbmdsZSwgJ1wiJyxcclxuICAgICAgICAgICAgICAgICAgICcgZm9jdXNwb3NpdGlvbj1cIicsIGZvY3VzLngsICcsJywgZm9jdXMueSwgJ1wiIC8+Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsaW5lU3RyLnB1c2goJzxnX3ZtbF86ZmlsbCBjb2xvcj1cIicsIGNvbG9yLCAnXCIgb3BhY2l0eT1cIicsIG9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAnXCIgLz4nKTtcclxuICAgIH1cclxuXHJcbiAgICBsaW5lU3RyLnB1c2goJzwvZ192bWxfOnNoYXBlPicpO1xyXG5cclxuICAgIHRoaXMuZWxlbWVudF8uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVFbmQnLCBsaW5lU3RyLmpvaW4oJycpKTtcclxuICB9O1xyXG5cclxuICBjb250ZXh0UHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuc3Ryb2tlKHRydWUpO1xyXG4gIH1cclxuXHJcbiAgY29udGV4dFByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuY3VycmVudFBhdGhfLnB1c2goe3R5cGU6ICdjbG9zZSd9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGNvbnRleHRQcm90b3R5cGUuZ2V0Q29vcmRzXyA9IGZ1bmN0aW9uKGFYLCBhWSkge1xyXG4gICAgdmFyIG0gPSB0aGlzLm1fO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogWiAqIChhWCAqIG1bMF1bMF0gKyBhWSAqIG1bMV1bMF0gKyBtWzJdWzBdKSAtIFoyLFxyXG4gICAgICB5OiBaICogKGFYICogbVswXVsxXSArIGFZICogbVsxXVsxXSArIG1bMl1bMV0pIC0gWjJcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb250ZXh0UHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvID0ge307XHJcbiAgICBjb3B5U3RhdGUodGhpcywgbyk7XHJcbiAgICB0aGlzLmFTdGFja18ucHVzaChvKTtcclxuICAgIHRoaXMubVN0YWNrXy5wdXNoKHRoaXMubV8pO1xyXG4gICAgdGhpcy5tXyA9IG1hdHJpeE11bHRpcGx5KGNyZWF0ZU1hdHJpeElkZW50aXR5KCksIHRoaXMubV8pO1xyXG4gIH07XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgY29weVN0YXRlKHRoaXMuYVN0YWNrXy5wb3AoKSwgdGhpcyk7XHJcbiAgICB0aGlzLm1fID0gdGhpcy5tU3RhY2tfLnBvcCgpO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIG1hdHJpeElzRmluaXRlKG0pIHtcclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XHJcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgMjsgaysrKSB7XHJcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShtW2pdW2tdKSB8fCBpc05hTihtW2pdW2tdKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRNKGN0eCwgbSwgdXBkYXRlTGluZVNjYWxlKSB7XHJcbiAgICBpZiAoIW1hdHJpeElzRmluaXRlKG0pKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGN0eC5tXyA9IG07XHJcblxyXG4gICAgaWYgKHVwZGF0ZUxpbmVTY2FsZSkge1xyXG4gICAgICAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXHJcbiAgICAgIC8vIERldGVybWluYW50IG9mIHRoaXMubV8gbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXHJcbiAgICAgIC8vIHRyYW5zZm9ybWF0aW9uLiBTbyBpdHMgc3F1YXJlIHJvb3QgY2FuIGJlIHVzZWQgYXMgYSBzY2FsZSBmYWN0b3JcclxuICAgICAgLy8gZm9yIHdpZHRoLlxyXG4gICAgICB2YXIgZGV0ID0gbVswXVswXSAqIG1bMV1bMV0gLSBtWzBdWzFdICogbVsxXVswXTtcclxuICAgICAgY3R4LmxpbmVTY2FsZV8gPSBzcXJ0KGFicyhkZXQpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oYVgsIGFZKSB7XHJcbiAgICB2YXIgbTEgPSBbXHJcbiAgICAgIFsxLCAgMCwgIDBdLFxyXG4gICAgICBbMCwgIDEsICAwXSxcclxuICAgICAgW2FYLCBhWSwgMV1cclxuICAgIF07XHJcblxyXG4gICAgc2V0TSh0aGlzLCBtYXRyaXhNdWx0aXBseShtMSwgdGhpcy5tXyksIGZhbHNlKTtcclxuICB9O1xyXG5cclxuICBjb250ZXh0UHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKGFSb3QpIHtcclxuICAgIHZhciBjID0gbWMoYVJvdCk7XHJcbiAgICB2YXIgcyA9IG1zKGFSb3QpO1xyXG5cclxuICAgIHZhciBtMSA9IFtcclxuICAgICAgW2MsICBzLCAwXSxcclxuICAgICAgWy1zLCBjLCAwXSxcclxuICAgICAgWzAsICAwLCAxXVxyXG4gICAgXTtcclxuXHJcbiAgICBzZXRNKHRoaXMsIG1hdHJpeE11bHRpcGx5KG0xLCB0aGlzLm1fKSwgZmFsc2UpO1xyXG4gIH07XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbihhWCwgYVkpIHtcclxuICAgIHRoaXMuYXJjU2NhbGVYXyAqPSBhWDtcclxuICAgIHRoaXMuYXJjU2NhbGVZXyAqPSBhWTtcclxuICAgIHZhciBtMSA9IFtcclxuICAgICAgW2FYLCAwLCAgMF0sXHJcbiAgICAgIFswLCAgYVksIDBdLFxyXG4gICAgICBbMCwgIDAsICAxXVxyXG4gICAgXTtcclxuXHJcbiAgICBzZXRNKHRoaXMsIG1hdHJpeE11bHRpcGx5KG0xLCB0aGlzLm1fKSwgdHJ1ZSk7XHJcbiAgfTtcclxuXHJcbiAgY29udGV4dFByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihtMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeSkge1xyXG4gICAgdmFyIG0xID0gW1xyXG4gICAgICBbbTExLCBtMTIsIDBdLFxyXG4gICAgICBbbTIxLCBtMjIsIDBdLFxyXG4gICAgICBbZHgsICBkeSwgIDFdXHJcbiAgICBdO1xyXG5cclxuICAgIHNldE0odGhpcywgbWF0cml4TXVsdGlwbHkobTEsIHRoaXMubV8pLCB0cnVlKTtcclxuICB9O1xyXG5cclxuICBjb250ZXh0UHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKG0xMSwgbTEyLCBtMjEsIG0yMiwgZHgsIGR5KSB7XHJcbiAgICB2YXIgbSA9IFtcclxuICAgICAgW20xMSwgbTEyLCAwXSxcclxuICAgICAgW20yMSwgbTIyLCAwXSxcclxuICAgICAgW2R4LCAgZHksICAxXVxyXG4gICAgXTtcclxuXHJcbiAgICBzZXRNKHRoaXMsIG0sIHRydWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKioqKioqKiBTVFVCUyAqKioqKioqKi9cclxuICBjb250ZXh0UHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIFRPRE86IEltcGxlbWVudFxyXG4gIH07XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUuYXJjVG8gPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIFRPRE86IEltcGxlbWVudFxyXG4gIH07XHJcblxyXG4gIGNvbnRleHRQcm90b3R5cGUuY3JlYXRlUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG5ldyBDYW52YXNQYXR0ZXJuXztcclxuICB9O1xyXG5cclxuICAvLyBHcmFkaWVudCAvIFBhdHRlcm4gU3R1YnNcclxuICBmdW5jdGlvbiBDYW52YXNHcmFkaWVudF8oYVR5cGUpIHtcclxuICAgIHRoaXMudHlwZV8gPSBhVHlwZTtcclxuICAgIHRoaXMueDBfID0gMDtcclxuICAgIHRoaXMueTBfID0gMDtcclxuICAgIHRoaXMucjBfID0gMDtcclxuICAgIHRoaXMueDFfID0gMDtcclxuICAgIHRoaXMueTFfID0gMDtcclxuICAgIHRoaXMucjFfID0gMDtcclxuICAgIHRoaXMuY29sb3JzXyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgQ2FudmFzR3JhZGllbnRfLnByb3RvdHlwZS5hZGRDb2xvclN0b3AgPSBmdW5jdGlvbihhT2Zmc2V0LCBhQ29sb3IpIHtcclxuICAgIGFDb2xvciA9IHByb2Nlc3NTdHlsZShhQ29sb3IpO1xyXG4gICAgdGhpcy5jb2xvcnNfLnB1c2goe29mZnNldDogYU9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogYUNvbG9yLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGFscGhhOiBhQ29sb3IuYWxwaGF9KTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBDYW52YXNQYXR0ZXJuXygpIHt9XHJcblxyXG4gIC8vIHNldCB1cCBleHRlcm5zXHJcbiAgR192bWxDYW52YXNNYW5hZ2VyID0gR192bWxDYW52YXNNYW5hZ2VyXztcclxuICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRfO1xyXG4gIENhbnZhc0dyYWRpZW50ID0gQ2FudmFzR3JhZGllbnRfO1xyXG4gIENhbnZhc1BhdHRlcm4gPSBDYW52YXNQYXR0ZXJuXztcclxuXHJcbn0pKCk7XHJcblxyXG59IC8vIGlmIl19
