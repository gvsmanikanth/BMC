(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.noscope = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.4.0
/*
#
# Opentip v2.4.6
#
# More info at [www.opentip.org](http://www.opentip.org)
# 
# Copyright (c) 2012, Matias Meno  
# Graphics by Tjandra Mayerhold
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
*/

var Opentip, firstAdapter, i, mouseMoved, mousePosition, mousePositionObservers, position, vendors, _i, _len, _ref,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty;

Opentip = (function() {

  Opentip.prototype.STICKS_OUT_TOP = 1;

  Opentip.prototype.STICKS_OUT_BOTTOM = 2;

  Opentip.prototype.STICKS_OUT_LEFT = 1;

  Opentip.prototype.STICKS_OUT_RIGHT = 2;

  Opentip.prototype["class"] = {
    container: "opentip-container",
    opentip: "opentip",
    header: "ot-header",
    content: "ot-content",
    loadingIndicator: "ot-loading-indicator",
    close: "ot-close",
    goingToHide: "ot-going-to-hide",
    hidden: "ot-hidden",
    hiding: "ot-hiding",
    goingToShow: "ot-going-to-show",
    showing: "ot-showing",
    visible: "ot-visible",
    loading: "ot-loading",
    ajaxError: "ot-ajax-error",
    fixed: "ot-fixed",
    showEffectPrefix: "ot-show-effect-",
    hideEffectPrefix: "ot-hide-effect-",
    stylePrefix: "style-"
  };

  function Opentip(element, content, title, options) {
    var elementsOpentips, hideTrigger, methodToBind, optionSources, prop, styleName, _i, _j, _len, _len1, _ref, _ref1, _ref2, _tmpStyle,
      _this = this;
    this.id = ++Opentip.lastId;
    this.debug("Creating Opentip.");
    Opentip.tips.push(this);
    this.adapter = Opentip.adapter;
    elementsOpentips = this.adapter.data(element, "opentips") || [];
    elementsOpentips.push(this);
    this.adapter.data(element, "opentips", elementsOpentips);
    this.triggerElement = this.adapter.wrap(element);
    if (this.triggerElement.length > 1) {
      throw new Error("You can't call Opentip on multiple elements.");
    }
    if (this.triggerElement.length < 1) {
      throw new Error("Invalid element.");
    }
    this.loaded = false;
    this.loading = false;
    this.visible = false;
    this.waitingToShow = false;
    this.waitingToHide = false;
    this.currentPosition = {
      left: 0,
      top: 0
    };
    this.dimensions = {
      width: 100,
      height: 50
    };
    this.content = "";
    this.redraw = true;
    this.currentObservers = {
      showing: false,
      visible: false,
      hiding: false,
      hidden: false
    };
    options = this.adapter.clone(options);
    if (typeof content === "object") {
      options = content;
      content = title = void 0;
    } else if (typeof title === "object") {
      options = title;
      title = void 0;
    }
    if (title != null) {
      options.title = title;
    }
    if (content != null) {
      this.setContent(content);
    }
    if (options["extends"] == null) {
      if (options.style != null) {
        options["extends"] = options.style;
      } else {
        options["extends"] = Opentip.defaultStyle;
      }
    }
    optionSources = [options];
    _tmpStyle = options;
    while (_tmpStyle["extends"]) {
      styleName = _tmpStyle["extends"];
      _tmpStyle = Opentip.styles[styleName];
      if (_tmpStyle == null) {
        throw new Error("Invalid style: " + styleName);
      }
      optionSources.unshift(_tmpStyle);
      if (!((_tmpStyle["extends"] != null) || styleName === "standard")) {
        _tmpStyle["extends"] = "standard";
      }
    }
    options = (_ref = this.adapter).extend.apply(_ref, [{}].concat(__slice.call(optionSources)));
    options.hideTriggers = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = options.hideTriggers;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        hideTrigger = _ref1[_i];
        _results.push(hideTrigger);
      }
      return _results;
    })();
    if (options.hideTrigger && options.hideTriggers.length === 0) {
      options.hideTriggers.push(options.hideTrigger);
    }
    _ref1 = ["tipJoint", "targetJoint", "stem"];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      prop = _ref1[_i];
      if (options[prop] && typeof options[prop] === "string") {
        options[prop] = new Opentip.Joint(options[prop]);
      }
    }
    if (options.ajax && (options.ajax === true || !options.ajax)) {
      if (this.adapter.tagName(this.triggerElement) === "A") {
        options.ajax = this.adapter.attr(this.triggerElement, "href");
      } else {
        options.ajax = false;
      }
    }
    if (options.showOn === "click" && this.adapter.tagName(this.triggerElement) === "A") {
      this.adapter.observe(this.triggerElement, "click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        return e.stopped = true;
      });
    }
    if (options.target) {
      options.fixed = true;
    }
    if (options.stem === true) {
      options.stem = new Opentip.Joint(options.tipJoint);
    }
    if (options.target === true) {
      options.target = this.triggerElement;
    } else if (options.target) {
      options.target = this.adapter.wrap(options.target);
    }
    this.currentStem = options.stem;
    if (options.delay == null) {
      options.delay = options.showOn === "mouseover" ? 0.2 : 0;
    }
    if (options.targetJoint == null) {
      options.targetJoint = new Opentip.Joint(options.tipJoint).flip();
    }
    this.showTriggers = [];
    this.showTriggersWhenVisible = [];
    this.hideTriggers = [];
    if (options.showOn && options.showOn !== "creation") {
      this.showTriggers.push({
        element: this.triggerElement,
        event: options.showOn
      });
    }
    if (options.ajaxCache != null) {
      options.cache = options.ajaxCache;
      delete options.ajaxCache;
    }
    this.options = options;
    this.bound = {};
    _ref2 = ["prepareToShow", "prepareToHide", "show", "hide", "reposition"];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      methodToBind = _ref2[_j];
      this.bound[methodToBind] = (function(methodToBind) {
        return function() {
          return _this[methodToBind].apply(_this, arguments);
        };
      })(methodToBind);
    }
    this.adapter.domReady(function() {
      _this.activate();
      if (_this.options.showOn === "creation") {
        return _this.prepareToShow();
      }
    });
  }

  Opentip.prototype._setup = function() {
    var hideOn, hideTrigger, hideTriggerElement, i, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.debug("Setting up the tooltip.");
    this._buildContainer();
    this.hideTriggers = [];
    _ref = this.options.hideTriggers;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      hideTrigger = _ref[i];
      hideTriggerElement = null;
      hideOn = this.options.hideOn instanceof Array ? this.options.hideOn[i] : this.options.hideOn;
      if (typeof hideTrigger === "string") {
        switch (hideTrigger) {
          case "trigger":
            hideOn = hideOn || "mouseout";
            hideTriggerElement = this.triggerElement;
            break;
          case "tip":
            hideOn = hideOn || "mouseover";
            hideTriggerElement = this.container;
            break;
          case "target":
            hideOn = hideOn || "mouseover";
            hideTriggerElement = this.options.target;
            break;
          case "closeButton":
            break;
          default:
            throw new Error("Unknown hide trigger: " + hideTrigger + ".");
        }
      } else {
        hideOn = hideOn || "mouseover";
        hideTriggerElement = this.adapter.wrap(hideTrigger);
      }
      if (hideTriggerElement) {
        this.hideTriggers.push({
          element: hideTriggerElement,
          event: hideOn,
          original: hideTrigger
        });
      }
    }
    _ref1 = this.hideTriggers;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      hideTrigger = _ref1[_j];
      _results.push(this.showTriggersWhenVisible.push({
        element: hideTrigger.element,
        event: "mouseover"
      }));
    }
    return _results;
  };

  Opentip.prototype._buildContainer = function() {
    this.container = this.adapter.create("<div id=\"opentip-" + this.id + "\" class=\"" + this["class"].container + " " + this["class"].hidden + " " + this["class"].stylePrefix + this.options.className + "\"></div>");
    this.adapter.css(this.container, {
      position: "absolute"
    });
    if (this.options.ajax) {
      this.adapter.addClass(this.container, this["class"].loading);
    }
    if (this.options.fixed) {
      this.adapter.addClass(this.container, this["class"].fixed);
    }
    if (this.options.showEffect) {
      this.adapter.addClass(this.container, "" + this["class"].showEffectPrefix + this.options.showEffect);
    }
    if (this.options.hideEffect) {
      return this.adapter.addClass(this.container, "" + this["class"].hideEffectPrefix + this.options.hideEffect);
    }
  };

  Opentip.prototype._buildElements = function() {
    var headerElement, titleElement;
    this.tooltipElement = this.adapter.create("<div class=\"" + this["class"].opentip + "\"><div class=\"" + this["class"].header + "\"></div><div class=\"" + this["class"].content + "\"></div></div>");
    this.backgroundCanvas = this.adapter.wrap(document.createElement("canvas"));
    this.adapter.css(this.backgroundCanvas, {
      position: "absolute"
    });
    if (typeof G_vmlCanvasManager !== "undefined" && G_vmlCanvasManager !== null) {
      G_vmlCanvasManager.initElement(this.adapter.unwrap(this.backgroundCanvas));
    }
    headerElement = this.adapter.find(this.tooltipElement, "." + this["class"].header);
    if (this.options.title) {
      titleElement = this.adapter.create("<h1></h1>");
      this.adapter.update(titleElement, this.options.title, this.options.escapeTitle);
      this.adapter.append(headerElement, titleElement);
    }
    if (this.options.ajax && !this.loaded) {
      this.adapter.append(this.tooltipElement, this.adapter.create("<div class=\"" + this["class"].loadingIndicator + "\"><span>↻</span></div>"));
    }
    if (__indexOf.call(this.options.hideTriggers, "closeButton") >= 0) {
      this.closeButtonElement = this.adapter.create("<a href=\"javascript:undefined;\" class=\"" + this["class"].close + "\"><span>Close</span></a>");
      this.adapter.append(headerElement, this.closeButtonElement);
    }
    this.adapter.append(this.container, this.backgroundCanvas);
    this.adapter.append(this.container, this.tooltipElement);
    this.adapter.append(document.body, this.container);
    this._newContent = true;
    return this.redraw = true;
  };

  Opentip.prototype.setContent = function(content) {
    this.content = content;
    this._newContent = true;
    if (typeof this.content === "function") {
      this._contentFunction = this.content;
      this.content = "";
    } else {
      this._contentFunction = null;
    }
    if (this.visible) {
      return this._updateElementContent();
    }
  };

  Opentip.prototype._updateElementContent = function() {
    var contentDiv;
    if (this._newContent || (!this.options.cache && this._contentFunction)) {
      contentDiv = this.adapter.find(this.container, "." + this["class"].content);
      if (contentDiv != null) {
        if (this._contentFunction) {
          this.debug("Executing content function.");
          this.content = this._contentFunction(this);
        }
        this.adapter.update(contentDiv, this.content, this.options.escapeContent);
      }
      this._newContent = false;
    }
    this._storeAndLockDimensions();
    return this.reposition();
  };

  Opentip.prototype._storeAndLockDimensions = function() {
    var prevDimension;
    if (!this.container) {
      return;
    }
    prevDimension = this.dimensions;
    this.adapter.css(this.container, {
      width: "auto",
      left: "0px",
      top: "0px"
    });
    this.dimensions = this.adapter.dimensions(this.container);
    this.dimensions.width += 1;
    this.adapter.css(this.container, {
      width: "" + this.dimensions.width + "px",
      top: "" + this.currentPosition.top + "px",
      left: "" + this.currentPosition.left + "px"
    });
    if (!this._dimensionsEqual(this.dimensions, prevDimension)) {
      this.redraw = true;
      return this._draw();
    }
  };

  Opentip.prototype.activate = function() {
    return this._setupObservers("hidden", "hiding");
  };

  Opentip.prototype.deactivate = function() {
    this.debug("Deactivating tooltip.");
    this.hide();
    return this._setupObservers("-showing", "-visible", "-hidden", "-hiding");
  };

  Opentip.prototype._setupObservers = function() {
    var observeOrStop, removeObserver, state, states, trigger, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2,
      _this = this;
    states = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = states.length; _i < _len; _i++) {
      state = states[_i];
      removeObserver = false;
      if (state.charAt(0) === "-") {
        removeObserver = true;
        state = state.substr(1);
      }
      if (this.currentObservers[state] === !removeObserver) {
        continue;
      }
      this.currentObservers[state] = !removeObserver;
      observeOrStop = function() {
        var args, _ref, _ref1;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (removeObserver) {
          return (_ref = _this.adapter).stopObserving.apply(_ref, args);
        } else {
          return (_ref1 = _this.adapter).observe.apply(_ref1, args);
        }
      };
      switch (state) {
        case "showing":
          _ref = this.hideTriggers;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            trigger = _ref[_j];
            observeOrStop(trigger.element, trigger.event, this.bound.prepareToHide);
          }
          observeOrStop((document.onresize != null ? document : window), "resize", this.bound.reposition);
          observeOrStop(window, "scroll", this.bound.reposition);
          break;
        case "visible":
          _ref1 = this.showTriggersWhenVisible;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            trigger = _ref1[_k];
            observeOrStop(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          break;
        case "hiding":
          _ref2 = this.showTriggers;
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            trigger = _ref2[_l];
            observeOrStop(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          break;
        case "hidden":
          break;
        default:
          throw new Error("Unknown state: " + state);
      }
    }
    return null;
  };

  Opentip.prototype.prepareToShow = function() {
    this._abortHiding();
    this._abortShowing();
    if (this.visible) {
      return;
    }
    this.debug("Showing in " + this.options.delay + "s.");
    if (this.container == null) {
      this._setup();
    }
    if (this.options.group) {
      Opentip._abortShowingGroup(this.options.group, this);
    }
    this.preparingToShow = true;
    this._setupObservers("-hidden", "-hiding", "showing");
    this._followMousePosition();
    if (this.options.fixed && !this.options.target) {
      this.initialMousePosition = mousePosition;
    }
    this.reposition();
    return this._showTimeoutId = this.setTimeout(this.bound.show, this.options.delay || 0);
  };

  Opentip.prototype.show = function() {
    var _this = this;
    this._abortHiding();
    if (this.visible) {
      return;
    }
    this._clearTimeouts();
    if (!this._triggerElementExists()) {
      return this.deactivate();
    }
    this.debug("Showing now.");
    if (this.container == null) {
      this._setup();
    }
    if (this.options.group) {
      Opentip._hideGroup(this.options.group, this);
    }
    this.visible = true;
    this.preparingToShow = false;
    if (this.tooltipElement == null) {
      this._buildElements();
    }
    this._updateElementContent();
    if (this.options.ajax && (!this.loaded || !this.options.cache)) {
      this._loadAjax();
    }
    this._searchAndActivateCloseButtons();
    this._startEnsureTriggerElement();
    this.adapter.css(this.container, {
      zIndex: Opentip.lastZIndex++
    });
    this._setupObservers("-hidden", "-hiding", "-showing", "-visible", "showing", "visible");
    if (this.options.fixed && !this.options.target) {
      this.initialMousePosition = mousePosition;
    }
    this.reposition();
    this.adapter.removeClass(this.container, this["class"].hiding);
    this.adapter.removeClass(this.container, this["class"].hidden);
    this.adapter.addClass(this.container, this["class"].goingToShow);
    this.setCss3Style(this.container, {
      transitionDuration: "0s"
    });
    this.defer(function() {
      var delay;
      if (!_this.visible || _this.preparingToHide) {
        return;
      }
      _this.adapter.removeClass(_this.container, _this["class"].goingToShow);
      _this.adapter.addClass(_this.container, _this["class"].showing);
      delay = 0;
      if (_this.options.showEffect && _this.options.showEffectDuration) {
        delay = _this.options.showEffectDuration;
      }
      _this.setCss3Style(_this.container, {
        transitionDuration: "" + delay + "s"
      });
      _this._visibilityStateTimeoutId = _this.setTimeout(function() {
        _this.adapter.removeClass(_this.container, _this["class"].showing);
        return _this.adapter.addClass(_this.container, _this["class"].visible);
      }, delay);
      return _this._activateFirstInput();
    });
    return this._draw();
  };

  Opentip.prototype._abortShowing = function() {
    if (this.preparingToShow) {
      this.debug("Aborting showing.");
      this._clearTimeouts();
      this._stopFollowingMousePosition();
      this.preparingToShow = false;
      return this._setupObservers("-showing", "-visible", "hiding", "hidden");
    }
  };

  Opentip.prototype.prepareToHide = function() {
    this._abortShowing();
    this._abortHiding();
    if (!this.visible) {
      return;
    }
    this.debug("Hiding in " + this.options.hideDelay + "s");
    this.preparingToHide = true;
    this._setupObservers("-showing", "visible", "-hidden", "hiding");
    return this._hideTimeoutId = this.setTimeout(this.bound.hide, this.options.hideDelay);
  };

  Opentip.prototype.hide = function() {
    var _this = this;
    this._abortShowing();
    if (!this.visible) {
      return;
    }
    this._clearTimeouts();
    this.debug("Hiding!");
    this.visible = false;
    this.preparingToHide = false;
    this._stopEnsureTriggerElement();
    this._setupObservers("-showing", "-visible", "-hiding", "-hidden", "hiding", "hidden");
    if (!this.options.fixed) {
      this._stopFollowingMousePosition();
    }
    if (!this.container) {
      return;
    }
    this.adapter.removeClass(this.container, this["class"].visible);
    this.adapter.removeClass(this.container, this["class"].showing);
    this.adapter.addClass(this.container, this["class"].goingToHide);
    this.setCss3Style(this.container, {
      transitionDuration: "0s"
    });
    return this.defer(function() {
      var hideDelay;
      _this.adapter.removeClass(_this.container, _this["class"].goingToHide);
      _this.adapter.addClass(_this.container, _this["class"].hiding);
      hideDelay = 0;
      if (_this.options.hideEffect && _this.options.hideEffectDuration) {
        hideDelay = _this.options.hideEffectDuration;
      }
      _this.setCss3Style(_this.container, {
        transitionDuration: "" + hideDelay + "s"
      });
      return _this._visibilityStateTimeoutId = _this.setTimeout(function() {
        _this.adapter.removeClass(_this.container, _this["class"].hiding);
        _this.adapter.addClass(_this.container, _this["class"].hidden);
        _this.setCss3Style(_this.container, {
          transitionDuration: "0s"
        });
        if (_this.options.removeElementsOnHide) {
          _this.debug("Removing HTML elements.");
          _this.adapter.remove(_this.container);
          delete _this.container;
          return delete _this.tooltipElement;
        }
      }, hideDelay);
    });
  };

  Opentip.prototype._abortHiding = function() {
    if (this.preparingToHide) {
      this.debug("Aborting hiding.");
      this._clearTimeouts();
      this.preparingToHide = false;
      return this._setupObservers("-hiding", "showing", "visible");
    }
  };

  Opentip.prototype.reposition = function() {
    var position, stem, _ref,
      _this = this;
    position = this.getPosition();
    if (position == null) {
      return;
    }
    stem = this.options.stem;
    if (this.options.containInViewport) {
      _ref = this._ensureViewportContainment(position), position = _ref.position, stem = _ref.stem;
    }
    if (this._positionsEqual(position, this.currentPosition)) {
      return;
    }
    if (!(!this.options.stem || stem.eql(this.currentStem))) {
      this.redraw = true;
    }
    this.currentPosition = position;
    this.currentStem = stem;
    this._draw();
    this.adapter.css(this.container, {
      left: "" + position.left + "px",
      top: "" + position.top + "px"
    });
    return this.defer(function() {
      var rawContainer, redrawFix;
      rawContainer = _this.adapter.unwrap(_this.container);
      rawContainer.style.visibility = "hidden";
      redrawFix = rawContainer.offsetHeight;
      return rawContainer.style.visibility = "visible";
    });
  };

  Opentip.prototype.getPosition = function(tipJoint, targetJoint, stem) {
    var additionalHorizontal, additionalVertical, offsetDistance, position, stemLength, targetDimensions, targetPosition, unwrappedTarget, _ref;
    if (!this.container) {
      return;
    }
    if (tipJoint == null) {
      tipJoint = this.options.tipJoint;
    }
    if (targetJoint == null) {
      targetJoint = this.options.targetJoint;
    }
    position = {};
    if (this.options.target) {
      targetPosition = this.adapter.offset(this.options.target);
      targetDimensions = this.adapter.dimensions(this.options.target);
      position = targetPosition;
      if (targetJoint.right) {
        unwrappedTarget = this.adapter.unwrap(this.options.target);
        if (unwrappedTarget.getBoundingClientRect != null) {
          position.left = unwrappedTarget.getBoundingClientRect().right + ((_ref = window.pageXOffset) != null ? _ref : document.body.scrollLeft);
        } else {
          position.left += targetDimensions.width;
        }
      } else if (targetJoint.center) {
        position.left += Math.round(targetDimensions.width / 2);
      }
      if (targetJoint.bottom) {
        position.top += targetDimensions.height;
      } else if (targetJoint.middle) {
        position.top += Math.round(targetDimensions.height / 2);
      }
      if (this.options.borderWidth) {
        if (this.options.tipJoint.left) {
          position.left += this.options.borderWidth;
        }
        if (this.options.tipJoint.right) {
          position.left -= this.options.borderWidth;
        }
        if (this.options.tipJoint.top) {
          position.top += this.options.borderWidth;
        } else if (this.options.tipJoint.bottom) {
          position.top -= this.options.borderWidth;
        }
      }
    } else {
      if (this.initialMousePosition) {
        position = {
          top: this.initialMousePosition.y,
          left: this.initialMousePosition.x
        };
      } else {
        position = {
          top: mousePosition.y,
          left: mousePosition.x
        };
      }
    }
    if (this.options.autoOffset) {
      stemLength = this.options.stem ? this.options.stemLength : 0;
      offsetDistance = stemLength && this.options.fixed ? 2 : 10;
      additionalHorizontal = tipJoint.middle && !this.options.fixed ? 15 : 0;
      additionalVertical = tipJoint.center && !this.options.fixed ? 15 : 0;
      if (tipJoint.right) {
        position.left -= offsetDistance + additionalHorizontal;
      } else if (tipJoint.left) {
        position.left += offsetDistance + additionalHorizontal;
      }
      if (tipJoint.bottom) {
        position.top -= offsetDistance + additionalVertical;
      } else if (tipJoint.top) {
        position.top += offsetDistance + additionalVertical;
      }
      if (stemLength) {
        if (stem == null) {
          stem = this.options.stem;
        }
        if (stem.right) {
          position.left -= stemLength;
        } else if (stem.left) {
          position.left += stemLength;
        }
        if (stem.bottom) {
          position.top -= stemLength;
        } else if (stem.top) {
          position.top += stemLength;
        }
      }
    }
    position.left += this.options.offset[0];
    position.top += this.options.offset[1];
    if (tipJoint.right) {
      position.left -= this.dimensions.width;
    } else if (tipJoint.center) {
      position.left -= Math.round(this.dimensions.width / 2);
    }
    if (tipJoint.bottom) {
      position.top -= this.dimensions.height;
    } else if (tipJoint.middle) {
      position.top -= Math.round(this.dimensions.height / 2);
    }
    return position;
  };

  Opentip.prototype._ensureViewportContainment = function(position) {
    var needsRepositioning, newSticksOut, originals, revertedX, revertedY, scrollOffset, stem, sticksOut, targetJoint, tipJoint, viewportDimensions, viewportPosition;
    stem = this.options.stem;
    originals = {
      position: position,
      stem: stem
    };
    if (!(this.visible && position)) {
      return originals;
    }
    sticksOut = this._sticksOut(position);
    if (!(sticksOut[0] || sticksOut[1])) {
      return originals;
    }
    tipJoint = new Opentip.Joint(this.options.tipJoint);
    if (this.options.targetJoint) {
      targetJoint = new Opentip.Joint(this.options.targetJoint);
    }
    scrollOffset = this.adapter.scrollOffset();
    viewportDimensions = this.adapter.viewportDimensions();
    viewportPosition = [position.left - scrollOffset[0], position.top - scrollOffset[1]];
    needsRepositioning = false;
    if (viewportDimensions.width >= this.dimensions.width) {
      if (sticksOut[0]) {
        needsRepositioning = true;
        switch (sticksOut[0]) {
          case this.STICKS_OUT_LEFT:
            tipJoint.setHorizontal("left");
            if (this.options.targetJoint) {
              targetJoint.setHorizontal("right");
            }
            break;
          case this.STICKS_OUT_RIGHT:
            tipJoint.setHorizontal("right");
            if (this.options.targetJoint) {
              targetJoint.setHorizontal("left");
            }
        }
      }
    }
    if (viewportDimensions.height >= this.dimensions.height) {
      if (sticksOut[1]) {
        needsRepositioning = true;
        switch (sticksOut[1]) {
          case this.STICKS_OUT_TOP:
            tipJoint.setVertical("top");
            if (this.options.targetJoint) {
              targetJoint.setVertical("bottom");
            }
            break;
          case this.STICKS_OUT_BOTTOM:
            tipJoint.setVertical("bottom");
            if (this.options.targetJoint) {
              targetJoint.setVertical("top");
            }
        }
      }
    }
    if (!needsRepositioning) {
      return originals;
    }
    if (this.options.stem) {
      stem = tipJoint;
    }
    position = this.getPosition(tipJoint, targetJoint, stem);
    newSticksOut = this._sticksOut(position);
    revertedX = false;
    revertedY = false;
    if (newSticksOut[0] && (newSticksOut[0] !== sticksOut[0])) {
      revertedX = true;
      tipJoint.setHorizontal(this.options.tipJoint.horizontal);
      if (this.options.targetJoint) {
        targetJoint.setHorizontal(this.options.targetJoint.horizontal);
      }
    }
    if (newSticksOut[1] && (newSticksOut[1] !== sticksOut[1])) {
      revertedY = true;
      tipJoint.setVertical(this.options.tipJoint.vertical);
      if (this.options.targetJoint) {
        targetJoint.setVertical(this.options.targetJoint.vertical);
      }
    }
    if (revertedX && revertedY) {
      return originals;
    }
    if (revertedX || revertedY) {
      if (this.options.stem) {
        stem = tipJoint;
      }
      position = this.getPosition(tipJoint, targetJoint, stem);
    }
    return {
      position: position,
      stem: stem
    };
  };

  Opentip.prototype._sticksOut = function(position) {
    var positionOffset, scrollOffset, sticksOut, viewportDimensions;
    scrollOffset = this.adapter.scrollOffset();
    viewportDimensions = this.adapter.viewportDimensions();
    positionOffset = [position.left - scrollOffset[0], position.top - scrollOffset[1]];
    sticksOut = [false, false];
    if (positionOffset[0] < 0) {
      sticksOut[0] = this.STICKS_OUT_LEFT;
    } else if (positionOffset[0] + this.dimensions.width > viewportDimensions.width) {
      sticksOut[0] = this.STICKS_OUT_RIGHT;
    }
    if (positionOffset[1] < 0) {
      sticksOut[1] = this.STICKS_OUT_TOP;
    } else if (positionOffset[1] + this.dimensions.height > viewportDimensions.height) {
      sticksOut[1] = this.STICKS_OUT_BOTTOM;
    }
    return sticksOut;
  };

  Opentip.prototype._draw = function() {
    var backgroundCanvas, bulge, canvasDimensions, canvasPosition, closeButton, closeButtonInner, closeButtonOuter, ctx, drawCorner, drawLine, hb, position, stemBase, stemLength, _i, _len, _ref, _ref1, _ref2,
      _this = this;
    if (!(this.backgroundCanvas && this.redraw)) {
      return;
    }
    this.debug("Drawing background.");
    this.redraw = false;
    if (this.currentStem) {
      _ref = ["top", "right", "bottom", "left"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        position = _ref[_i];
        this.adapter.removeClass(this.container, "stem-" + position);
      }
      this.adapter.addClass(this.container, "stem-" + this.currentStem.horizontal);
      this.adapter.addClass(this.container, "stem-" + this.currentStem.vertical);
    }
    closeButtonInner = [0, 0];
    closeButtonOuter = [0, 0];
    if (__indexOf.call(this.options.hideTriggers, "closeButton") >= 0) {
      closeButton = new Opentip.Joint(((_ref1 = this.currentStem) != null ? _ref1.toString() : void 0) === "top right" ? "top left" : "top right");
      closeButtonInner = [this.options.closeButtonRadius + this.options.closeButtonOffset[0], this.options.closeButtonRadius + this.options.closeButtonOffset[1]];
      closeButtonOuter = [this.options.closeButtonRadius - this.options.closeButtonOffset[0], this.options.closeButtonRadius - this.options.closeButtonOffset[1]];
    }
    canvasDimensions = this.adapter.clone(this.dimensions);
    canvasPosition = [0, 0];
    if (this.options.borderWidth) {
      canvasDimensions.width += this.options.borderWidth * 2;
      canvasDimensions.height += this.options.borderWidth * 2;
      canvasPosition[0] -= this.options.borderWidth;
      canvasPosition[1] -= this.options.borderWidth;
    }
    if (this.options.shadow) {
      canvasDimensions.width += this.options.shadowBlur * 2;
      canvasDimensions.width += Math.max(0, this.options.shadowOffset[0] - this.options.shadowBlur * 2);
      canvasDimensions.height += this.options.shadowBlur * 2;
      canvasDimensions.height += Math.max(0, this.options.shadowOffset[1] - this.options.shadowBlur * 2);
      canvasPosition[0] -= Math.max(0, this.options.shadowBlur - this.options.shadowOffset[0]);
      canvasPosition[1] -= Math.max(0, this.options.shadowBlur - this.options.shadowOffset[1]);
    }
    bulge = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    if (this.currentStem) {
      if (this.currentStem.left) {
        bulge.left = this.options.stemLength;
      } else if (this.currentStem.right) {
        bulge.right = this.options.stemLength;
      }
      if (this.currentStem.top) {
        bulge.top = this.options.stemLength;
      } else if (this.currentStem.bottom) {
        bulge.bottom = this.options.stemLength;
      }
    }
    if (closeButton) {
      if (closeButton.left) {
        bulge.left = Math.max(bulge.left, closeButtonOuter[0]);
      } else if (closeButton.right) {
        bulge.right = Math.max(bulge.right, closeButtonOuter[0]);
      }
      if (closeButton.top) {
        bulge.top = Math.max(bulge.top, closeButtonOuter[1]);
      } else if (closeButton.bottom) {
        bulge.bottom = Math.max(bulge.bottom, closeButtonOuter[1]);
      }
    }
    canvasDimensions.width += bulge.left + bulge.right;
    canvasDimensions.height += bulge.top + bulge.bottom;
    canvasPosition[0] -= bulge.left;
    canvasPosition[1] -= bulge.top;
    if (this.currentStem && this.options.borderWidth) {
      _ref2 = this._getPathStemMeasures(this.options.stemBase, this.options.stemLength, this.options.borderWidth), stemLength = _ref2.stemLength, stemBase = _ref2.stemBase;
    }
    backgroundCanvas = this.adapter.unwrap(this.backgroundCanvas);
    backgroundCanvas.width = canvasDimensions.width;
    backgroundCanvas.height = canvasDimensions.height;
    this.adapter.css(this.backgroundCanvas, {
      width: "" + backgroundCanvas.width + "px",
      height: "" + backgroundCanvas.height + "px",
      left: "" + canvasPosition[0] + "px",
      top: "" + canvasPosition[1] + "px"
    });
    ctx = backgroundCanvas.getContext("2d");
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
    ctx.beginPath();
    ctx.fillStyle = this._getColor(ctx, this.dimensions, this.options.background, this.options.backgroundGradientHorizontal);
    ctx.lineJoin = "miter";
    ctx.miterLimit = 500;
    hb = this.options.borderWidth / 2;
    if (this.options.borderWidth) {
      ctx.strokeStyle = this.options.borderColor;
      ctx.lineWidth = this.options.borderWidth;
    } else {
      stemLength = this.options.stemLength;
      stemBase = this.options.stemBase;
    }
    if (stemBase == null) {
      stemBase = 0;
    }
    drawLine = function(length, stem, first) {
      if (first) {
        ctx.moveTo(Math.max(stemBase, _this.options.borderRadius, closeButtonInner[0]) + 1 - hb, -hb);
      }
      if (stem) {
        ctx.lineTo(length / 2 - stemBase / 2, -hb);
        ctx.lineTo(length / 2, -stemLength - hb);
        return ctx.lineTo(length / 2 + stemBase / 2, -hb);
      }
    };
    drawCorner = function(stem, closeButton, i) {
      var angle1, angle2, innerWidth, offset;
      if (stem) {
        ctx.lineTo(-stemBase + hb, 0 - hb);
        ctx.lineTo(stemLength + hb, -stemLength - hb);
        return ctx.lineTo(hb, stemBase - hb);
      } else if (closeButton) {
        offset = _this.options.closeButtonOffset;
        innerWidth = closeButtonInner[0];
        if (i % 2 !== 0) {
          offset = [offset[1], offset[0]];
          innerWidth = closeButtonInner[1];
        }
        angle1 = Math.acos(offset[1] / _this.options.closeButtonRadius);
        angle2 = Math.acos(offset[0] / _this.options.closeButtonRadius);
        ctx.lineTo(-innerWidth + hb, -hb);
        return ctx.arc(hb - offset[0], -hb + offset[1], _this.options.closeButtonRadius, -(Math.PI / 2 + angle1), angle2, false);
      } else {
        ctx.lineTo(-_this.options.borderRadius + hb, -hb);
        return ctx.quadraticCurveTo(hb, -hb, hb, _this.options.borderRadius - hb);
      }
    };
    ctx.translate(-canvasPosition[0], -canvasPosition[1]);
    ctx.save();
    (function() {
      var cornerStem, i, lineLength, lineStem, positionIdx, positionX, positionY, rotation, _j, _ref3, _results;
      _results = [];
      for (i = _j = 0, _ref3 = Opentip.positions.length / 2; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        positionIdx = i * 2;
        positionX = i === 0 || i === 3 ? 0 : _this.dimensions.width;
        positionY = i < 2 ? 0 : _this.dimensions.height;
        rotation = (Math.PI / 2) * i;
        lineLength = i % 2 === 0 ? _this.dimensions.width : _this.dimensions.height;
        lineStem = new Opentip.Joint(Opentip.positions[positionIdx]);
        cornerStem = new Opentip.Joint(Opentip.positions[positionIdx + 1]);
        ctx.save();
        ctx.translate(positionX, positionY);
        ctx.rotate(rotation);
        drawLine(lineLength, lineStem.eql(_this.currentStem), i === 0);
        ctx.translate(lineLength, 0);
        drawCorner(cornerStem.eql(_this.currentStem), cornerStem.eql(closeButton), i);
        _results.push(ctx.restore());
      }
      return _results;
    })();
    ctx.closePath();
    ctx.save();
    if (this.options.shadow) {
      ctx.shadowColor = this.options.shadowColor;
      ctx.shadowBlur = this.options.shadowBlur;
      ctx.shadowOffsetX = this.options.shadowOffset[0];
      ctx.shadowOffsetY = this.options.shadowOffset[1];
    }
    ctx.fill();
    ctx.restore();
    if (this.options.borderWidth) {
      ctx.stroke();
    }
    ctx.restore();
    if (closeButton) {
      return (function() {
        var crossCenter, crossHeight, crossWidth, hcs, linkCenter;
        crossWidth = crossHeight = _this.options.closeButtonRadius * 2;
        if (closeButton.toString() === "top right") {
          linkCenter = [_this.dimensions.width - _this.options.closeButtonOffset[0], _this.options.closeButtonOffset[1]];
          crossCenter = [linkCenter[0] + hb, linkCenter[1] - hb];
        } else {
          linkCenter = [_this.options.closeButtonOffset[0], _this.options.closeButtonOffset[1]];
          crossCenter = [linkCenter[0] - hb, linkCenter[1] - hb];
        }
        ctx.translate(crossCenter[0], crossCenter[1]);
        hcs = _this.options.closeButtonCrossSize / 2;
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = _this.options.closeButtonCrossColor;
        ctx.lineWidth = _this.options.closeButtonCrossLineWidth;
        ctx.lineCap = "round";
        ctx.moveTo(-hcs, -hcs);
        ctx.lineTo(hcs, hcs);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(hcs, -hcs);
        ctx.lineTo(-hcs, hcs);
        ctx.stroke();
        ctx.restore();
        return _this.adapter.css(_this.closeButtonElement, {
          left: "" + (linkCenter[0] - hcs - _this.options.closeButtonLinkOverscan) + "px",
          top: "" + (linkCenter[1] - hcs - _this.options.closeButtonLinkOverscan) + "px",
          width: "" + (_this.options.closeButtonCrossSize + _this.options.closeButtonLinkOverscan * 2) + "px",
          height: "" + (_this.options.closeButtonCrossSize + _this.options.closeButtonLinkOverscan * 2) + "px"
        });
      })();
    }
  };

  Opentip.prototype._getPathStemMeasures = function(outerStemBase, outerStemLength, borderWidth) {
    var angle, distanceBetweenTips, halfAngle, hb, rhombusSide, stemBase, stemLength;
    hb = borderWidth / 2;
    halfAngle = Math.atan((outerStemBase / 2) / outerStemLength);
    angle = halfAngle * 2;
    rhombusSide = hb / Math.sin(angle);
    distanceBetweenTips = 2 * rhombusSide * Math.cos(halfAngle);
    stemLength = hb + outerStemLength - distanceBetweenTips;
    if (stemLength < 0) {
      throw new Error("Sorry but your stemLength / stemBase ratio is strange.");
    }
    stemBase = (Math.tan(halfAngle) * stemLength) * 2;
    return {
      stemLength: stemLength,
      stemBase: stemBase
    };
  };

  Opentip.prototype._getColor = function(ctx, dimensions, color, horizontal) {
    var colorStop, gradient, i, _i, _len;
    if (horizontal == null) {
      horizontal = false;
    }
    if (typeof color === "string") {
      return color;
    }
    if (horizontal) {
      gradient = ctx.createLinearGradient(0, 0, dimensions.width, 0);
    } else {
      gradient = ctx.createLinearGradient(0, 0, 0, dimensions.height);
    }
    for (i = _i = 0, _len = color.length; _i < _len; i = ++_i) {
      colorStop = color[i];
      gradient.addColorStop(colorStop[0], colorStop[1]);
    }
    return gradient;
  };

  Opentip.prototype._searchAndActivateCloseButtons = function() {
    var element, _i, _len, _ref;
    _ref = this.adapter.findAll(this.container, "." + this["class"].close);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      this.hideTriggers.push({
        element: this.adapter.wrap(element),
        event: "click"
      });
    }
    if (this.currentObservers.showing) {
      this._setupObservers("-showing", "showing");
    }
    if (this.currentObservers.visible) {
      return this._setupObservers("-visible", "visible");
    }
  };

  Opentip.prototype._activateFirstInput = function() {
    var input;
    input = this.adapter.unwrap(this.adapter.find(this.container, "input, textarea"));
    return input != null ? typeof input.focus === "function" ? input.focus() : void 0 : void 0;
  };

  Opentip.prototype._followMousePosition = function() {
    if (!this.options.fixed) {
      return Opentip._observeMousePosition(this.bound.reposition);
    }
  };

  Opentip.prototype._stopFollowingMousePosition = function() {
    if (!this.options.fixed) {
      return Opentip._stopObservingMousePosition(this.bound.reposition);
    }
  };

  Opentip.prototype._clearShowTimeout = function() {
    return clearTimeout(this._showTimeoutId);
  };

  Opentip.prototype._clearHideTimeout = function() {
    return clearTimeout(this._hideTimeoutId);
  };

  Opentip.prototype._clearTimeouts = function() {
    clearTimeout(this._visibilityStateTimeoutId);
    this._clearShowTimeout();
    return this._clearHideTimeout();
  };

  Opentip.prototype._triggerElementExists = function() {
    var el;
    el = this.adapter.unwrap(this.triggerElement);
    while (el.parentNode) {
      if (el.parentNode.tagName === "BODY") {
        return true;
      }
      el = el.parentNode;
    }
    return false;
  };

  Opentip.prototype._loadAjax = function() {
    var _this = this;
    if (this.loading) {
      return;
    }
    this.loaded = false;
    this.loading = true;
    this.adapter.addClass(this.container, this["class"].loading);
    this.setContent("");
    this.debug("Loading content from " + this.options.ajax);
    return this.adapter.ajax({
      url: this.options.ajax,
      method: this.options.ajaxMethod,
      onSuccess: function(responseText) {
        _this.debug("Loading successful.");
        _this.adapter.removeClass(_this.container, _this["class"].loading);
        return _this.setContent(responseText);
      },
      onError: function(error) {
        var message;
        message = _this.options.ajaxErrorMessage;
        _this.debug(message, error);
        _this.setContent(message);
        return _this.adapter.addClass(_this.container, _this["class"].ajaxError);
      },
      onComplete: function() {
        _this.adapter.removeClass(_this.container, _this["class"].loading);
        _this.loading = false;
        _this.loaded = true;
        _this._searchAndActivateCloseButtons();
        _this._activateFirstInput();
        return _this.reposition();
      }
    });
  };

  Opentip.prototype._ensureTriggerElement = function() {
    if (!this._triggerElementExists()) {
      this.deactivate();
      return this._stopEnsureTriggerElement();
    }
  };

  Opentip.prototype._ensureTriggerElementInterval = 1000;

  Opentip.prototype._startEnsureTriggerElement = function() {
    var _this = this;
    return this._ensureTriggerElementTimeoutId = setInterval((function() {
      return _this._ensureTriggerElement();
    }), this._ensureTriggerElementInterval);
  };

  Opentip.prototype._stopEnsureTriggerElement = function() {
    return clearInterval(this._ensureTriggerElementTimeoutId);
  };

  return Opentip;

})();

vendors = ["khtml", "ms", "o", "moz", "webkit"];

Opentip.prototype.setCss3Style = function(element, styles) {
  var prop, value, vendor, vendorProp, _results;
  element = this.adapter.unwrap(element);
  _results = [];
  for (prop in styles) {
    if (!__hasProp.call(styles, prop)) continue;
    value = styles[prop];
    if (element.style[prop] != null) {
      _results.push(element.style[prop] = value);
    } else {
      _results.push((function() {
        var _i, _len, _results1;
        _results1 = [];
        for (_i = 0, _len = vendors.length; _i < _len; _i++) {
          vendor = vendors[_i];
          vendorProp = "" + (this.ucfirst(vendor)) + (this.ucfirst(prop));
          if (element.style[vendorProp] != null) {
            _results1.push(element.style[vendorProp] = value);
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      }).call(this));
    }
  }
  return _results;
};

Opentip.prototype.defer = function(func) {
  return setTimeout(func, 0);
};

Opentip.prototype.setTimeout = function(func, seconds) {
  return setTimeout(func, seconds ? seconds * 1000 : 0);
};

Opentip.prototype.ucfirst = function(string) {
  if (string == null) {
    return "";
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
};

Opentip.prototype.dasherize = function(string) {
  return string.replace(/([A-Z])/g, function(_, character) {
    return "-" + (character.toLowerCase());
  });
};

mousePositionObservers = [];

mousePosition = {
  x: 0,
  y: 0
};

mouseMoved = function(e) {
  var observer, _i, _len, _results;
  mousePosition = Opentip.adapter.mousePosition(e);
  _results = [];
  for (_i = 0, _len = mousePositionObservers.length; _i < _len; _i++) {
    observer = mousePositionObservers[_i];
    _results.push(observer());
  }
  return _results;
};

Opentip.followMousePosition = function() {
  return Opentip.adapter.observe(document.body, "mousemove", mouseMoved);
};

Opentip._observeMousePosition = function(observer) {
  return mousePositionObservers.push(observer);
};

Opentip._stopObservingMousePosition = function(removeObserver) {
  var observer;
  return mousePositionObservers = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = mousePositionObservers.length; _i < _len; _i++) {
      observer = mousePositionObservers[_i];
      if (observer !== removeObserver) {
        _results.push(observer);
      }
    }
    return _results;
  })();
};

Opentip.Joint = (function() {

  function Joint(pointerString) {
    if (pointerString == null) {
      return;
    }
    if (pointerString instanceof Opentip.Joint) {
      pointerString = pointerString.toString();
    }
    this.set(pointerString);
    this;

  }

  Joint.prototype.set = function(string) {
    string = string.toLowerCase();
    this.setHorizontal(string);
    this.setVertical(string);
    return this;
  };

  Joint.prototype.setHorizontal = function(string) {
    var i, valid, _i, _j, _len, _len1, _results;
    valid = ["left", "center", "right"];
    for (_i = 0, _len = valid.length; _i < _len; _i++) {
      i = valid[_i];
      if (~string.indexOf(i)) {
        this.horizontal = i.toLowerCase();
      }
    }
    if (this.horizontal == null) {
      this.horizontal = "center";
    }
    _results = [];
    for (_j = 0, _len1 = valid.length; _j < _len1; _j++) {
      i = valid[_j];
      _results.push(this[i] = this.horizontal === i ? i : void 0);
    }
    return _results;
  };

  Joint.prototype.setVertical = function(string) {
    var i, valid, _i, _j, _len, _len1, _results;
    valid = ["top", "middle", "bottom"];
    for (_i = 0, _len = valid.length; _i < _len; _i++) {
      i = valid[_i];
      if (~string.indexOf(i)) {
        this.vertical = i.toLowerCase();
      }
    }
    if (this.vertical == null) {
      this.vertical = "middle";
    }
    _results = [];
    for (_j = 0, _len1 = valid.length; _j < _len1; _j++) {
      i = valid[_j];
      _results.push(this[i] = this.vertical === i ? i : void 0);
    }
    return _results;
  };

  Joint.prototype.eql = function(pointer) {
    return (pointer != null) && this.horizontal === pointer.horizontal && this.vertical === pointer.vertical;
  };

  Joint.prototype.flip = function() {
    var flippedIndex, positionIdx;
    positionIdx = Opentip.position[this.toString(true)];
    flippedIndex = (positionIdx + 4) % 8;
    this.set(Opentip.positions[flippedIndex]);
    return this;
  };

  Joint.prototype.toString = function(camelized) {
    var horizontal, vertical;
    if (camelized == null) {
      camelized = false;
    }
    vertical = this.vertical === "middle" ? "" : this.vertical;
    horizontal = this.horizontal === "center" ? "" : this.horizontal;
    if (vertical && horizontal) {
      if (camelized) {
        horizontal = Opentip.prototype.ucfirst(horizontal);
      } else {
        horizontal = " " + horizontal;
      }
    }
    return "" + vertical + horizontal;
  };

  return Joint;

})();

Opentip.prototype._positionsEqual = function(posA, posB) {
  return (posA != null) && (posB != null) && posA.left === posB.left && posA.top === posB.top;
};

Opentip.prototype._dimensionsEqual = function(dimA, dimB) {
  return (dimA != null) && (dimB != null) && dimA.width === dimB.width && dimA.height === dimB.height;
};

Opentip.prototype.debug = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  if (Opentip.debug && ((typeof console !== "undefined" && console !== null ? console.debug : void 0) != null)) {
    args.unshift("#" + this.id + " |");
    return console.debug.apply(console, args);
  }
};

Opentip.findElements = function() {
  var adapter, content, element, optionName, optionValue, options, _i, _len, _ref, _results;
  adapter = Opentip.adapter;
  _ref = adapter.findAll(document.body, "[data-ot]");
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    element = _ref[_i];
    options = {};
    content = adapter.data(element, "ot");
    if (content === "" || content === "true" || content === "yes") {
      content = adapter.attr(element, "title");
      adapter.attr(element, "title", "");
    }
    content = content || "";
    for (optionName in Opentip.styles.standard) {
      optionValue = adapter.data(element, "ot" + (Opentip.prototype.ucfirst(optionName)));
      if (optionValue != null) {
        if (optionValue === "yes" || optionValue === "true" || optionValue === "on") {
          optionValue = true;
        } else if (optionValue === "no" || optionValue === "false" || optionValue === "off") {
          optionValue = false;
        }
        options[optionName] = optionValue;
      }
    }
    _results.push(new Opentip(element, content, options));
  }
  return _results;
};

Opentip.version = "2.4.6";

Opentip.debug = false;

Opentip.lastId = 0;

Opentip.lastZIndex = 100;

Opentip.tips = [];

Opentip._abortShowingGroup = function(group, originatingOpentip) {
  var opentip, _i, _len, _ref, _results;
  _ref = Opentip.tips;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    opentip = _ref[_i];
    if (opentip !== originatingOpentip && opentip.options.group === group) {
      _results.push(opentip._abortShowing());
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

Opentip._hideGroup = function(group, originatingOpentip) {
  var opentip, _i, _len, _ref, _results;
  _ref = Opentip.tips;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    opentip = _ref[_i];
    if (opentip !== originatingOpentip && opentip.options.group === group) {
      _results.push(opentip.hide());
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

Opentip.adapters = {};

Opentip.adapter = null;

firstAdapter = true;

Opentip.addAdapter = function(adapter) {
  Opentip.adapters[adapter.name] = adapter;
  if (firstAdapter) {
    Opentip.adapter = adapter;
    adapter.domReady(Opentip.findElements);
    adapter.domReady(Opentip.followMousePosition);
    return firstAdapter = false;
  }
};

Opentip.positions = ["top", "topRight", "right", "bottomRight", "bottom", "bottomLeft", "left", "topLeft"];

Opentip.position = {};

_ref = Opentip.positions;
for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
  position = _ref[i];
  Opentip.position[position] = i;
}

Opentip.styles = {
  standard: {
    "extends": null,
    title: void 0,
    escapeTitle: true,
    escapeContent: false,
    className: "standard",
    stem: true,
    delay: null,
    hideDelay: 0.1,
    fixed: false,
    showOn: "mouseover",
    hideTrigger: "trigger",
    hideTriggers: [],
    hideOn: null,
    removeElementsOnHide: false,
    offset: [0, 0],
    containInViewport: true,
    autoOffset: true,
    showEffect: "appear",
    hideEffect: "fade",
    showEffectDuration: 0.3,
    hideEffectDuration: 0.2,
    stemLength: 5,
    stemBase: 8,
    tipJoint: "top left",
    target: null,
    targetJoint: null,
    cache: true,
    ajax: false,
    ajaxMethod: "GET",
    ajaxErrorMessage: "There was a problem downloading the content.",
    group: null,
    style: null,
    background: "#fff18f",
    backgroundGradientHorizontal: false,
    closeButtonOffset: [5, 5],
    closeButtonRadius: 7,
    closeButtonCrossSize: 4,
    closeButtonCrossColor: "#d2c35b",
    closeButtonCrossLineWidth: 1.5,
    closeButtonLinkOverscan: 6,
    borderRadius: 5,
    borderWidth: 1,
    borderColor: "#f2e37b",
    shadow: true,
    shadowBlur: 10,
    shadowOffset: [3, 3],
    shadowColor: "rgba(0, 0, 0, 0.1)"
  },
  glass: {
    "extends": "standard",
    className: "glass",
    background: [[0, "rgba(252, 252, 252, 0.8)"], [0.5, "rgba(255, 255, 255, 0.8)"], [0.5, "rgba(250, 250, 250, 0.9)"], [1, "rgba(245, 245, 245, 0.9)"]],
    borderColor: "#eee",
    closeButtonCrossColor: "rgba(0, 0, 0, 0.2)",
    borderRadius: 15,
    closeButtonRadius: 10,
    closeButtonOffset: [8, 8]
  },
  dark: {
    "extends": "standard",
    className: "dark",
    borderRadius: 13,
    borderColor: "#444",
    closeButtonCrossColor: "rgba(240, 240, 240, 1)",
    shadowColor: "rgba(0, 0, 0, 0.3)",
    shadowOffset: [2, 2],
    background: [[0, "rgba(30, 30, 30, 0.7)"], [0.5, "rgba(30, 30, 30, 0.8)"], [0.5, "rgba(10, 10, 10, 0.8)"], [1, "rgba(10, 10, 10, 0.9)"]]
  },
  alert: {
    "extends": "standard",
    className: "alert",
    borderRadius: 1,
    borderColor: "#AE0D11",
    closeButtonCrossColor: "rgba(255, 255, 255, 1)",
    shadowColor: "rgba(0, 0, 0, 0.3)",
    shadowOffset: [2, 2],
    background: [[0, "rgba(203, 15, 19, 0.7)"], [0.5, "rgba(203, 15, 19, 0.8)"], [0.5, "rgba(189, 14, 18, 0.8)"], [1, "rgba(179, 14, 17, 0.9)"]]
  }
};

Opentip.defaultStyle = "standard";

if (typeof module !== "undefined" && module !== null) {
  module.exports = Opentip;
} else {
  window.Opentip = Opentip;
}


// Generated by CoffeeScript 1.4.0
var __slice = [].slice;

(function($) {
  var Adapter;
  $.fn.opentip = function(content, title, options) {
    return new Opentip(this, content, title, options);
  };
  Adapter = (function() {

    function Adapter() {}

    Adapter.prototype.name = "jquery";

    Adapter.prototype.domReady = function(callback) {
      return $(callback);
    };

    Adapter.prototype.create = function(html) {
      return $(html);
    };

    Adapter.prototype.wrap = function(element) {
      element = $(element);
      if (element.length > 1) {
        throw new Error("Multiple elements provided.");
      }
      return element;
    };

    Adapter.prototype.unwrap = function(element) {
      return $(element)[0];
    };

    Adapter.prototype.tagName = function(element) {
      return this.unwrap(element).tagName;
    };

    Adapter.prototype.attr = function() {
      var args, element, _ref;
      element = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref = $(element)).attr.apply(_ref, args);
    };

    Adapter.prototype.data = function() {
      var args, element, _ref;
      element = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref = $(element)).data.apply(_ref, args);
    };

    Adapter.prototype.find = function(element, selector) {
      return $(element).find(selector).get(0);
    };

    Adapter.prototype.findAll = function(element, selector) {
      return $(element).find(selector);
    };

    Adapter.prototype.update = function(element, content, escape) {
      element = $(element);
      if (escape) {
        return element.text(content);
      } else {
        return element.html(content);
      }
    };

    Adapter.prototype.append = function(element, child) {
      return $(element).append(child);
    };

    Adapter.prototype.remove = function(element) {
      return $(element).remove();
    };

    Adapter.prototype.addClass = function(element, className) {
      return $(element).addClass(className);
    };

    Adapter.prototype.removeClass = function(element, className) {
      return $(element).removeClass(className);
    };

    Adapter.prototype.css = function(element, properties) {
      return $(element).css(properties);
    };

    Adapter.prototype.dimensions = function(element) {
      return {
        width: $(element).outerWidth(),
        height: $(element).outerHeight()
      };
    };

    Adapter.prototype.scrollOffset = function() {
      return [window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft, window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop];
    };

    Adapter.prototype.viewportDimensions = function() {
      return {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight
      };
    };

    Adapter.prototype.mousePosition = function(e) {
      if (e == null) {
        return null;
      }
      return {
        x: e.pageX,
        y: e.pageY
      };
    };

    Adapter.prototype.offset = function(element) {
      var offset;
      offset = $(element).offset();
      return {
        left: offset.left,
        top: offset.top
      };
    };

    Adapter.prototype.observe = function(element, eventName, observer) {
      return $(element).bind(eventName, observer);
    };

    Adapter.prototype.stopObserving = function(element, eventName, observer) {
      return $(element).unbind(eventName, observer);
    };

    Adapter.prototype.ajax = function(options) {
      var _ref, _ref1;
      if (options.url == null) {
        throw new Error("No url provided");
      }
      return $.ajax({
        url: options.url,
        type: (_ref = (_ref1 = options.method) != null ? _ref1.toUpperCase() : void 0) != null ? _ref : "GET"
      }).done(function(content) {
        return typeof options.onSuccess === "function" ? options.onSuccess(content) : void 0;
      }).fail(function(request) {
        return typeof options.onError === "function" ? options.onError("Server responded with status " + request.status) : void 0;
      }).always(function() {
        return typeof options.onComplete === "function" ? options.onComplete() : void 0;
      });
    };

    Adapter.prototype.clone = function(object) {
      return $.extend({}, object);
    };

    Adapter.prototype.extend = function() {
      var sources, target;
      target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return $.extend.apply($, [target].concat(__slice.call(sources)));
    };

    return Adapter;

  })();
  return Opentip.addAdapter(new Adapter);
})(jQuery);


// Modified by Matias Meno to work in IE8.
// I removed the line 312, as proposed by someone on the google forum.

// Copyright 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Known Issues:
//
// * Patterns are not implemented.
// * Radial gradient are not implemented. The VML version of these look very
//   different from the canvas one.
// * Clipping paths are not implemented.
// * Coordsize. The width and height attribute have higher priority than the
//   width and height style values which isn't correct.
// * Painting mode isn't implemented.
// * Canvas width/height should is using content-box by default. IE in
//   Quirks mode will draw the canvas using border-box. Either change your
//   doctype to HTML5
//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype)
//   or use Box Sizing Behavior from WebFX
//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html)
// * Non uniform scaling does not correctly scale strokes.
// * Optimize. There is always room for speed improvements.

// Only add this code if we do not already have a canvas implementation
if (!document.createElement('canvas').getContext) {

(function() {

  // alias some functions to make (compiled) code shorter
  var m = Math;
  var mr = m.round;
  var ms = m.sin;
  var mc = m.cos;
  var abs = m.abs;
  var sqrt = m.sqrt;

  // this is used for sub pixel precision
  var Z = 10;
  var Z2 = Z / 2;

  /**
   * This funtion is assigned to the <canvas> elements as element.getContext().
   * @this {HTMLElement}
   * @return {CanvasRenderingContext2D_}
   */
  function getContext() {
    return this.context_ ||
        (this.context_ = new CanvasRenderingContext2D_(this));
  }

  var slice = Array.prototype.slice;

  /**
   * Binds a function to an object. The returned function will always use the
   * passed in {@code obj} as {@code this}.
   *
   * Example:
   *
   *   g = bind(f, obj, a, b)
   *   g(c, d) // will do f.call(obj, a, b, c, d)
   *
   * @param {Function} f The function to bind the object to
   * @param {Object} obj The object that should act as this when the function
   *     is called
   * @param {*} var_args Rest arguments that will be used as the initial
   *     arguments when the function is called
   * @return {Function} A new function that has bound this
   */
  function bind(f, obj, var_args) {
    var a = slice.call(arguments, 2);
    return function() {
      return f.apply(obj, a.concat(slice.call(arguments)));
    };
  }

  var G_vmlCanvasManager_ = {
    init: function(opt_doc) {
      if (/MSIE/.test(navigator.userAgent) && !window.opera) {
        var doc = opt_doc || document;
        // Create a dummy element so that IE will allow canvas elements to be
        // recognized.
        doc.createElement('canvas');
        doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
      }
    },

    init_: function(doc) {
      // create xmlns
      if (!doc.namespaces['g_vml_']) {
        doc.namespaces.add('g_vml_', 'urn:schemas-microsoft-com:vml',
                           '#default#VML');

      }
      if (!doc.namespaces['g_o_']) {
        doc.namespaces.add('g_o_', 'urn:schemas-microsoft-com:office:office',
                           '#default#VML');
      }

      // Setup default CSS.  Only add one style sheet per document
      if (!doc.styleSheets['ex_canvas_']) {
        var ss = doc.createStyleSheet();
        ss.owningElement.id = 'ex_canvas_';
        ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +
            // default size is 300x150 in Gecko and Opera
            'text-align:left;width:300px;height:150px}' +
            'g_vml_\\:*{behavior:url(#default#VML)}' +
            'g_o_\\:*{behavior:url(#default#VML)}';

      }

      // find all canvas elements
      var els = doc.getElementsByTagName('canvas');
      for (var i = 0; i < els.length; i++) {
        this.initElement(els[i]);
      }
    },

    /**
     * Public initializes a canvas element so that it can be used as canvas
     * element from now on. This is called automatically before the page is
     * loaded but if you are creating elements using createElement you need to
     * make sure this is called on the element.
     * @param {HTMLElement} el The canvas element to initialize.
     * @return {HTMLElement} the element that was created.
     */
    initElement: function(el) {
      if (!el.getContext) {

        el.getContext = getContext;

        // Remove fallback content. There is no way to hide text nodes so we
        // just remove all childNodes. We could hide all elements and remove
        // text nodes but who really cares about the fallback content.
        el.innerHTML = '';

        // do not use inline function because that will leak memory
        el.attachEvent('onpropertychange', onPropertyChange);
        el.attachEvent('onresize', onResize);

        var attrs = el.attributes;
        if (attrs.width && attrs.width.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setWidth_(attrs.width.nodeValue);
          el.style.width = attrs.width.nodeValue + 'px';
        } else {
          el.width = el.clientWidth;
        }
        if (attrs.height && attrs.height.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setHeight_(attrs.height.nodeValue);
          el.style.height = attrs.height.nodeValue + 'px';
        } else {
          el.height = el.clientHeight;
        }
        //el.getContext().setCoordsize_()
      }
      return el;
    }
  };

  function onPropertyChange(e) {
    var el = e.srcElement;

    switch (e.propertyName) {
      case 'width':
        el.style.width = el.attributes.width.nodeValue + 'px';
        el.getContext().clearRect();
        break;
      case 'height':
        el.style.height = el.attributes.height.nodeValue + 'px';
        el.getContext().clearRect();
        break;
    }
  }

  function onResize(e) {
    var el = e.srcElement;
    if (el.firstChild) {
      el.firstChild.style.width =  el.clientWidth + 'px';
      el.firstChild.style.height = el.clientHeight + 'px';
    }
  }

  G_vmlCanvasManager_.init();

  // precompute "00" to "FF"
  var dec2hex = [];
  for (var i = 0; i < 16; i++) {
    for (var j = 0; j < 16; j++) {
      dec2hex[i * 16 + j] = i.toString(16) + j.toString(16);
    }
  }

  function createMatrixIdentity() {
    return [
      [1, 0, 0],
      [0, 1, 0],
      [0, 0, 1]
    ];
  }

  function matrixMultiply(m1, m2) {
    var result = createMatrixIdentity();

    for (var x = 0; x < 3; x++) {
      for (var y = 0; y < 3; y++) {
        var sum = 0;

        for (var z = 0; z < 3; z++) {
          sum += m1[x][z] * m2[z][y];
        }

        result[x][y] = sum;
      }
    }
    return result;
  }

  function copyState(o1, o2) {
    o2.fillStyle     = o1.fillStyle;
    o2.lineCap       = o1.lineCap;
    o2.lineJoin      = o1.lineJoin;
    o2.lineWidth     = o1.lineWidth;
    o2.miterLimit    = o1.miterLimit;
    o2.shadowBlur    = o1.shadowBlur;
    o2.shadowColor   = o1.shadowColor;
    o2.shadowOffsetX = o1.shadowOffsetX;
    o2.shadowOffsetY = o1.shadowOffsetY;
    o2.strokeStyle   = o1.strokeStyle;
    o2.globalAlpha   = o1.globalAlpha;
    o2.arcScaleX_    = o1.arcScaleX_;
    o2.arcScaleY_    = o1.arcScaleY_;
    o2.lineScale_    = o1.lineScale_;
  }

  function processStyle(styleString) {
    var str, alpha = 1;

    styleString = String(styleString);
    if (styleString.substring(0, 3) == 'rgb') {
      var start = styleString.indexOf('(', 3);
      var end = styleString.indexOf(')', start + 1);
      var guts = styleString.substring(start + 1, end).split(',');

      str = '#';
      for (var i = 0; i < 3; i++) {
        str += dec2hex[Number(guts[i])];
      }

      if (guts.length == 4 && styleString.substr(3, 1) == 'a') {
        alpha = guts[3];
      }
    } else {
      str = styleString;
    }

    return {color: str, alpha: alpha};
  }

  function processLineCap(lineCap) {
    switch (lineCap) {
      case 'butt':
        return 'flat';
      case 'round':
        return 'round';
      case 'square':
      default:
        return 'square';
    }
  }

  /**
   * This class implements CanvasRenderingContext2D interface as described by
   * the WHATWG.
   * @param {HTMLElement} surfaceElement The element that the 2D context should
   * be associated with
   */
  function CanvasRenderingContext2D_(surfaceElement) {
    this.m_ = createMatrixIdentity();

    this.mStack_ = [];
    this.aStack_ = [];
    this.currentPath_ = [];

    // Canvas context properties
    this.strokeStyle = '#000';
    this.fillStyle = '#000';

    this.lineWidth = 1;
    this.lineJoin = 'miter';
    this.lineCap = 'butt';
    this.miterLimit = Z * 1;
    this.globalAlpha = 1;
    this.canvas = surfaceElement;

    var el = surfaceElement.ownerDocument.createElement('div');
    el.style.width =  surfaceElement.clientWidth + 'px';
    el.style.height = surfaceElement.clientHeight + 'px';
    // el.style.overflow = 'hidden';
    el.style.position = 'absolute';
    surfaceElement.appendChild(el);

    this.element_ = el;
    this.arcScaleX_ = 1;
    this.arcScaleY_ = 1;
    this.lineScale_ = 1;
  }

  var contextPrototype = CanvasRenderingContext2D_.prototype;
  contextPrototype.clearRect = function() {
    this.element_.innerHTML = '';
  };

  contextPrototype.beginPath = function() {
    // TODO: Branch current matrix so that save/restore has no effect
    //       as per safari docs.
    this.currentPath_ = [];
  };

  contextPrototype.moveTo = function(aX, aY) {
    var p = this.getCoords_(aX, aY);
    this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});
    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.lineTo = function(aX, aY) {
    var p = this.getCoords_(aX, aY);
    this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});

    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                                            aCP2x, aCP2y,
                                            aX, aY) {
    var p = this.getCoords_(aX, aY);
    var cp1 = this.getCoords_(aCP1x, aCP1y);
    var cp2 = this.getCoords_(aCP2x, aCP2y);
    bezierCurveTo(this, cp1, cp2, p);
  };

  // Helper function that takes the already fixed cordinates.
  function bezierCurveTo(self, cp1, cp2, p) {
    self.currentPath_.push({
      type: 'bezierCurveTo',
      cp1x: cp1.x,
      cp1y: cp1.y,
      cp2x: cp2.x,
      cp2y: cp2.y,
      x: p.x,
      y: p.y
    });
    self.currentX_ = p.x;
    self.currentY_ = p.y;
  }

  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
    // the following is lifted almost directly from
    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

    var cp = this.getCoords_(aCPx, aCPy);
    var p = this.getCoords_(aX, aY);

    var cp1 = {
      x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
      y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
    };
    var cp2 = {
      x: cp1.x + (p.x - this.currentX_) / 3.0,
      y: cp1.y + (p.y - this.currentY_) / 3.0
    };

    bezierCurveTo(this, cp1, cp2, p);
  };

  contextPrototype.arc = function(aX, aY, aRadius,
                                  aStartAngle, aEndAngle, aClockwise) {
    aRadius *= Z;
    var arcType = aClockwise ? 'at' : 'wa';

    var xStart = aX + mc(aStartAngle) * aRadius - Z2;
    var yStart = aY + ms(aStartAngle) * aRadius - Z2;

    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

    // IE won't render arches drawn counter clockwise if xStart == xEnd.
    if (xStart == xEnd && !aClockwise) {
      xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                       // that can be represented in binary
    }

    var p = this.getCoords_(aX, aY);
    var pStart = this.getCoords_(xStart, yStart);
    var pEnd = this.getCoords_(xEnd, yEnd);

    this.currentPath_.push({type: arcType,
                           x: p.x,
                           y: p.y,
                           radius: aRadius,
                           xStart: pStart.x,
                           yStart: pStart.y,
                           xEnd: pEnd.x,
                           yEnd: pEnd.y});

  };

  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
  };

  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.stroke();

    this.currentPath_ = oldPath;
  };

  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.fill();

    this.currentPath_ = oldPath;
  };

  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
    var gradient = new CanvasGradient_('gradient');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    return gradient;
  };

  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                                                   aX1, aY1, aR1) {
    var gradient = new CanvasGradient_('gradientradial');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.r0_ = aR0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    gradient.r1_ = aR1;
    return gradient;
  };

  contextPrototype.drawImage = function(image, var_args) {
    var dx, dy, dw, dh, sx, sy, sw, sh;

    // to find the original width we overide the width and height
    var oldRuntimeWidth = image.runtimeStyle.width;
    var oldRuntimeHeight = image.runtimeStyle.height;
    image.runtimeStyle.width = 'auto';
    image.runtimeStyle.height = 'auto';

    // get the original size
    var w = image.width;
    var h = image.height;

    // and remove overides
    image.runtimeStyle.width = oldRuntimeWidth;
    image.runtimeStyle.height = oldRuntimeHeight;

    if (arguments.length == 3) {
      dx = arguments[1];
      dy = arguments[2];
      sx = sy = 0;
      sw = dw = w;
      sh = dh = h;
    } else if (arguments.length == 5) {
      dx = arguments[1];
      dy = arguments[2];
      dw = arguments[3];
      dh = arguments[4];
      sx = sy = 0;
      sw = w;
      sh = h;
    } else if (arguments.length == 9) {
      sx = arguments[1];
      sy = arguments[2];
      sw = arguments[3];
      sh = arguments[4];
      dx = arguments[5];
      dy = arguments[6];
      dw = arguments[7];
      dh = arguments[8];
    } else {
      throw Error('Invalid number of arguments');
    }

    var d = this.getCoords_(dx, dy);

    var w2 = sw / 2;
    var h2 = sh / 2;

    var vmlStr = [];

    var W = 10;
    var H = 10;

    // For some reason that I've now forgotten, using divs didn't work
    vmlStr.push(' <g_vml_:group',
                ' coordsize="', Z * W, ',', Z * H, '"',
                ' coordorigin="0,0"' ,
                ' style="width:', W, 'px;height:', H, 'px;position:absolute;');

    // If filters are necessary (rotation exists), create them
    // filters are bog-slow, so only create them if abbsolutely necessary
    // The following check doesn't account for skews (which don't exist
    // in the canvas spec (yet) anyway.

    if (this.m_[0][0] != 1 || this.m_[0][1]) {
      var filter = [];

      // Note the 12/21 reversal
      filter.push('M11=', this.m_[0][0], ',',
                  'M12=', this.m_[1][0], ',',
                  'M21=', this.m_[0][1], ',',
                  'M22=', this.m_[1][1], ',',
                  'Dx=', mr(d.x / Z), ',',
                  'Dy=', mr(d.y / Z), '');

      // Bounding box calculation (need to minimize displayed area so that
      // filters don't waste time on unused pixels.
      var max = d;
      var c2 = this.getCoords_(dx + dw, dy);
      var c3 = this.getCoords_(dx, dy + dh);
      var c4 = this.getCoords_(dx + dw, dy + dh);

      max.x = m.max(max.x, c2.x, c3.x, c4.x);
      max.y = m.max(max.y, c2.y, c3.y, c4.y);

      vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
                  'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',
                  filter.join(''), ", sizingmethod='clip');")
    } else {
      vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
    }

    vmlStr.push(' ">' ,
                '<g_vml_:image src="', image.src, '"',
                ' style="width:', Z * dw, 'px;',
                ' height:', Z * dh, 'px;"',
                ' cropleft="', sx / w, '"',
                ' croptop="', sy / h, '"',
                ' cropright="', (w - sx - sw) / w, '"',
                ' cropbottom="', (h - sy - sh) / h, '"',
                ' />',
                '</g_vml_:group>');

    this.element_.insertAdjacentHTML('BeforeEnd',
                                    vmlStr.join(''));
  };

  contextPrototype.stroke = function(aFill) {
    var lineStr = [];
    var lineOpen = false;
    var a = processStyle(aFill ? this.fillStyle : this.strokeStyle);
    var color = a.color;
    var opacity = a.alpha * this.globalAlpha;

    var W = 10;
    var H = 10;

    lineStr.push('<g_vml_:shape',
                 ' filled="', !!aFill, '"',
                 ' style="position:absolute;width:', W, 'px;height:', H, 'px;"',
                 ' coordorigin="0 0" coordsize="', Z * W, ' ', Z * H, '"',
                 ' stroked="', !aFill, '"',
                 ' path="');

    var newSeq = false;
    var min = {x: null, y: null};
    var max = {x: null, y: null};

    for (var i = 0; i < this.currentPath_.length; i++) {
      var p = this.currentPath_[i];
      var c;

      switch (p.type) {
        case 'moveTo':
          c = p;
          lineStr.push(' m ', mr(p.x), ',', mr(p.y));
          break;
        case 'lineTo':
          lineStr.push(' l ', mr(p.x), ',', mr(p.y));
          break;
        case 'close':
          lineStr.push(' x ');
          p = null;
          break;
        case 'bezierCurveTo':
          lineStr.push(' c ',
                       mr(p.cp1x), ',', mr(p.cp1y), ',',
                       mr(p.cp2x), ',', mr(p.cp2y), ',',
                       mr(p.x), ',', mr(p.y));
          break;
        case 'at':
        case 'wa':
          lineStr.push(' ', p.type, ' ',
                       mr(p.x - this.arcScaleX_ * p.radius), ',',
                       mr(p.y - this.arcScaleY_ * p.radius), ' ',
                       mr(p.x + this.arcScaleX_ * p.radius), ',',
                       mr(p.y + this.arcScaleY_ * p.radius), ' ',
                       mr(p.xStart), ',', mr(p.yStart), ' ',
                       mr(p.xEnd), ',', mr(p.yEnd));
          break;
      }


      // TODO: Following is broken for curves due to
      //       move to proper paths.

      // Figure out dimensions so we can do gradient fills
      // properly
      if (p) {
        if (min.x == null || p.x < min.x) {
          min.x = p.x;
        }
        if (max.x == null || p.x > max.x) {
          max.x = p.x;
        }
        if (min.y == null || p.y < min.y) {
          min.y = p.y;
        }
        if (max.y == null || p.y > max.y) {
          max.y = p.y;
        }
      }
    }
    lineStr.push(' ">');

    if (!aFill) {
      var lineWidth = this.lineScale_ * this.lineWidth;

      // VML cannot correctly render a line if the width is less than 1px.
      // In that case, we dilute the color to make the line look thinner.
      if (lineWidth < 1) {
        opacity *= lineWidth;
      }

      lineStr.push(
        '<g_vml_:stroke',
        ' opacity="', opacity, '"',
        ' joinstyle="', this.lineJoin, '"',
        ' miterlimit="', this.miterLimit, '"',
        ' endcap="', processLineCap(this.lineCap), '"',
        ' weight="', lineWidth, 'px"',
        ' color="', color, '" />'
      );
    } else if (typeof this.fillStyle == 'object') {
      var fillStyle = this.fillStyle;
      var angle = 0;
      var focus = {x: 0, y: 0};

      // additional offset
      var shift = 0;
      // scale factor for offset
      var expansion = 1;

      if (fillStyle.type_ == 'gradient') {
        var x0 = fillStyle.x0_ / this.arcScaleX_;
        var y0 = fillStyle.y0_ / this.arcScaleY_;
        var x1 = fillStyle.x1_ / this.arcScaleX_;
        var y1 = fillStyle.y1_ / this.arcScaleY_;
        var p0 = this.getCoords_(x0, y0);
        var p1 = this.getCoords_(x1, y1);
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;
        angle = Math.atan2(dx, dy) * 180 / Math.PI;

        // The angle should be a non-negative number.
        if (angle < 0) {
          angle += 360;
        }

        // Very small angles produce an unexpected result because they are
        // converted to a scientific notation string.
        if (angle < 1e-6) {
          angle = 0;
        }
      } else {
        var p0 = this.getCoords_(fillStyle.x0_, fillStyle.y0_);
        var width  = max.x - min.x;
        var height = max.y - min.y;
        focus = {
          x: (p0.x - min.x) / width,
          y: (p0.y - min.y) / height
        };

        width  /= this.arcScaleX_ * Z;
        height /= this.arcScaleY_ * Z;
        var dimension = m.max(width, height);
        shift = 2 * fillStyle.r0_ / dimension;
        expansion = 2 * fillStyle.r1_ / dimension - shift;
      }

      // We need to sort the color stops in ascending order by offset,
      // otherwise IE won't interpret it correctly.
      var stops = fillStyle.colors_;
      stops.sort(function(cs1, cs2) {
        return cs1.offset - cs2.offset;
      });

      var length = stops.length;
      var color1 = stops[0].color;
      var color2 = stops[length - 1].color;
      var opacity1 = stops[0].alpha * this.globalAlpha;
      var opacity2 = stops[length - 1].alpha * this.globalAlpha;

      var colors = [];
      for (var i = 0; i < length; i++) {
        var stop = stops[i];
        colors.push(stop.offset * expansion + shift + ' ' + stop.color);
      }

      // When colors attribute is used, the meanings of opacity and o:opacity2
      // are reversed.
      lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"',
                   ' method="none" focus="100%"',
                   ' color="', color1, '"',
                   ' color2="', color2, '"',
                   ' colors="', colors.join(','), '"',
                   ' opacity="', opacity2, '"',
                   ' g_o_:opacity2="', opacity1, '"',
                   ' angle="', angle, '"',
                   ' focusposition="', focus.x, ',', focus.y, '" />');
    } else {
      lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity,
                   '" />');
    }

    lineStr.push('</g_vml_:shape>');

    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
  };

  contextPrototype.fill = function() {
    this.stroke(true);
  }

  contextPrototype.closePath = function() {
    this.currentPath_.push({type: 'close'});
  };

  /**
   * @private
   */
  contextPrototype.getCoords_ = function(aX, aY) {
    var m = this.m_;
    return {
      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
    }
  };

  contextPrototype.save = function() {
    var o = {};
    copyState(this, o);
    this.aStack_.push(o);
    this.mStack_.push(this.m_);
    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
  };

  contextPrototype.restore = function() {
    copyState(this.aStack_.pop(), this);
    this.m_ = this.mStack_.pop();
  };

  function matrixIsFinite(m) {
    for (var j = 0; j < 3; j++) {
      for (var k = 0; k < 2; k++) {
        if (!isFinite(m[j][k]) || isNaN(m[j][k])) {
          return false;
        }
      }
    }
    return true;
  }

  function setM(ctx, m, updateLineScale) {
    if (!matrixIsFinite(m)) {
      return;
    }
    ctx.m_ = m;

    if (updateLineScale) {
      // Get the line scale.
      // Determinant of this.m_ means how much the area is enlarged by the
      // transformation. So its square root can be used as a scale factor
      // for width.
      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
      ctx.lineScale_ = sqrt(abs(det));
    }
  }

  contextPrototype.translate = function(aX, aY) {
    var m1 = [
      [1,  0,  0],
      [0,  1,  0],
      [aX, aY, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.rotate = function(aRot) {
    var c = mc(aRot);
    var s = ms(aRot);

    var m1 = [
      [c,  s, 0],
      [-s, c, 0],
      [0,  0, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.scale = function(aX, aY) {
    this.arcScaleX_ *= aX;
    this.arcScaleY_ *= aY;
    var m1 = [
      [aX, 0,  0],
      [0,  aY, 0],
      [0,  0,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
    var m1 = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
    var m = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, m, true);
  };

  /******** STUBS ********/
  contextPrototype.clip = function() {
    // TODO: Implement
  };

  contextPrototype.arcTo = function() {
    // TODO: Implement
  };

  contextPrototype.createPattern = function() {
    return new CanvasPattern_;
  };

  // Gradient / Pattern Stubs
  function CanvasGradient_(aType) {
    this.type_ = aType;
    this.x0_ = 0;
    this.y0_ = 0;
    this.r0_ = 0;
    this.x1_ = 0;
    this.y1_ = 0;
    this.r1_ = 0;
    this.colors_ = [];
  }

  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
    aColor = processStyle(aColor);
    this.colors_.push({offset: aOffset,
                       color: aColor.color,
                       alpha: aColor.alpha});
  };

  function CanvasPattern_() {}

  // set up externs
  G_vmlCanvasManager = G_vmlCanvasManager_;
  CanvasRenderingContext2D = CanvasRenderingContext2D_;
  CanvasGradient = CanvasGradient_;
  CanvasPattern = CanvasPattern_;

})();

} // if
},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9tb2R1bGVzL29wZW50aXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNC4wXG4vKlxuI1xuIyBPcGVudGlwIHYyLjQuNlxuI1xuIyBNb3JlIGluZm8gYXQgW3d3dy5vcGVudGlwLm9yZ10oaHR0cDovL3d3dy5vcGVudGlwLm9yZylcbiMgXG4jIENvcHlyaWdodCAoYykgMjAxMiwgTWF0aWFzIE1lbm8gIFxuIyBHcmFwaGljcyBieSBUamFuZHJhIE1heWVyaG9sZFxuIyBcbiMgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4jIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuIyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiMgXG4jIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4jIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuIyBcbiMgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiMgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4jIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiMgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiMgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuIyBUSEUgU09GVFdBUkUuXG4jXG4qL1xuXG52YXIgT3BlbnRpcCwgZmlyc3RBZGFwdGVyLCBpLCBtb3VzZU1vdmVkLCBtb3VzZVBvc2l0aW9uLCBtb3VzZVBvc2l0aW9uT2JzZXJ2ZXJzLCBwb3NpdGlvbiwgdmVuZG9ycywgX2ksIF9sZW4sIF9yZWYsXG4gIF9fc2xpY2UgPSBbXS5zbGljZSxcbiAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH0sXG4gIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5PcGVudGlwID0gKGZ1bmN0aW9uKCkge1xuXG4gIE9wZW50aXAucHJvdG90eXBlLlNUSUNLU19PVVRfVE9QID0gMTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5TVElDS1NfT1VUX0JPVFRPTSA9IDI7XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuU1RJQ0tTX09VVF9MRUZUID0gMTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5TVElDS1NfT1VUX1JJR0hUID0gMjtcblxuICBPcGVudGlwLnByb3RvdHlwZVtcImNsYXNzXCJdID0ge1xuICAgIGNvbnRhaW5lcjogXCJvcGVudGlwLWNvbnRhaW5lclwiLFxuICAgIG9wZW50aXA6IFwib3BlbnRpcFwiLFxuICAgIGhlYWRlcjogXCJvdC1oZWFkZXJcIixcbiAgICBjb250ZW50OiBcIm90LWNvbnRlbnRcIixcbiAgICBsb2FkaW5nSW5kaWNhdG9yOiBcIm90LWxvYWRpbmctaW5kaWNhdG9yXCIsXG4gICAgY2xvc2U6IFwib3QtY2xvc2VcIixcbiAgICBnb2luZ1RvSGlkZTogXCJvdC1nb2luZy10by1oaWRlXCIsXG4gICAgaGlkZGVuOiBcIm90LWhpZGRlblwiLFxuICAgIGhpZGluZzogXCJvdC1oaWRpbmdcIixcbiAgICBnb2luZ1RvU2hvdzogXCJvdC1nb2luZy10by1zaG93XCIsXG4gICAgc2hvd2luZzogXCJvdC1zaG93aW5nXCIsXG4gICAgdmlzaWJsZTogXCJvdC12aXNpYmxlXCIsXG4gICAgbG9hZGluZzogXCJvdC1sb2FkaW5nXCIsXG4gICAgYWpheEVycm9yOiBcIm90LWFqYXgtZXJyb3JcIixcbiAgICBmaXhlZDogXCJvdC1maXhlZFwiLFxuICAgIHNob3dFZmZlY3RQcmVmaXg6IFwib3Qtc2hvdy1lZmZlY3QtXCIsXG4gICAgaGlkZUVmZmVjdFByZWZpeDogXCJvdC1oaWRlLWVmZmVjdC1cIixcbiAgICBzdHlsZVByZWZpeDogXCJzdHlsZS1cIlxuICB9O1xuXG4gIGZ1bmN0aW9uIE9wZW50aXAoZWxlbWVudCwgY29udGVudCwgdGl0bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZWxlbWVudHNPcGVudGlwcywgaGlkZVRyaWdnZXIsIG1ldGhvZFRvQmluZCwgb3B0aW9uU291cmNlcywgcHJvcCwgc3R5bGVOYW1lLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLCBfcmVmMSwgX3JlZjIsIF90bXBTdHlsZSxcbiAgICAgIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmlkID0gKytPcGVudGlwLmxhc3RJZDtcbiAgICB0aGlzLmRlYnVnKFwiQ3JlYXRpbmcgT3BlbnRpcC5cIik7XG4gICAgT3BlbnRpcC50aXBzLnB1c2godGhpcyk7XG4gICAgdGhpcy5hZGFwdGVyID0gT3BlbnRpcC5hZGFwdGVyO1xuICAgIGVsZW1lbnRzT3BlbnRpcHMgPSB0aGlzLmFkYXB0ZXIuZGF0YShlbGVtZW50LCBcIm9wZW50aXBzXCIpIHx8IFtdO1xuICAgIGVsZW1lbnRzT3BlbnRpcHMucHVzaCh0aGlzKTtcbiAgICB0aGlzLmFkYXB0ZXIuZGF0YShlbGVtZW50LCBcIm9wZW50aXBzXCIsIGVsZW1lbnRzT3BlbnRpcHMpO1xuICAgIHRoaXMudHJpZ2dlckVsZW1lbnQgPSB0aGlzLmFkYXB0ZXIud3JhcChlbGVtZW50KTtcbiAgICBpZiAodGhpcy50cmlnZ2VyRWxlbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuJ3QgY2FsbCBPcGVudGlwIG9uIG11bHRpcGxlIGVsZW1lbnRzLlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJpZ2dlckVsZW1lbnQubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbGVtZW50LlwiKTtcbiAgICB9XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLndhaXRpbmdUb1Nob3cgPSBmYWxzZTtcbiAgICB0aGlzLndhaXRpbmdUb0hpZGUgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbiA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHtcbiAgICAgIHdpZHRoOiAxMDAsXG4gICAgICBoZWlnaHQ6IDUwXG4gICAgfTtcbiAgICB0aGlzLmNvbnRlbnQgPSBcIlwiO1xuICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRPYnNlcnZlcnMgPSB7XG4gICAgICBzaG93aW5nOiBmYWxzZSxcbiAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgaGlkaW5nOiBmYWxzZSxcbiAgICAgIGhpZGRlbjogZmFsc2VcbiAgICB9O1xuICAgIG9wdGlvbnMgPSB0aGlzLmFkYXB0ZXIuY2xvbmUob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBvcHRpb25zID0gY29udGVudDtcbiAgICAgIGNvbnRlbnQgPSB0aXRsZSA9IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aXRsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgb3B0aW9ucyA9IHRpdGxlO1xuICAgICAgdGl0bGUgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aXRsZSAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLnRpdGxlID0gdGl0bGU7XG4gICAgfVxuICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuc2V0Q29udGVudChjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbXCJleHRlbmRzXCJdID09IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9uc1tcImV4dGVuZHNcIl0gPSBvcHRpb25zLnN0eWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uc1tcImV4dGVuZHNcIl0gPSBPcGVudGlwLmRlZmF1bHRTdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3B0aW9uU291cmNlcyA9IFtvcHRpb25zXTtcbiAgICBfdG1wU3R5bGUgPSBvcHRpb25zO1xuICAgIHdoaWxlIChfdG1wU3R5bGVbXCJleHRlbmRzXCJdKSB7XG4gICAgICBzdHlsZU5hbWUgPSBfdG1wU3R5bGVbXCJleHRlbmRzXCJdO1xuICAgICAgX3RtcFN0eWxlID0gT3BlbnRpcC5zdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChfdG1wU3R5bGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0eWxlOiBcIiArIHN0eWxlTmFtZSk7XG4gICAgICB9XG4gICAgICBvcHRpb25Tb3VyY2VzLnVuc2hpZnQoX3RtcFN0eWxlKTtcbiAgICAgIGlmICghKChfdG1wU3R5bGVbXCJleHRlbmRzXCJdICE9IG51bGwpIHx8IHN0eWxlTmFtZSA9PT0gXCJzdGFuZGFyZFwiKSkge1xuICAgICAgICBfdG1wU3R5bGVbXCJleHRlbmRzXCJdID0gXCJzdGFuZGFyZFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zID0gKF9yZWYgPSB0aGlzLmFkYXB0ZXIpLmV4dGVuZC5hcHBseShfcmVmLCBbe31dLmNvbmNhdChfX3NsaWNlLmNhbGwob3B0aW9uU291cmNlcykpKTtcbiAgICBvcHRpb25zLmhpZGVUcmlnZ2VycyA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgX3JlZjEgPSBvcHRpb25zLmhpZGVUcmlnZ2VycztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGhpZGVUcmlnZ2VyID0gX3JlZjFbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGhpZGVUcmlnZ2VyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpO1xuICAgIGlmIChvcHRpb25zLmhpZGVUcmlnZ2VyICYmIG9wdGlvbnMuaGlkZVRyaWdnZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb3B0aW9ucy5oaWRlVHJpZ2dlcnMucHVzaChvcHRpb25zLmhpZGVUcmlnZ2VyKTtcbiAgICB9XG4gICAgX3JlZjEgPSBbXCJ0aXBKb2ludFwiLCBcInRhcmdldEpvaW50XCIsIFwic3RlbVwiXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBwcm9wID0gX3JlZjFbX2ldO1xuICAgICAgaWYgKG9wdGlvbnNbcHJvcF0gJiYgdHlwZW9mIG9wdGlvbnNbcHJvcF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3B0aW9uc1twcm9wXSA9IG5ldyBPcGVudGlwLkpvaW50KG9wdGlvbnNbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hamF4ICYmIChvcHRpb25zLmFqYXggPT09IHRydWUgfHwgIW9wdGlvbnMuYWpheCkpIHtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXIudGFnTmFtZSh0aGlzLnRyaWdnZXJFbGVtZW50KSA9PT0gXCJBXCIpIHtcbiAgICAgICAgb3B0aW9ucy5hamF4ID0gdGhpcy5hZGFwdGVyLmF0dHIodGhpcy50cmlnZ2VyRWxlbWVudCwgXCJocmVmXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5hamF4ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNob3dPbiA9PT0gXCJjbGlja1wiICYmIHRoaXMuYWRhcHRlci50YWdOYW1lKHRoaXMudHJpZ2dlckVsZW1lbnQpID09PSBcIkFcIikge1xuICAgICAgdGhpcy5hZGFwdGVyLm9ic2VydmUodGhpcy50cmlnZ2VyRWxlbWVudCwgXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGUuc3RvcHBlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICBvcHRpb25zLmZpeGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RlbSA9PT0gdHJ1ZSkge1xuICAgICAgb3B0aW9ucy5zdGVtID0gbmV3IE9wZW50aXAuSm9pbnQob3B0aW9ucy50aXBKb2ludCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRhcmdldCA9PT0gdHJ1ZSkge1xuICAgICAgb3B0aW9ucy50YXJnZXQgPSB0aGlzLnRyaWdnZXJFbGVtZW50O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0ID0gdGhpcy5hZGFwdGVyLndyYXAob3B0aW9ucy50YXJnZXQpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRTdGVtID0gb3B0aW9ucy5zdGVtO1xuICAgIGlmIChvcHRpb25zLmRlbGF5ID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLnNob3dPbiA9PT0gXCJtb3VzZW92ZXJcIiA/IDAuMiA6IDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRhcmdldEpvaW50ID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0Sm9pbnQgPSBuZXcgT3BlbnRpcC5Kb2ludChvcHRpb25zLnRpcEpvaW50KS5mbGlwKCk7XG4gICAgfVxuICAgIHRoaXMuc2hvd1RyaWdnZXJzID0gW107XG4gICAgdGhpcy5zaG93VHJpZ2dlcnNXaGVuVmlzaWJsZSA9IFtdO1xuICAgIHRoaXMuaGlkZVRyaWdnZXJzID0gW107XG4gICAgaWYgKG9wdGlvbnMuc2hvd09uICYmIG9wdGlvbnMuc2hvd09uICE9PSBcImNyZWF0aW9uXCIpIHtcbiAgICAgIHRoaXMuc2hvd1RyaWdnZXJzLnB1c2goe1xuICAgICAgICBlbGVtZW50OiB0aGlzLnRyaWdnZXJFbGVtZW50LFxuICAgICAgICBldmVudDogb3B0aW9ucy5zaG93T25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hamF4Q2FjaGUgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5jYWNoZSA9IG9wdGlvbnMuYWpheENhY2hlO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYWpheENhY2hlO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuYm91bmQgPSB7fTtcbiAgICBfcmVmMiA9IFtcInByZXBhcmVUb1Nob3dcIiwgXCJwcmVwYXJlVG9IaWRlXCIsIFwic2hvd1wiLCBcImhpZGVcIiwgXCJyZXBvc2l0aW9uXCJdO1xuICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYyLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgbWV0aG9kVG9CaW5kID0gX3JlZjJbX2pdO1xuICAgICAgdGhpcy5ib3VuZFttZXRob2RUb0JpbmRdID0gKGZ1bmN0aW9uKG1ldGhvZFRvQmluZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzW21ldGhvZFRvQmluZF0uYXBwbHkoX3RoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KShtZXRob2RUb0JpbmQpO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXIuZG9tUmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc2hvd09uID09PSBcImNyZWF0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByZXBhcmVUb1Nob3coKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIE9wZW50aXAucHJvdG90eXBlLl9zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWRlT24sIGhpZGVUcmlnZ2VyLCBoaWRlVHJpZ2dlckVsZW1lbnQsIGksIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICB0aGlzLmRlYnVnKFwiU2V0dGluZyB1cCB0aGUgdG9vbHRpcC5cIik7XG4gICAgdGhpcy5fYnVpbGRDb250YWluZXIoKTtcbiAgICB0aGlzLmhpZGVUcmlnZ2VycyA9IFtdO1xuICAgIF9yZWYgPSB0aGlzLm9wdGlvbnMuaGlkZVRyaWdnZXJzO1xuICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gICAgICBoaWRlVHJpZ2dlciA9IF9yZWZbaV07XG4gICAgICBoaWRlVHJpZ2dlckVsZW1lbnQgPSBudWxsO1xuICAgICAgaGlkZU9uID0gdGhpcy5vcHRpb25zLmhpZGVPbiBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcy5vcHRpb25zLmhpZGVPbltpXSA6IHRoaXMub3B0aW9ucy5oaWRlT247XG4gICAgICBpZiAodHlwZW9mIGhpZGVUcmlnZ2VyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN3aXRjaCAoaGlkZVRyaWdnZXIpIHtcbiAgICAgICAgICBjYXNlIFwidHJpZ2dlclwiOlxuICAgICAgICAgICAgaGlkZU9uID0gaGlkZU9uIHx8IFwibW91c2VvdXRcIjtcbiAgICAgICAgICAgIGhpZGVUcmlnZ2VyRWxlbWVudCA9IHRoaXMudHJpZ2dlckVsZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidGlwXCI6XG4gICAgICAgICAgICBoaWRlT24gPSBoaWRlT24gfHwgXCJtb3VzZW92ZXJcIjtcbiAgICAgICAgICAgIGhpZGVUcmlnZ2VyRWxlbWVudCA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRhcmdldFwiOlxuICAgICAgICAgICAgaGlkZU9uID0gaGlkZU9uIHx8IFwibW91c2VvdmVyXCI7XG4gICAgICAgICAgICBoaWRlVHJpZ2dlckVsZW1lbnQgPSB0aGlzLm9wdGlvbnMudGFyZ2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNsb3NlQnV0dG9uXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBoaWRlIHRyaWdnZXI6IFwiICsgaGlkZVRyaWdnZXIgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpZGVPbiA9IGhpZGVPbiB8fCBcIm1vdXNlb3ZlclwiO1xuICAgICAgICBoaWRlVHJpZ2dlckVsZW1lbnQgPSB0aGlzLmFkYXB0ZXIud3JhcChoaWRlVHJpZ2dlcik7XG4gICAgICB9XG4gICAgICBpZiAoaGlkZVRyaWdnZXJFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZVRyaWdnZXJzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGhpZGVUcmlnZ2VyRWxlbWVudCxcbiAgICAgICAgICBldmVudDogaGlkZU9uLFxuICAgICAgICAgIG9yaWdpbmFsOiBoaWRlVHJpZ2dlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3JlZjEgPSB0aGlzLmhpZGVUcmlnZ2VycztcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgaGlkZVRyaWdnZXIgPSBfcmVmMVtfal07XG4gICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuc2hvd1RyaWdnZXJzV2hlblZpc2libGUucHVzaCh7XG4gICAgICAgIGVsZW1lbnQ6IGhpZGVUcmlnZ2VyLmVsZW1lbnQsXG4gICAgICAgIGV2ZW50OiBcIm1vdXNlb3ZlclwiXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5fYnVpbGRDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuYWRhcHRlci5jcmVhdGUoXCI8ZGl2IGlkPVxcXCJvcGVudGlwLVwiICsgdGhpcy5pZCArIFwiXFxcIiBjbGFzcz1cXFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0uY29udGFpbmVyICsgXCIgXCIgKyB0aGlzW1wiY2xhc3NcIl0uaGlkZGVuICsgXCIgXCIgKyB0aGlzW1wiY2xhc3NcIl0uc3R5bGVQcmVmaXggKyB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lICsgXCJcXFwiPjwvZGl2PlwiKTtcbiAgICB0aGlzLmFkYXB0ZXIuY3NzKHRoaXMuY29udGFpbmVyLCB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hamF4KSB7XG4gICAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXNbXCJjbGFzc1wiXS5sb2FkaW5nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5maXhlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzW1wiY2xhc3NcIl0uZml4ZWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dFZmZlY3QpIHtcbiAgICAgIHRoaXMuYWRhcHRlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgXCJcIiArIHRoaXNbXCJjbGFzc1wiXS5zaG93RWZmZWN0UHJlZml4ICsgdGhpcy5vcHRpb25zLnNob3dFZmZlY3QpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmhpZGVFZmZlY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0uaGlkZUVmZmVjdFByZWZpeCArIHRoaXMub3B0aW9ucy5oaWRlRWZmZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX2J1aWxkRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGVhZGVyRWxlbWVudCwgdGl0bGVFbGVtZW50O1xuICAgIHRoaXMudG9vbHRpcEVsZW1lbnQgPSB0aGlzLmFkYXB0ZXIuY3JlYXRlKFwiPGRpdiBjbGFzcz1cXFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0ub3BlbnRpcCArIFwiXFxcIj48ZGl2IGNsYXNzPVxcXCJcIiArIHRoaXNbXCJjbGFzc1wiXS5oZWFkZXIgKyBcIlxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0uY29udGVudCArIFwiXFxcIj48L2Rpdj48L2Rpdj5cIik7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ2FudmFzID0gdGhpcy5hZGFwdGVyLndyYXAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSk7XG4gICAgdGhpcy5hZGFwdGVyLmNzcyh0aGlzLmJhY2tncm91bmRDYW52YXMsIHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIEdfdm1sQ2FudmFzTWFuYWdlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBHX3ZtbENhbnZhc01hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgIEdfdm1sQ2FudmFzTWFuYWdlci5pbml0RWxlbWVudCh0aGlzLmFkYXB0ZXIudW53cmFwKHRoaXMuYmFja2dyb3VuZENhbnZhcykpO1xuICAgIH1cbiAgICBoZWFkZXJFbGVtZW50ID0gdGhpcy5hZGFwdGVyLmZpbmQodGhpcy50b29sdGlwRWxlbWVudCwgXCIuXCIgKyB0aGlzW1wiY2xhc3NcIl0uaGVhZGVyKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpdGxlKSB7XG4gICAgICB0aXRsZUVsZW1lbnQgPSB0aGlzLmFkYXB0ZXIuY3JlYXRlKFwiPGgxPjwvaDE+XCIpO1xuICAgICAgdGhpcy5hZGFwdGVyLnVwZGF0ZSh0aXRsZUVsZW1lbnQsIHRoaXMub3B0aW9ucy50aXRsZSwgdGhpcy5vcHRpb25zLmVzY2FwZVRpdGxlKTtcbiAgICAgIHRoaXMuYWRhcHRlci5hcHBlbmQoaGVhZGVyRWxlbWVudCwgdGl0bGVFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hamF4ICYmICF0aGlzLmxvYWRlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyLmFwcGVuZCh0aGlzLnRvb2x0aXBFbGVtZW50LCB0aGlzLmFkYXB0ZXIuY3JlYXRlKFwiPGRpdiBjbGFzcz1cXFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0ubG9hZGluZ0luZGljYXRvciArIFwiXFxcIj48c3Bhbj7ihrs8L3NwYW4+PC9kaXY+XCIpKTtcbiAgICB9XG4gICAgaWYgKF9faW5kZXhPZi5jYWxsKHRoaXMub3B0aW9ucy5oaWRlVHJpZ2dlcnMsIFwiY2xvc2VCdXR0b25cIikgPj0gMCkge1xuICAgICAgdGhpcy5jbG9zZUJ1dHRvbkVsZW1lbnQgPSB0aGlzLmFkYXB0ZXIuY3JlYXRlKFwiPGEgaHJlZj1cXFwiamF2YXNjcmlwdDp1bmRlZmluZWQ7XFxcIiBjbGFzcz1cXFwiXCIgKyB0aGlzW1wiY2xhc3NcIl0uY2xvc2UgKyBcIlxcXCI+PHNwYW4+Q2xvc2U8L3NwYW4+PC9hPlwiKTtcbiAgICAgIHRoaXMuYWRhcHRlci5hcHBlbmQoaGVhZGVyRWxlbWVudCwgdGhpcy5jbG9zZUJ1dHRvbkVsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXIuYXBwZW5kKHRoaXMuY29udGFpbmVyLCB0aGlzLmJhY2tncm91bmRDYW52YXMpO1xuICAgIHRoaXMuYWRhcHRlci5hcHBlbmQodGhpcy5jb250YWluZXIsIHRoaXMudG9vbHRpcEVsZW1lbnQpO1xuICAgIHRoaXMuYWRhcHRlci5hcHBlbmQoZG9jdW1lbnQuYm9keSwgdGhpcy5jb250YWluZXIpO1xuICAgIHRoaXMuX25ld0NvbnRlbnQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLnJlZHJhdyA9IHRydWU7XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMuX25ld0NvbnRlbnQgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnRGdW5jdGlvbiA9IHRoaXMuY29udGVudDtcbiAgICAgIHRoaXMuY29udGVudCA9IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnRlbnRGdW5jdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVFbGVtZW50Q29udGVudCgpO1xuICAgIH1cbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5fdXBkYXRlRWxlbWVudENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGVudERpdjtcbiAgICBpZiAodGhpcy5fbmV3Q29udGVudCB8fCAoIXRoaXMub3B0aW9ucy5jYWNoZSAmJiB0aGlzLl9jb250ZW50RnVuY3Rpb24pKSB7XG4gICAgICBjb250ZW50RGl2ID0gdGhpcy5hZGFwdGVyLmZpbmQodGhpcy5jb250YWluZXIsIFwiLlwiICsgdGhpc1tcImNsYXNzXCJdLmNvbnRlbnQpO1xuICAgICAgaWYgKGNvbnRlbnREaXYgIT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudEZ1bmN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV4ZWN1dGluZyBjb250ZW50IGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLl9jb250ZW50RnVuY3Rpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGFwdGVyLnVwZGF0ZShjb250ZW50RGl2LCB0aGlzLmNvbnRlbnQsIHRoaXMub3B0aW9ucy5lc2NhcGVDb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX25ld0NvbnRlbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fc3RvcmVBbmRMb2NrRGltZW5zaW9ucygpO1xuICAgIHJldHVybiB0aGlzLnJlcG9zaXRpb24oKTtcbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5fc3RvcmVBbmRMb2NrRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcmV2RGltZW5zaW9uO1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJldkRpbWVuc2lvbiA9IHRoaXMuZGltZW5zaW9ucztcbiAgICB0aGlzLmFkYXB0ZXIuY3NzKHRoaXMuY29udGFpbmVyLCB7XG4gICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICBsZWZ0OiBcIjBweFwiLFxuICAgICAgdG9wOiBcIjBweFwiXG4gICAgfSk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdGhpcy5hZGFwdGVyLmRpbWVuc2lvbnModGhpcy5jb250YWluZXIpO1xuICAgIHRoaXMuZGltZW5zaW9ucy53aWR0aCArPSAxO1xuICAgIHRoaXMuYWRhcHRlci5jc3ModGhpcy5jb250YWluZXIsIHtcbiAgICAgIHdpZHRoOiBcIlwiICsgdGhpcy5kaW1lbnNpb25zLndpZHRoICsgXCJweFwiLFxuICAgICAgdG9wOiBcIlwiICsgdGhpcy5jdXJyZW50UG9zaXRpb24udG9wICsgXCJweFwiLFxuICAgICAgbGVmdDogXCJcIiArIHRoaXMuY3VycmVudFBvc2l0aW9uLmxlZnQgKyBcInB4XCJcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuX2RpbWVuc2lvbnNFcXVhbCh0aGlzLmRpbWVuc2lvbnMsIHByZXZEaW1lbnNpb24pKSB7XG4gICAgICB0aGlzLnJlZHJhdyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXR1cE9ic2VydmVycyhcImhpZGRlblwiLCBcImhpZGluZ1wiKTtcbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kZWJ1ZyhcIkRlYWN0aXZhdGluZyB0b29sdGlwLlwiKTtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fc2V0dXBPYnNlcnZlcnMoXCItc2hvd2luZ1wiLCBcIi12aXNpYmxlXCIsIFwiLWhpZGRlblwiLCBcIi1oaWRpbmdcIik7XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX3NldHVwT2JzZXJ2ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9ic2VydmVPclN0b3AsIHJlbW92ZU9ic2VydmVyLCBzdGF0ZSwgc3RhdGVzLCB0cmlnZ2VyLCBfaSwgX2osIF9rLCBfbCwgX2xlbiwgX2xlbjEsIF9sZW4yLCBfbGVuMywgX3JlZiwgX3JlZjEsIF9yZWYyLFxuICAgICAgX3RoaXMgPSB0aGlzO1xuICAgIHN0YXRlcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBzdGF0ZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHN0YXRlID0gc3RhdGVzW19pXTtcbiAgICAgIHJlbW92ZU9ic2VydmVyID0gZmFsc2U7XG4gICAgICBpZiAoc3RhdGUuY2hhckF0KDApID09PSBcIi1cIikge1xuICAgICAgICByZW1vdmVPYnNlcnZlciA9IHRydWU7XG4gICAgICAgIHN0YXRlID0gc3RhdGUuc3Vic3RyKDEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VycmVudE9ic2VydmVyc1tzdGF0ZV0gPT09ICFyZW1vdmVPYnNlcnZlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudE9ic2VydmVyc1tzdGF0ZV0gPSAhcmVtb3ZlT2JzZXJ2ZXI7XG4gICAgICBvYnNlcnZlT3JTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzLCBfcmVmLCBfcmVmMTtcbiAgICAgICAgYXJncyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICAgIGlmIChyZW1vdmVPYnNlcnZlcikge1xuICAgICAgICAgIHJldHVybiAoX3JlZiA9IF90aGlzLmFkYXB0ZXIpLnN0b3BPYnNlcnZpbmcuYXBwbHkoX3JlZiwgYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChfcmVmMSA9IF90aGlzLmFkYXB0ZXIpLm9ic2VydmUuYXBwbHkoX3JlZjEsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIFwic2hvd2luZ1wiOlxuICAgICAgICAgIF9yZWYgPSB0aGlzLmhpZGVUcmlnZ2VycztcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgdHJpZ2dlciA9IF9yZWZbX2pdO1xuICAgICAgICAgICAgb2JzZXJ2ZU9yU3RvcCh0cmlnZ2VyLmVsZW1lbnQsIHRyaWdnZXIuZXZlbnQsIHRoaXMuYm91bmQucHJlcGFyZVRvSGlkZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ic2VydmVPclN0b3AoKGRvY3VtZW50Lm9ucmVzaXplICE9IG51bGwgPyBkb2N1bWVudCA6IHdpbmRvdyksIFwicmVzaXplXCIsIHRoaXMuYm91bmQucmVwb3NpdGlvbik7XG4gICAgICAgICAgb2JzZXJ2ZU9yU3RvcCh3aW5kb3csIFwic2Nyb2xsXCIsIHRoaXMuYm91bmQucmVwb3NpdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2aXNpYmxlXCI6XG4gICAgICAgICAgX3JlZjEgPSB0aGlzLnNob3dUcmlnZ2Vyc1doZW5WaXNpYmxlO1xuICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IF9yZWYxLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgdHJpZ2dlciA9IF9yZWYxW19rXTtcbiAgICAgICAgICAgIG9ic2VydmVPclN0b3AodHJpZ2dlci5lbGVtZW50LCB0cmlnZ2VyLmV2ZW50LCB0aGlzLmJvdW5kLnByZXBhcmVUb1Nob3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhpZGluZ1wiOlxuICAgICAgICAgIF9yZWYyID0gdGhpcy5zaG93VHJpZ2dlcnM7XG4gICAgICAgICAgZm9yIChfbCA9IDAsIF9sZW4zID0gX3JlZjIubGVuZ3RoOyBfbCA8IF9sZW4zOyBfbCsrKSB7XG4gICAgICAgICAgICB0cmlnZ2VyID0gX3JlZjJbX2xdO1xuICAgICAgICAgICAgb2JzZXJ2ZU9yU3RvcCh0cmlnZ2VyLmVsZW1lbnQsIHRyaWdnZXIuZXZlbnQsIHRoaXMuYm91bmQucHJlcGFyZVRvU2hvdyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdGF0ZTogXCIgKyBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE9wZW50aXAucHJvdG90eXBlLnByZXBhcmVUb1Nob3cgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9hYm9ydEhpZGluZygpO1xuICAgIHRoaXMuX2Fib3J0U2hvd2luZygpO1xuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIlNob3dpbmcgaW4gXCIgKyB0aGlzLm9wdGlvbnMuZGVsYXkgKyBcInMuXCIpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICB0aGlzLl9zZXR1cCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmdyb3VwKSB7XG4gICAgICBPcGVudGlwLl9hYm9ydFNob3dpbmdHcm91cCh0aGlzLm9wdGlvbnMuZ3JvdXAsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnByZXBhcmluZ1RvU2hvdyA9IHRydWU7XG4gICAgdGhpcy5fc2V0dXBPYnNlcnZlcnMoXCItaGlkZGVuXCIsIFwiLWhpZGluZ1wiLCBcInNob3dpbmdcIik7XG4gICAgdGhpcy5fZm9sbG93TW91c2VQb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZml4ZWQgJiYgIXRoaXMub3B0aW9ucy50YXJnZXQpIHtcbiAgICAgIHRoaXMuaW5pdGlhbE1vdXNlUG9zaXRpb24gPSBtb3VzZVBvc2l0aW9uO1xuICAgIH1cbiAgICB0aGlzLnJlcG9zaXRpb24oKTtcbiAgICByZXR1cm4gdGhpcy5fc2hvd1RpbWVvdXRJZCA9IHRoaXMuc2V0VGltZW91dCh0aGlzLmJvdW5kLnNob3csIHRoaXMub3B0aW9ucy5kZWxheSB8fCAwKTtcbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9hYm9ydEhpZGluZygpO1xuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0cygpO1xuICAgIGlmICghdGhpcy5fdHJpZ2dlckVsZW1lbnRFeGlzdHMoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKFwiU2hvd2luZyBub3cuXCIpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICB0aGlzLl9zZXR1cCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmdyb3VwKSB7XG4gICAgICBPcGVudGlwLl9oaWRlR3JvdXAodGhpcy5vcHRpb25zLmdyb3VwLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnByZXBhcmluZ1RvU2hvdyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnRvb2x0aXBFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1aWxkRWxlbWVudHMoKTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRWxlbWVudENvbnRlbnQoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFqYXggJiYgKCF0aGlzLmxvYWRlZCB8fCAhdGhpcy5vcHRpb25zLmNhY2hlKSkge1xuICAgICAgdGhpcy5fbG9hZEFqYXgoKTtcbiAgICB9XG4gICAgdGhpcy5fc2VhcmNoQW5kQWN0aXZhdGVDbG9zZUJ1dHRvbnMoKTtcbiAgICB0aGlzLl9zdGFydEVuc3VyZVRyaWdnZXJFbGVtZW50KCk7XG4gICAgdGhpcy5hZGFwdGVyLmNzcyh0aGlzLmNvbnRhaW5lciwge1xuICAgICAgekluZGV4OiBPcGVudGlwLmxhc3RaSW5kZXgrK1xuICAgIH0pO1xuICAgIHRoaXMuX3NldHVwT2JzZXJ2ZXJzKFwiLWhpZGRlblwiLCBcIi1oaWRpbmdcIiwgXCItc2hvd2luZ1wiLCBcIi12aXNpYmxlXCIsIFwic2hvd2luZ1wiLCBcInZpc2libGVcIik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5maXhlZCAmJiAhdGhpcy5vcHRpb25zLnRhcmdldCkge1xuICAgICAgdGhpcy5pbml0aWFsTW91c2VQb3NpdGlvbiA9IG1vdXNlUG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMucmVwb3NpdGlvbigpO1xuICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpc1tcImNsYXNzXCJdLmhpZGluZyk7XG4gICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzW1wiY2xhc3NcIl0uaGlkZGVuKTtcbiAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXNbXCJjbGFzc1wiXS5nb2luZ1RvU2hvdyk7XG4gICAgdGhpcy5zZXRDc3MzU3R5bGUodGhpcy5jb250YWluZXIsIHtcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogXCIwc1wiXG4gICAgfSk7XG4gICAgdGhpcy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZWxheTtcbiAgICAgIGlmICghX3RoaXMudmlzaWJsZSB8fCBfdGhpcy5wcmVwYXJpbmdUb0hpZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhfdGhpcy5jb250YWluZXIsIF90aGlzW1wiY2xhc3NcIl0uZ29pbmdUb1Nob3cpO1xuICAgICAgX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhfdGhpcy5jb250YWluZXIsIF90aGlzW1wiY2xhc3NcIl0uc2hvd2luZyk7XG4gICAgICBkZWxheSA9IDA7XG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5zaG93RWZmZWN0ICYmIF90aGlzLm9wdGlvbnMuc2hvd0VmZmVjdER1cmF0aW9uKSB7XG4gICAgICAgIGRlbGF5ID0gX3RoaXMub3B0aW9ucy5zaG93RWZmZWN0RHVyYXRpb247XG4gICAgICB9XG4gICAgICBfdGhpcy5zZXRDc3MzU3R5bGUoX3RoaXMuY29udGFpbmVyLCB7XG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogXCJcIiArIGRlbGF5ICsgXCJzXCJcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuX3Zpc2liaWxpdHlTdGF0ZVRpbWVvdXRJZCA9IF90aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoX3RoaXMuY29udGFpbmVyLCBfdGhpc1tcImNsYXNzXCJdLnNob3dpbmcpO1xuICAgICAgICByZXR1cm4gX3RoaXMuYWRhcHRlci5hZGRDbGFzcyhfdGhpcy5jb250YWluZXIsIF90aGlzW1wiY2xhc3NcIl0udmlzaWJsZSk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgICByZXR1cm4gX3RoaXMuX2FjdGl2YXRlRmlyc3RJbnB1dCgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9kcmF3KCk7XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX2Fib3J0U2hvd2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnByZXBhcmluZ1RvU2hvdykge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkFib3J0aW5nIHNob3dpbmcuXCIpO1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0cygpO1xuICAgICAgdGhpcy5fc3RvcEZvbGxvd2luZ01vdXNlUG9zaXRpb24oKTtcbiAgICAgIHRoaXMucHJlcGFyaW5nVG9TaG93ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0dXBPYnNlcnZlcnMoXCItc2hvd2luZ1wiLCBcIi12aXNpYmxlXCIsIFwiaGlkaW5nXCIsIFwiaGlkZGVuXCIpO1xuICAgIH1cbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5wcmVwYXJlVG9IaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYWJvcnRTaG93aW5nKCk7XG4gICAgdGhpcy5fYWJvcnRIaWRpbmcoKTtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKFwiSGlkaW5nIGluIFwiICsgdGhpcy5vcHRpb25zLmhpZGVEZWxheSArIFwic1wiKTtcbiAgICB0aGlzLnByZXBhcmluZ1RvSGlkZSA9IHRydWU7XG4gICAgdGhpcy5fc2V0dXBPYnNlcnZlcnMoXCItc2hvd2luZ1wiLCBcInZpc2libGVcIiwgXCItaGlkZGVuXCIsIFwiaGlkaW5nXCIpO1xuICAgIHJldHVybiB0aGlzLl9oaWRlVGltZW91dElkID0gdGhpcy5zZXRUaW1lb3V0KHRoaXMuYm91bmQuaGlkZSwgdGhpcy5vcHRpb25zLmhpZGVEZWxheSk7XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fYWJvcnRTaG93aW5nKCk7XG4gICAgaWYgKCF0aGlzLnZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0cygpO1xuICAgIHRoaXMuZGVidWcoXCJIaWRpbmchXCIpO1xuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMucHJlcGFyaW5nVG9IaWRlID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcEVuc3VyZVRyaWdnZXJFbGVtZW50KCk7XG4gICAgdGhpcy5fc2V0dXBPYnNlcnZlcnMoXCItc2hvd2luZ1wiLCBcIi12aXNpYmxlXCIsIFwiLWhpZGluZ1wiLCBcIi1oaWRkZW5cIiwgXCJoaWRpbmdcIiwgXCJoaWRkZW5cIik7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZml4ZWQpIHtcbiAgICAgIHRoaXMuX3N0b3BGb2xsb3dpbmdNb3VzZVBvc2l0aW9uKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzW1wiY2xhc3NcIl0udmlzaWJsZSk7XG4gICAgdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzW1wiY2xhc3NcIl0uc2hvd2luZyk7XG4gICAgdGhpcy5hZGFwdGVyLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCB0aGlzW1wiY2xhc3NcIl0uZ29pbmdUb0hpZGUpO1xuICAgIHRoaXMuc2V0Q3NzM1N0eWxlKHRoaXMuY29udGFpbmVyLCB7XG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IFwiMHNcIlxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhpZGVEZWxheTtcbiAgICAgIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoX3RoaXMuY29udGFpbmVyLCBfdGhpc1tcImNsYXNzXCJdLmdvaW5nVG9IaWRlKTtcbiAgICAgIF90aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoX3RoaXMuY29udGFpbmVyLCBfdGhpc1tcImNsYXNzXCJdLmhpZGluZyk7XG4gICAgICBoaWRlRGVsYXkgPSAwO1xuICAgICAgaWYgKF90aGlzLm9wdGlvbnMuaGlkZUVmZmVjdCAmJiBfdGhpcy5vcHRpb25zLmhpZGVFZmZlY3REdXJhdGlvbikge1xuICAgICAgICBoaWRlRGVsYXkgPSBfdGhpcy5vcHRpb25zLmhpZGVFZmZlY3REdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIF90aGlzLnNldENzczNTdHlsZShfdGhpcy5jb250YWluZXIsIHtcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBcIlwiICsgaGlkZURlbGF5ICsgXCJzXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF90aGlzLl92aXNpYmlsaXR5U3RhdGVUaW1lb3V0SWQgPSBfdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5hZGFwdGVyLnJlbW92ZUNsYXNzKF90aGlzLmNvbnRhaW5lciwgX3RoaXNbXCJjbGFzc1wiXS5oaWRpbmcpO1xuICAgICAgICBfdGhpcy5hZGFwdGVyLmFkZENsYXNzKF90aGlzLmNvbnRhaW5lciwgX3RoaXNbXCJjbGFzc1wiXS5oaWRkZW4pO1xuICAgICAgICBfdGhpcy5zZXRDc3MzU3R5bGUoX3RoaXMuY29udGFpbmVyLCB7XG4gICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBcIjBzXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnJlbW92ZUVsZW1lbnRzT25IaWRlKSB7XG4gICAgICAgICAgX3RoaXMuZGVidWcoXCJSZW1vdmluZyBIVE1MIGVsZW1lbnRzLlwiKTtcbiAgICAgICAgICBfdGhpcy5hZGFwdGVyLnJlbW92ZShfdGhpcy5jb250YWluZXIpO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpcy5jb250YWluZXI7XG4gICAgICAgICAgcmV0dXJuIGRlbGV0ZSBfdGhpcy50b29sdGlwRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSwgaGlkZURlbGF5KTtcbiAgICB9KTtcbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5fYWJvcnRIaWRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wcmVwYXJpbmdUb0hpZGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJBYm9ydGluZyBoaWRpbmcuXCIpO1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0cygpO1xuICAgICAgdGhpcy5wcmVwYXJpbmdUb0hpZGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLl9zZXR1cE9ic2VydmVycyhcIi1oaWRpbmdcIiwgXCJzaG93aW5nXCIsIFwidmlzaWJsZVwiKTtcbiAgICB9XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUucmVwb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb3NpdGlvbiwgc3RlbSwgX3JlZixcbiAgICAgIF90aGlzID0gdGhpcztcbiAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGVtID0gdGhpcy5vcHRpb25zLnN0ZW07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluSW5WaWV3cG9ydCkge1xuICAgICAgX3JlZiA9IHRoaXMuX2Vuc3VyZVZpZXdwb3J0Q29udGFpbm1lbnQocG9zaXRpb24pLCBwb3NpdGlvbiA9IF9yZWYucG9zaXRpb24sIHN0ZW0gPSBfcmVmLnN0ZW07XG4gICAgfVxuICAgIGlmICh0aGlzLl9wb3NpdGlvbnNFcXVhbChwb3NpdGlvbiwgdGhpcy5jdXJyZW50UG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKCF0aGlzLm9wdGlvbnMuc3RlbSB8fCBzdGVtLmVxbCh0aGlzLmN1cnJlbnRTdGVtKSkpIHtcbiAgICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB0aGlzLmN1cnJlbnRTdGVtID0gc3RlbTtcbiAgICB0aGlzLl9kcmF3KCk7XG4gICAgdGhpcy5hZGFwdGVyLmNzcyh0aGlzLmNvbnRhaW5lciwge1xuICAgICAgbGVmdDogXCJcIiArIHBvc2l0aW9uLmxlZnQgKyBcInB4XCIsXG4gICAgICB0b3A6IFwiXCIgKyBwb3NpdGlvbi50b3AgKyBcInB4XCJcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYXdDb250YWluZXIsIHJlZHJhd0ZpeDtcbiAgICAgIHJhd0NvbnRhaW5lciA9IF90aGlzLmFkYXB0ZXIudW53cmFwKF90aGlzLmNvbnRhaW5lcik7XG4gICAgICByYXdDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICByZWRyYXdGaXggPSByYXdDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgcmV0dXJuIHJhd0NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgfSk7XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbih0aXBKb2ludCwgdGFyZ2V0Sm9pbnQsIHN0ZW0pIHtcbiAgICB2YXIgYWRkaXRpb25hbEhvcml6b250YWwsIGFkZGl0aW9uYWxWZXJ0aWNhbCwgb2Zmc2V0RGlzdGFuY2UsIHBvc2l0aW9uLCBzdGVtTGVuZ3RoLCB0YXJnZXREaW1lbnNpb25zLCB0YXJnZXRQb3NpdGlvbiwgdW53cmFwcGVkVGFyZ2V0LCBfcmVmO1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRpcEpvaW50ID09IG51bGwpIHtcbiAgICAgIHRpcEpvaW50ID0gdGhpcy5vcHRpb25zLnRpcEpvaW50O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Sm9pbnQgPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0Sm9pbnQgPSB0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQ7XG4gICAgfVxuICAgIHBvc2l0aW9uID0ge307XG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXQpIHtcbiAgICAgIHRhcmdldFBvc2l0aW9uID0gdGhpcy5hZGFwdGVyLm9mZnNldCh0aGlzLm9wdGlvbnMudGFyZ2V0KTtcbiAgICAgIHRhcmdldERpbWVuc2lvbnMgPSB0aGlzLmFkYXB0ZXIuZGltZW5zaW9ucyh0aGlzLm9wdGlvbnMudGFyZ2V0KTtcbiAgICAgIHBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb247XG4gICAgICBpZiAodGFyZ2V0Sm9pbnQucmlnaHQpIHtcbiAgICAgICAgdW53cmFwcGVkVGFyZ2V0ID0gdGhpcy5hZGFwdGVyLnVud3JhcCh0aGlzLm9wdGlvbnMudGFyZ2V0KTtcbiAgICAgICAgaWYgKHVud3JhcHBlZFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT0gbnVsbCkge1xuICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPSB1bndyYXBwZWRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgKyAoKF9yZWYgPSB3aW5kb3cucGFnZVhPZmZzZXQpICE9IG51bGwgPyBfcmVmIDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3NpdGlvbi5sZWZ0ICs9IHRhcmdldERpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Sm9pbnQuY2VudGVyKSB7XG4gICAgICAgIHBvc2l0aW9uLmxlZnQgKz0gTWF0aC5yb3VuZCh0YXJnZXREaW1lbnNpb25zLndpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0Sm9pbnQuYm90dG9tKSB7XG4gICAgICAgIHBvc2l0aW9uLnRvcCArPSB0YXJnZXREaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Sm9pbnQubWlkZGxlKSB7XG4gICAgICAgIHBvc2l0aW9uLnRvcCArPSBNYXRoLnJvdW5kKHRhcmdldERpbWVuc2lvbnMuaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGlwSm9pbnQubGVmdCkge1xuICAgICAgICAgIHBvc2l0aW9uLmxlZnQgKz0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGlwSm9pbnQucmlnaHQpIHtcbiAgICAgICAgICBwb3NpdGlvbi5sZWZ0IC09IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRpcEpvaW50LnRvcCkge1xuICAgICAgICAgIHBvc2l0aW9uLnRvcCArPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnRpcEpvaW50LmJvdHRvbSkge1xuICAgICAgICAgIHBvc2l0aW9uLnRvcCAtPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbE1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgICAgdG9wOiB0aGlzLmluaXRpYWxNb3VzZVBvc2l0aW9uLnksXG4gICAgICAgICAgbGVmdDogdGhpcy5pbml0aWFsTW91c2VQb3NpdGlvbi54XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGlvbiA9IHtcbiAgICAgICAgICB0b3A6IG1vdXNlUG9zaXRpb24ueSxcbiAgICAgICAgICBsZWZ0OiBtb3VzZVBvc2l0aW9uLnhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvT2Zmc2V0KSB7XG4gICAgICBzdGVtTGVuZ3RoID0gdGhpcy5vcHRpb25zLnN0ZW0gPyB0aGlzLm9wdGlvbnMuc3RlbUxlbmd0aCA6IDA7XG4gICAgICBvZmZzZXREaXN0YW5jZSA9IHN0ZW1MZW5ndGggJiYgdGhpcy5vcHRpb25zLmZpeGVkID8gMiA6IDEwO1xuICAgICAgYWRkaXRpb25hbEhvcml6b250YWwgPSB0aXBKb2ludC5taWRkbGUgJiYgIXRoaXMub3B0aW9ucy5maXhlZCA/IDE1IDogMDtcbiAgICAgIGFkZGl0aW9uYWxWZXJ0aWNhbCA9IHRpcEpvaW50LmNlbnRlciAmJiAhdGhpcy5vcHRpb25zLmZpeGVkID8gMTUgOiAwO1xuICAgICAgaWYgKHRpcEpvaW50LnJpZ2h0KSB7XG4gICAgICAgIHBvc2l0aW9uLmxlZnQgLT0gb2Zmc2V0RGlzdGFuY2UgKyBhZGRpdGlvbmFsSG9yaXpvbnRhbDtcbiAgICAgIH0gZWxzZSBpZiAodGlwSm9pbnQubGVmdCkge1xuICAgICAgICBwb3NpdGlvbi5sZWZ0ICs9IG9mZnNldERpc3RhbmNlICsgYWRkaXRpb25hbEhvcml6b250YWw7XG4gICAgICB9XG4gICAgICBpZiAodGlwSm9pbnQuYm90dG9tKSB7XG4gICAgICAgIHBvc2l0aW9uLnRvcCAtPSBvZmZzZXREaXN0YW5jZSArIGFkZGl0aW9uYWxWZXJ0aWNhbDtcbiAgICAgIH0gZWxzZSBpZiAodGlwSm9pbnQudG9wKSB7XG4gICAgICAgIHBvc2l0aW9uLnRvcCArPSBvZmZzZXREaXN0YW5jZSArIGFkZGl0aW9uYWxWZXJ0aWNhbDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGVtTGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdGVtID09IG51bGwpIHtcbiAgICAgICAgICBzdGVtID0gdGhpcy5vcHRpb25zLnN0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZW0ucmlnaHQpIHtcbiAgICAgICAgICBwb3NpdGlvbi5sZWZ0IC09IHN0ZW1MZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlbS5sZWZ0KSB7XG4gICAgICAgICAgcG9zaXRpb24ubGVmdCArPSBzdGVtTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGVtLmJvdHRvbSkge1xuICAgICAgICAgIHBvc2l0aW9uLnRvcCAtPSBzdGVtTGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHN0ZW0udG9wKSB7XG4gICAgICAgICAgcG9zaXRpb24udG9wICs9IHN0ZW1MZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcG9zaXRpb24ubGVmdCArPSB0aGlzLm9wdGlvbnMub2Zmc2V0WzBdO1xuICAgIHBvc2l0aW9uLnRvcCArPSB0aGlzLm9wdGlvbnMub2Zmc2V0WzFdO1xuICAgIGlmICh0aXBKb2ludC5yaWdodCkge1xuICAgICAgcG9zaXRpb24ubGVmdCAtPSB0aGlzLmRpbWVuc2lvbnMud2lkdGg7XG4gICAgfSBlbHNlIGlmICh0aXBKb2ludC5jZW50ZXIpIHtcbiAgICAgIHBvc2l0aW9uLmxlZnQgLT0gTWF0aC5yb3VuZCh0aGlzLmRpbWVuc2lvbnMud2lkdGggLyAyKTtcbiAgICB9XG4gICAgaWYgKHRpcEpvaW50LmJvdHRvbSkge1xuICAgICAgcG9zaXRpb24udG9wIC09IHRoaXMuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh0aXBKb2ludC5taWRkbGUpIHtcbiAgICAgIHBvc2l0aW9uLnRvcCAtPSBNYXRoLnJvdW5kKHRoaXMuZGltZW5zaW9ucy5oZWlnaHQgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuXG4gIE9wZW50aXAucHJvdG90eXBlLl9lbnN1cmVWaWV3cG9ydENvbnRhaW5tZW50ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICB2YXIgbmVlZHNSZXBvc2l0aW9uaW5nLCBuZXdTdGlja3NPdXQsIG9yaWdpbmFscywgcmV2ZXJ0ZWRYLCByZXZlcnRlZFksIHNjcm9sbE9mZnNldCwgc3RlbSwgc3RpY2tzT3V0LCB0YXJnZXRKb2ludCwgdGlwSm9pbnQsIHZpZXdwb3J0RGltZW5zaW9ucywgdmlld3BvcnRQb3NpdGlvbjtcbiAgICBzdGVtID0gdGhpcy5vcHRpb25zLnN0ZW07XG4gICAgb3JpZ2luYWxzID0ge1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgc3RlbTogc3RlbVxuICAgIH07XG4gICAgaWYgKCEodGhpcy52aXNpYmxlICYmIHBvc2l0aW9uKSkge1xuICAgICAgcmV0dXJuIG9yaWdpbmFscztcbiAgICB9XG4gICAgc3RpY2tzT3V0ID0gdGhpcy5fc3RpY2tzT3V0KHBvc2l0aW9uKTtcbiAgICBpZiAoIShzdGlja3NPdXRbMF0gfHwgc3RpY2tzT3V0WzFdKSkge1xuICAgICAgcmV0dXJuIG9yaWdpbmFscztcbiAgICB9XG4gICAgdGlwSm9pbnQgPSBuZXcgT3BlbnRpcC5Kb2ludCh0aGlzLm9wdGlvbnMudGlwSm9pbnQpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQpIHtcbiAgICAgIHRhcmdldEpvaW50ID0gbmV3IE9wZW50aXAuSm9pbnQodGhpcy5vcHRpb25zLnRhcmdldEpvaW50KTtcbiAgICB9XG4gICAgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5hZGFwdGVyLnNjcm9sbE9mZnNldCgpO1xuICAgIHZpZXdwb3J0RGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlci52aWV3cG9ydERpbWVuc2lvbnMoKTtcbiAgICB2aWV3cG9ydFBvc2l0aW9uID0gW3Bvc2l0aW9uLmxlZnQgLSBzY3JvbGxPZmZzZXRbMF0sIHBvc2l0aW9uLnRvcCAtIHNjcm9sbE9mZnNldFsxXV07XG4gICAgbmVlZHNSZXBvc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgaWYgKHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCA+PSB0aGlzLmRpbWVuc2lvbnMud2lkdGgpIHtcbiAgICAgIGlmIChzdGlja3NPdXRbMF0pIHtcbiAgICAgICAgbmVlZHNSZXBvc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoIChzdGlja3NPdXRbMF0pIHtcbiAgICAgICAgICBjYXNlIHRoaXMuU1RJQ0tTX09VVF9MRUZUOlxuICAgICAgICAgICAgdGlwSm9pbnQuc2V0SG9yaXpvbnRhbChcImxlZnRcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEpvaW50KSB7XG4gICAgICAgICAgICAgIHRhcmdldEpvaW50LnNldEhvcml6b250YWwoXCJyaWdodFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgdGhpcy5TVElDS1NfT1VUX1JJR0hUOlxuICAgICAgICAgICAgdGlwSm9pbnQuc2V0SG9yaXpvbnRhbChcInJpZ2h0XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXRKb2ludCkge1xuICAgICAgICAgICAgICB0YXJnZXRKb2ludC5zZXRIb3Jpem9udGFsKFwibGVmdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlld3BvcnREaW1lbnNpb25zLmhlaWdodCA+PSB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0KSB7XG4gICAgICBpZiAoc3RpY2tzT3V0WzFdKSB7XG4gICAgICAgIG5lZWRzUmVwb3NpdGlvbmluZyA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAoc3RpY2tzT3V0WzFdKSB7XG4gICAgICAgICAgY2FzZSB0aGlzLlNUSUNLU19PVVRfVE9QOlxuICAgICAgICAgICAgdGlwSm9pbnQuc2V0VmVydGljYWwoXCJ0b3BcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEpvaW50KSB7XG4gICAgICAgICAgICAgIHRhcmdldEpvaW50LnNldFZlcnRpY2FsKFwiYm90dG9tXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB0aGlzLlNUSUNLU19PVVRfQk9UVE9NOlxuICAgICAgICAgICAgdGlwSm9pbnQuc2V0VmVydGljYWwoXCJib3R0b21cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEpvaW50KSB7XG4gICAgICAgICAgICAgIHRhcmdldEpvaW50LnNldFZlcnRpY2FsKFwidG9wXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbmVlZHNSZXBvc2l0aW9uaW5nKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxzO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnN0ZW0pIHtcbiAgICAgIHN0ZW0gPSB0aXBKb2ludDtcbiAgICB9XG4gICAgcG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKHRpcEpvaW50LCB0YXJnZXRKb2ludCwgc3RlbSk7XG4gICAgbmV3U3RpY2tzT3V0ID0gdGhpcy5fc3RpY2tzT3V0KHBvc2l0aW9uKTtcbiAgICByZXZlcnRlZFggPSBmYWxzZTtcbiAgICByZXZlcnRlZFkgPSBmYWxzZTtcbiAgICBpZiAobmV3U3RpY2tzT3V0WzBdICYmIChuZXdTdGlja3NPdXRbMF0gIT09IHN0aWNrc091dFswXSkpIHtcbiAgICAgIHJldmVydGVkWCA9IHRydWU7XG4gICAgICB0aXBKb2ludC5zZXRIb3Jpem9udGFsKHRoaXMub3B0aW9ucy50aXBKb2ludC5ob3Jpem9udGFsKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQpIHtcbiAgICAgICAgdGFyZ2V0Sm9pbnQuc2V0SG9yaXpvbnRhbCh0aGlzLm9wdGlvbnMudGFyZ2V0Sm9pbnQuaG9yaXpvbnRhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdTdGlja3NPdXRbMV0gJiYgKG5ld1N0aWNrc091dFsxXSAhPT0gc3RpY2tzT3V0WzFdKSkge1xuICAgICAgcmV2ZXJ0ZWRZID0gdHJ1ZTtcbiAgICAgIHRpcEpvaW50LnNldFZlcnRpY2FsKHRoaXMub3B0aW9ucy50aXBKb2ludC52ZXJ0aWNhbCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEpvaW50KSB7XG4gICAgICAgIHRhcmdldEpvaW50LnNldFZlcnRpY2FsKHRoaXMub3B0aW9ucy50YXJnZXRKb2ludC52ZXJ0aWNhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXZlcnRlZFggJiYgcmV2ZXJ0ZWRZKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxzO1xuICAgIH1cbiAgICBpZiAocmV2ZXJ0ZWRYIHx8IHJldmVydGVkWSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGVtKSB7XG4gICAgICAgIHN0ZW0gPSB0aXBKb2ludDtcbiAgICAgIH1cbiAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbih0aXBKb2ludCwgdGFyZ2V0Sm9pbnQsIHN0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgc3RlbTogc3RlbVxuICAgIH07XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX3N0aWNrc091dCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgdmFyIHBvc2l0aW9uT2Zmc2V0LCBzY3JvbGxPZmZzZXQsIHN0aWNrc091dCwgdmlld3BvcnREaW1lbnNpb25zO1xuICAgIHNjcm9sbE9mZnNldCA9IHRoaXMuYWRhcHRlci5zY3JvbGxPZmZzZXQoKTtcbiAgICB2aWV3cG9ydERpbWVuc2lvbnMgPSB0aGlzLmFkYXB0ZXIudmlld3BvcnREaW1lbnNpb25zKCk7XG4gICAgcG9zaXRpb25PZmZzZXQgPSBbcG9zaXRpb24ubGVmdCAtIHNjcm9sbE9mZnNldFswXSwgcG9zaXRpb24udG9wIC0gc2Nyb2xsT2Zmc2V0WzFdXTtcbiAgICBzdGlja3NPdXQgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICBpZiAocG9zaXRpb25PZmZzZXRbMF0gPCAwKSB7XG4gICAgICBzdGlja3NPdXRbMF0gPSB0aGlzLlNUSUNLU19PVVRfTEVGVDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uT2Zmc2V0WzBdICsgdGhpcy5kaW1lbnNpb25zLndpZHRoID4gdmlld3BvcnREaW1lbnNpb25zLndpZHRoKSB7XG4gICAgICBzdGlja3NPdXRbMF0gPSB0aGlzLlNUSUNLU19PVVRfUklHSFQ7XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbk9mZnNldFsxXSA8IDApIHtcbiAgICAgIHN0aWNrc091dFsxXSA9IHRoaXMuU1RJQ0tTX09VVF9UT1A7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbk9mZnNldFsxXSArIHRoaXMuZGltZW5zaW9ucy5oZWlnaHQgPiB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0KSB7XG4gICAgICBzdGlja3NPdXRbMV0gPSB0aGlzLlNUSUNLU19PVVRfQk9UVE9NO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2tzT3V0O1xuICB9O1xuXG4gIE9wZW50aXAucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJhY2tncm91bmRDYW52YXMsIGJ1bGdlLCBjYW52YXNEaW1lbnNpb25zLCBjYW52YXNQb3NpdGlvbiwgY2xvc2VCdXR0b24sIGNsb3NlQnV0dG9uSW5uZXIsIGNsb3NlQnV0dG9uT3V0ZXIsIGN0eCwgZHJhd0Nvcm5lciwgZHJhd0xpbmUsIGhiLCBwb3NpdGlvbiwgc3RlbUJhc2UsIHN0ZW1MZW5ndGgsIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3JlZjIsXG4gICAgICBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKCEodGhpcy5iYWNrZ3JvdW5kQ2FudmFzICYmIHRoaXMucmVkcmF3KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKFwiRHJhd2luZyBiYWNrZ3JvdW5kLlwiKTtcbiAgICB0aGlzLnJlZHJhdyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmN1cnJlbnRTdGVtKSB7XG4gICAgICBfcmVmID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHBvc2l0aW9uID0gX3JlZltfaV07XG4gICAgICAgIHRoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyh0aGlzLmNvbnRhaW5lciwgXCJzdGVtLVwiICsgcG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCBcInN0ZW0tXCIgKyB0aGlzLmN1cnJlbnRTdGVtLmhvcml6b250YWwpO1xuICAgICAgdGhpcy5hZGFwdGVyLmFkZENsYXNzKHRoaXMuY29udGFpbmVyLCBcInN0ZW0tXCIgKyB0aGlzLmN1cnJlbnRTdGVtLnZlcnRpY2FsKTtcbiAgICB9XG4gICAgY2xvc2VCdXR0b25Jbm5lciA9IFswLCAwXTtcbiAgICBjbG9zZUJ1dHRvbk91dGVyID0gWzAsIDBdO1xuICAgIGlmIChfX2luZGV4T2YuY2FsbCh0aGlzLm9wdGlvbnMuaGlkZVRyaWdnZXJzLCBcImNsb3NlQnV0dG9uXCIpID49IDApIHtcbiAgICAgIGNsb3NlQnV0dG9uID0gbmV3IE9wZW50aXAuSm9pbnQoKChfcmVmMSA9IHRoaXMuY3VycmVudFN0ZW0pICE9IG51bGwgPyBfcmVmMS50b1N0cmluZygpIDogdm9pZCAwKSA9PT0gXCJ0b3AgcmlnaHRcIiA/IFwidG9wIGxlZnRcIiA6IFwidG9wIHJpZ2h0XCIpO1xuICAgICAgY2xvc2VCdXR0b25Jbm5lciA9IFt0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25SYWRpdXMgKyB0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25PZmZzZXRbMF0sIHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvblJhZGl1cyArIHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFsxXV07XG4gICAgICBjbG9zZUJ1dHRvbk91dGVyID0gW3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvblJhZGl1cyAtIHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFswXSwgdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uUmFkaXVzIC0gdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uT2Zmc2V0WzFdXTtcbiAgICB9XG4gICAgY2FudmFzRGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlci5jbG9uZSh0aGlzLmRpbWVuc2lvbnMpO1xuICAgIGNhbnZhc1Bvc2l0aW9uID0gWzAsIDBdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGNhbnZhc0RpbWVuc2lvbnMud2lkdGggKz0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoICogMjtcbiAgICAgIGNhbnZhc0RpbWVuc2lvbnMuaGVpZ2h0ICs9IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCAqIDI7XG4gICAgICBjYW52YXNQb3NpdGlvblswXSAtPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICBjYW52YXNQb3NpdGlvblsxXSAtPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhZG93KSB7XG4gICAgICBjYW52YXNEaW1lbnNpb25zLndpZHRoICs9IHRoaXMub3B0aW9ucy5zaGFkb3dCbHVyICogMjtcbiAgICAgIGNhbnZhc0RpbWVuc2lvbnMud2lkdGggKz0gTWF0aC5tYXgoMCwgdGhpcy5vcHRpb25zLnNoYWRvd09mZnNldFswXSAtIHRoaXMub3B0aW9ucy5zaGFkb3dCbHVyICogMik7XG4gICAgICBjYW52YXNEaW1lbnNpb25zLmhlaWdodCArPSB0aGlzLm9wdGlvbnMuc2hhZG93Qmx1ciAqIDI7XG4gICAgICBjYW52YXNEaW1lbnNpb25zLmhlaWdodCArPSBNYXRoLm1heCgwLCB0aGlzLm9wdGlvbnMuc2hhZG93T2Zmc2V0WzFdIC0gdGhpcy5vcHRpb25zLnNoYWRvd0JsdXIgKiAyKTtcbiAgICAgIGNhbnZhc1Bvc2l0aW9uWzBdIC09IE1hdGgubWF4KDAsIHRoaXMub3B0aW9ucy5zaGFkb3dCbHVyIC0gdGhpcy5vcHRpb25zLnNoYWRvd09mZnNldFswXSk7XG4gICAgICBjYW52YXNQb3NpdGlvblsxXSAtPSBNYXRoLm1heCgwLCB0aGlzLm9wdGlvbnMuc2hhZG93Qmx1ciAtIHRoaXMub3B0aW9ucy5zaGFkb3dPZmZzZXRbMV0pO1xuICAgIH1cbiAgICBidWxnZSA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgaWYgKHRoaXMuY3VycmVudFN0ZW0pIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGVtLmxlZnQpIHtcbiAgICAgICAgYnVsZ2UubGVmdCA9IHRoaXMub3B0aW9ucy5zdGVtTGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRTdGVtLnJpZ2h0KSB7XG4gICAgICAgIGJ1bGdlLnJpZ2h0ID0gdGhpcy5vcHRpb25zLnN0ZW1MZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50U3RlbS50b3ApIHtcbiAgICAgICAgYnVsZ2UudG9wID0gdGhpcy5vcHRpb25zLnN0ZW1MZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFN0ZW0uYm90dG9tKSB7XG4gICAgICAgIGJ1bGdlLmJvdHRvbSA9IHRoaXMub3B0aW9ucy5zdGVtTGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xvc2VCdXR0b24pIHtcbiAgICAgIGlmIChjbG9zZUJ1dHRvbi5sZWZ0KSB7XG4gICAgICAgIGJ1bGdlLmxlZnQgPSBNYXRoLm1heChidWxnZS5sZWZ0LCBjbG9zZUJ1dHRvbk91dGVyWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2xvc2VCdXR0b24ucmlnaHQpIHtcbiAgICAgICAgYnVsZ2UucmlnaHQgPSBNYXRoLm1heChidWxnZS5yaWdodCwgY2xvc2VCdXR0b25PdXRlclswXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VCdXR0b24udG9wKSB7XG4gICAgICAgIGJ1bGdlLnRvcCA9IE1hdGgubWF4KGJ1bGdlLnRvcCwgY2xvc2VCdXR0b25PdXRlclsxXSk7XG4gICAgICB9IGVsc2UgaWYgKGNsb3NlQnV0dG9uLmJvdHRvbSkge1xuICAgICAgICBidWxnZS5ib3R0b20gPSBNYXRoLm1heChidWxnZS5ib3R0b20sIGNsb3NlQnV0dG9uT3V0ZXJbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjYW52YXNEaW1lbnNpb25zLndpZHRoICs9IGJ1bGdlLmxlZnQgKyBidWxnZS5yaWdodDtcbiAgICBjYW52YXNEaW1lbnNpb25zLmhlaWdodCArPSBidWxnZS50b3AgKyBidWxnZS5ib3R0b207XG4gICAgY2FudmFzUG9zaXRpb25bMF0gLT0gYnVsZ2UubGVmdDtcbiAgICBjYW52YXNQb3NpdGlvblsxXSAtPSBidWxnZS50b3A7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0ZW0gJiYgdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICBfcmVmMiA9IHRoaXMuX2dldFBhdGhTdGVtTWVhc3VyZXModGhpcy5vcHRpb25zLnN0ZW1CYXNlLCB0aGlzLm9wdGlvbnMuc3RlbUxlbmd0aCwgdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoKSwgc3RlbUxlbmd0aCA9IF9yZWYyLnN0ZW1MZW5ndGgsIHN0ZW1CYXNlID0gX3JlZjIuc3RlbUJhc2U7XG4gICAgfVxuICAgIGJhY2tncm91bmRDYW52YXMgPSB0aGlzLmFkYXB0ZXIudW53cmFwKHRoaXMuYmFja2dyb3VuZENhbnZhcyk7XG4gICAgYmFja2dyb3VuZENhbnZhcy53aWR0aCA9IGNhbnZhc0RpbWVuc2lvbnMud2lkdGg7XG4gICAgYmFja2dyb3VuZENhbnZhcy5oZWlnaHQgPSBjYW52YXNEaW1lbnNpb25zLmhlaWdodDtcbiAgICB0aGlzLmFkYXB0ZXIuY3NzKHRoaXMuYmFja2dyb3VuZENhbnZhcywge1xuICAgICAgd2lkdGg6IFwiXCIgKyBiYWNrZ3JvdW5kQ2FudmFzLndpZHRoICsgXCJweFwiLFxuICAgICAgaGVpZ2h0OiBcIlwiICsgYmFja2dyb3VuZENhbnZhcy5oZWlnaHQgKyBcInB4XCIsXG4gICAgICBsZWZ0OiBcIlwiICsgY2FudmFzUG9zaXRpb25bMF0gKyBcInB4XCIsXG4gICAgICB0b3A6IFwiXCIgKyBjYW52YXNQb3NpdGlvblsxXSArIFwicHhcIlxuICAgIH0pO1xuICAgIGN0eCA9IGJhY2tncm91bmRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBiYWNrZ3JvdW5kQ2FudmFzLndpZHRoLCBiYWNrZ3JvdW5kQ2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9nZXRDb2xvcihjdHgsIHRoaXMuZGltZW5zaW9ucywgdGhpcy5vcHRpb25zLmJhY2tncm91bmQsIHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kR3JhZGllbnRIb3Jpem9udGFsKTtcbiAgICBjdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XG4gICAgY3R4Lm1pdGVyTGltaXQgPSA1MDA7XG4gICAgaGIgPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGggLyAyO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMub3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZW1MZW5ndGggPSB0aGlzLm9wdGlvbnMuc3RlbUxlbmd0aDtcbiAgICAgIHN0ZW1CYXNlID0gdGhpcy5vcHRpb25zLnN0ZW1CYXNlO1xuICAgIH1cbiAgICBpZiAoc3RlbUJhc2UgPT0gbnVsbCkge1xuICAgICAgc3RlbUJhc2UgPSAwO1xuICAgIH1cbiAgICBkcmF3TGluZSA9IGZ1bmN0aW9uKGxlbmd0aCwgc3RlbSwgZmlyc3QpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBjdHgubW92ZVRvKE1hdGgubWF4KHN0ZW1CYXNlLCBfdGhpcy5vcHRpb25zLmJvcmRlclJhZGl1cywgY2xvc2VCdXR0b25Jbm5lclswXSkgKyAxIC0gaGIsIC1oYik7XG4gICAgICB9XG4gICAgICBpZiAoc3RlbSkge1xuICAgICAgICBjdHgubGluZVRvKGxlbmd0aCAvIDIgLSBzdGVtQmFzZSAvIDIsIC1oYik7XG4gICAgICAgIGN0eC5saW5lVG8obGVuZ3RoIC8gMiwgLXN0ZW1MZW5ndGggLSBoYik7XG4gICAgICAgIHJldHVybiBjdHgubGluZVRvKGxlbmd0aCAvIDIgKyBzdGVtQmFzZSAvIDIsIC1oYik7XG4gICAgICB9XG4gICAgfTtcbiAgICBkcmF3Q29ybmVyID0gZnVuY3Rpb24oc3RlbSwgY2xvc2VCdXR0b24sIGkpIHtcbiAgICAgIHZhciBhbmdsZTEsIGFuZ2xlMiwgaW5uZXJXaWR0aCwgb2Zmc2V0O1xuICAgICAgaWYgKHN0ZW0pIHtcbiAgICAgICAgY3R4LmxpbmVUbygtc3RlbUJhc2UgKyBoYiwgMCAtIGhiKTtcbiAgICAgICAgY3R4LmxpbmVUbyhzdGVtTGVuZ3RoICsgaGIsIC1zdGVtTGVuZ3RoIC0gaGIpO1xuICAgICAgICByZXR1cm4gY3R4LmxpbmVUbyhoYiwgc3RlbUJhc2UgLSBoYik7XG4gICAgICB9IGVsc2UgaWYgKGNsb3NlQnV0dG9uKSB7XG4gICAgICAgIG9mZnNldCA9IF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25PZmZzZXQ7XG4gICAgICAgIGlubmVyV2lkdGggPSBjbG9zZUJ1dHRvbklubmVyWzBdO1xuICAgICAgICBpZiAoaSAlIDIgIT09IDApIHtcbiAgICAgICAgICBvZmZzZXQgPSBbb2Zmc2V0WzFdLCBvZmZzZXRbMF1dO1xuICAgICAgICAgIGlubmVyV2lkdGggPSBjbG9zZUJ1dHRvbklubmVyWzFdO1xuICAgICAgICB9XG4gICAgICAgIGFuZ2xlMSA9IE1hdGguYWNvcyhvZmZzZXRbMV0gLyBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uUmFkaXVzKTtcbiAgICAgICAgYW5nbGUyID0gTWF0aC5hY29zKG9mZnNldFswXSAvIF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25SYWRpdXMpO1xuICAgICAgICBjdHgubGluZVRvKC1pbm5lcldpZHRoICsgaGIsIC1oYik7XG4gICAgICAgIHJldHVybiBjdHguYXJjKGhiIC0gb2Zmc2V0WzBdLCAtaGIgKyBvZmZzZXRbMV0sIF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25SYWRpdXMsIC0oTWF0aC5QSSAvIDIgKyBhbmdsZTEpLCBhbmdsZTIsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5saW5lVG8oLV90aGlzLm9wdGlvbnMuYm9yZGVyUmFkaXVzICsgaGIsIC1oYik7XG4gICAgICAgIHJldHVybiBjdHgucXVhZHJhdGljQ3VydmVUbyhoYiwgLWhiLCBoYiwgX3RoaXMub3B0aW9ucy5ib3JkZXJSYWRpdXMgLSBoYik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjdHgudHJhbnNsYXRlKC1jYW52YXNQb3NpdGlvblswXSwgLWNhbnZhc1Bvc2l0aW9uWzFdKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3JuZXJTdGVtLCBpLCBsaW5lTGVuZ3RoLCBsaW5lU3RlbSwgcG9zaXRpb25JZHgsIHBvc2l0aW9uWCwgcG9zaXRpb25ZLCByb3RhdGlvbiwgX2osIF9yZWYzLCBfcmVzdWx0cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYzID0gT3BlbnRpcC5wb3NpdGlvbnMubGVuZ3RoIC8gMjsgMCA8PSBfcmVmMyA/IF9qIDwgX3JlZjMgOiBfaiA+IF9yZWYzOyBpID0gMCA8PSBfcmVmMyA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICAgIHBvc2l0aW9uSWR4ID0gaSAqIDI7XG4gICAgICAgIHBvc2l0aW9uWCA9IGkgPT09IDAgfHwgaSA9PT0gMyA/IDAgOiBfdGhpcy5kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICBwb3NpdGlvblkgPSBpIDwgMiA/IDAgOiBfdGhpcy5kaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgcm90YXRpb24gPSAoTWF0aC5QSSAvIDIpICogaTtcbiAgICAgICAgbGluZUxlbmd0aCA9IGkgJSAyID09PSAwID8gX3RoaXMuZGltZW5zaW9ucy53aWR0aCA6IF90aGlzLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICBsaW5lU3RlbSA9IG5ldyBPcGVudGlwLkpvaW50KE9wZW50aXAucG9zaXRpb25zW3Bvc2l0aW9uSWR4XSk7XG4gICAgICAgIGNvcm5lclN0ZW0gPSBuZXcgT3BlbnRpcC5Kb2ludChPcGVudGlwLnBvc2l0aW9uc1twb3NpdGlvbklkeCArIDFdKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShwb3NpdGlvblgsIHBvc2l0aW9uWSk7XG4gICAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xuICAgICAgICBkcmF3TGluZShsaW5lTGVuZ3RoLCBsaW5lU3RlbS5lcWwoX3RoaXMuY3VycmVudFN0ZW0pLCBpID09PSAwKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShsaW5lTGVuZ3RoLCAwKTtcbiAgICAgICAgZHJhd0Nvcm5lcihjb3JuZXJTdGVtLmVxbChfdGhpcy5jdXJyZW50U3RlbSksIGNvcm5lclN0ZW0uZXFsKGNsb3NlQnV0dG9uKSwgaSk7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goY3R4LnJlc3RvcmUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSkoKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNoYWRvdykge1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5vcHRpb25zLnNoYWRvd0NvbG9yO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLm9wdGlvbnMuc2hhZG93Qmx1cjtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdGhpcy5vcHRpb25zLnNoYWRvd09mZnNldFswXTtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdGhpcy5vcHRpb25zLnNoYWRvd09mZnNldFsxXTtcbiAgICB9XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAoY2xvc2VCdXR0b24pIHtcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcm9zc0NlbnRlciwgY3Jvc3NIZWlnaHQsIGNyb3NzV2lkdGgsIGhjcywgbGlua0NlbnRlcjtcbiAgICAgICAgY3Jvc3NXaWR0aCA9IGNyb3NzSGVpZ2h0ID0gX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvblJhZGl1cyAqIDI7XG4gICAgICAgIGlmIChjbG9zZUJ1dHRvbi50b1N0cmluZygpID09PSBcInRvcCByaWdodFwiKSB7XG4gICAgICAgICAgbGlua0NlbnRlciA9IFtfdGhpcy5kaW1lbnNpb25zLndpZHRoIC0gX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFswXSwgX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFsxXV07XG4gICAgICAgICAgY3Jvc3NDZW50ZXIgPSBbbGlua0NlbnRlclswXSArIGhiLCBsaW5rQ2VudGVyWzFdIC0gaGJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmtDZW50ZXIgPSBbX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFswXSwgX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbk9mZnNldFsxXV07XG4gICAgICAgICAgY3Jvc3NDZW50ZXIgPSBbbGlua0NlbnRlclswXSAtIGhiLCBsaW5rQ2VudGVyWzFdIC0gaGJdO1xuICAgICAgICB9XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY3Jvc3NDZW50ZXJbMF0sIGNyb3NzQ2VudGVyWzFdKTtcbiAgICAgICAgaGNzID0gX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbkNyb3NzU2l6ZSAvIDI7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gX3RoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbkNyb3NzQ29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uQ3Jvc3NMaW5lV2lkdGg7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xuICAgICAgICBjdHgubW92ZVRvKC1oY3MsIC1oY3MpO1xuICAgICAgICBjdHgubGluZVRvKGhjcywgaGNzKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oaGNzLCAtaGNzKTtcbiAgICAgICAgY3R4LmxpbmVUbygtaGNzLCBoY3MpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcy5hZGFwdGVyLmNzcyhfdGhpcy5jbG9zZUJ1dHRvbkVsZW1lbnQsIHtcbiAgICAgICAgICBsZWZ0OiBcIlwiICsgKGxpbmtDZW50ZXJbMF0gLSBoY3MgLSBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uTGlua092ZXJzY2FuKSArIFwicHhcIixcbiAgICAgICAgICB0b3A6IFwiXCIgKyAobGlua0NlbnRlclsxXSAtIGhjcyAtIF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25MaW5rT3ZlcnNjYW4pICsgXCJweFwiLFxuICAgICAgICAgIHdpZHRoOiBcIlwiICsgKF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25Dcm9zc1NpemUgKyBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uTGlua092ZXJzY2FuICogMikgKyBcInB4XCIsXG4gICAgICAgICAgaGVpZ2h0OiBcIlwiICsgKF90aGlzLm9wdGlvbnMuY2xvc2VCdXR0b25Dcm9zc1NpemUgKyBfdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uTGlua092ZXJzY2FuICogMikgKyBcInB4XCJcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH1cbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5fZ2V0UGF0aFN0ZW1NZWFzdXJlcyA9IGZ1bmN0aW9uKG91dGVyU3RlbUJhc2UsIG91dGVyU3RlbUxlbmd0aCwgYm9yZGVyV2lkdGgpIHtcbiAgICB2YXIgYW5nbGUsIGRpc3RhbmNlQmV0d2VlblRpcHMsIGhhbGZBbmdsZSwgaGIsIHJob21idXNTaWRlLCBzdGVtQmFzZSwgc3RlbUxlbmd0aDtcbiAgICBoYiA9IGJvcmRlcldpZHRoIC8gMjtcbiAgICBoYWxmQW5nbGUgPSBNYXRoLmF0YW4oKG91dGVyU3RlbUJhc2UgLyAyKSAvIG91dGVyU3RlbUxlbmd0aCk7XG4gICAgYW5nbGUgPSBoYWxmQW5nbGUgKiAyO1xuICAgIHJob21idXNTaWRlID0gaGIgLyBNYXRoLnNpbihhbmdsZSk7XG4gICAgZGlzdGFuY2VCZXR3ZWVuVGlwcyA9IDIgKiByaG9tYnVzU2lkZSAqIE1hdGguY29zKGhhbGZBbmdsZSk7XG4gICAgc3RlbUxlbmd0aCA9IGhiICsgb3V0ZXJTdGVtTGVuZ3RoIC0gZGlzdGFuY2VCZXR3ZWVuVGlwcztcbiAgICBpZiAoc3RlbUxlbmd0aCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvcnJ5IGJ1dCB5b3VyIHN0ZW1MZW5ndGggLyBzdGVtQmFzZSByYXRpbyBpcyBzdHJhbmdlLlwiKTtcbiAgICB9XG4gICAgc3RlbUJhc2UgPSAoTWF0aC50YW4oaGFsZkFuZ2xlKSAqIHN0ZW1MZW5ndGgpICogMjtcbiAgICByZXR1cm4ge1xuICAgICAgc3RlbUxlbmd0aDogc3RlbUxlbmd0aCxcbiAgICAgIHN0ZW1CYXNlOiBzdGVtQmFzZVxuICAgIH07XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX2dldENvbG9yID0gZnVuY3Rpb24oY3R4LCBkaW1lbnNpb25zLCBjb2xvciwgaG9yaXpvbnRhbCkge1xuICAgIHZhciBjb2xvclN0b3AsIGdyYWRpZW50LCBpLCBfaSwgX2xlbjtcbiAgICBpZiAoaG9yaXpvbnRhbCA9PSBudWxsKSB7XG4gICAgICBob3Jpem9udGFsID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIGRpbWVuc2lvbnMud2lkdGgsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBkaW1lbnNpb25zLmhlaWdodCk7XG4gICAgfVxuICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IGNvbG9yLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgY29sb3JTdG9wID0gY29sb3JbaV07XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoY29sb3JTdG9wWzBdLCBjb2xvclN0b3BbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhZGllbnQ7XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX3NlYXJjaEFuZEFjdGl2YXRlQ2xvc2VCdXR0b25zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZW1lbnQsIF9pLCBfbGVuLCBfcmVmO1xuICAgIF9yZWYgPSB0aGlzLmFkYXB0ZXIuZmluZEFsbCh0aGlzLmNvbnRhaW5lciwgXCIuXCIgKyB0aGlzW1wiY2xhc3NcIl0uY2xvc2UpO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbWVudCA9IF9yZWZbX2ldO1xuICAgICAgdGhpcy5oaWRlVHJpZ2dlcnMucHVzaCh7XG4gICAgICAgIGVsZW1lbnQ6IHRoaXMuYWRhcHRlci53cmFwKGVsZW1lbnQpLFxuICAgICAgICBldmVudDogXCJjbGlja1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudE9ic2VydmVycy5zaG93aW5nKSB7XG4gICAgICB0aGlzLl9zZXR1cE9ic2VydmVycyhcIi1zaG93aW5nXCIsIFwic2hvd2luZ1wiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudE9ic2VydmVycy52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0dXBPYnNlcnZlcnMoXCItdmlzaWJsZVwiLCBcInZpc2libGVcIik7XG4gICAgfVxuICB9O1xuXG4gIE9wZW50aXAucHJvdG90eXBlLl9hY3RpdmF0ZUZpcnN0SW5wdXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5wdXQ7XG4gICAgaW5wdXQgPSB0aGlzLmFkYXB0ZXIudW53cmFwKHRoaXMuYWRhcHRlci5maW5kKHRoaXMuY29udGFpbmVyLCBcImlucHV0LCB0ZXh0YXJlYVwiKSk7XG4gICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0eXBlb2YgaW5wdXQuZm9jdXMgPT09IFwiZnVuY3Rpb25cIiA/IGlucHV0LmZvY3VzKCkgOiB2b2lkIDAgOiB2b2lkIDA7XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX2ZvbGxvd01vdXNlUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5maXhlZCkge1xuICAgICAgcmV0dXJuIE9wZW50aXAuX29ic2VydmVNb3VzZVBvc2l0aW9uKHRoaXMuYm91bmQucmVwb3NpdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIE9wZW50aXAucHJvdG90eXBlLl9zdG9wRm9sbG93aW5nTW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmZpeGVkKSB7XG4gICAgICByZXR1cm4gT3BlbnRpcC5fc3RvcE9ic2VydmluZ01vdXNlUG9zaXRpb24odGhpcy5ib3VuZC5yZXBvc2l0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX2NsZWFyU2hvd1RpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0SWQpO1xuICB9O1xuXG4gIE9wZW50aXAucHJvdG90eXBlLl9jbGVhckhpZGVUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dElkKTtcbiAgfTtcblxuICBPcGVudGlwLnByb3RvdHlwZS5fY2xlYXJUaW1lb3V0cyA9IGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl92aXNpYmlsaXR5U3RhdGVUaW1lb3V0SWQpO1xuICAgIHRoaXMuX2NsZWFyU2hvd1RpbWVvdXQoKTtcbiAgICByZXR1cm4gdGhpcy5fY2xlYXJIaWRlVGltZW91dCgpO1xuICB9O1xuXG4gIE9wZW50aXAucHJvdG90eXBlLl90cmlnZ2VyRWxlbWVudEV4aXN0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbDtcbiAgICBlbCA9IHRoaXMuYWRhcHRlci51bndyYXAodGhpcy50cmlnZ2VyRWxlbWVudCk7XG4gICAgd2hpbGUgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChlbC5wYXJlbnROb2RlLnRhZ05hbWUgPT09IFwiQk9EWVwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX2xvYWRBamF4ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5sb2FkaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmFkYXB0ZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXNbXCJjbGFzc1wiXS5sb2FkaW5nKTtcbiAgICB0aGlzLnNldENvbnRlbnQoXCJcIik7XG4gICAgdGhpcy5kZWJ1ZyhcIkxvYWRpbmcgY29udGVudCBmcm9tIFwiICsgdGhpcy5vcHRpb25zLmFqYXgpO1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuYWpheCh7XG4gICAgICB1cmw6IHRoaXMub3B0aW9ucy5hamF4LFxuICAgICAgbWV0aG9kOiB0aGlzLm9wdGlvbnMuYWpheE1ldGhvZCxcbiAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24ocmVzcG9uc2VUZXh0KSB7XG4gICAgICAgIF90aGlzLmRlYnVnKFwiTG9hZGluZyBzdWNjZXNzZnVsLlwiKTtcbiAgICAgICAgX3RoaXMuYWRhcHRlci5yZW1vdmVDbGFzcyhfdGhpcy5jb250YWluZXIsIF90aGlzW1wiY2xhc3NcIl0ubG9hZGluZyk7XG4gICAgICAgIHJldHVybiBfdGhpcy5zZXRDb250ZW50KHJlc3BvbnNlVGV4dCk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgIG1lc3NhZ2UgPSBfdGhpcy5vcHRpb25zLmFqYXhFcnJvck1lc3NhZ2U7XG4gICAgICAgIF90aGlzLmRlYnVnKG1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgX3RoaXMuc2V0Q29udGVudChtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzLmFkYXB0ZXIuYWRkQ2xhc3MoX3RoaXMuY29udGFpbmVyLCBfdGhpc1tcImNsYXNzXCJdLmFqYXhFcnJvcik7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLmFkYXB0ZXIucmVtb3ZlQ2xhc3MoX3RoaXMuY29udGFpbmVyLCBfdGhpc1tcImNsYXNzXCJdLmxvYWRpbmcpO1xuICAgICAgICBfdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIF90aGlzLl9zZWFyY2hBbmRBY3RpdmF0ZUNsb3NlQnV0dG9ucygpO1xuICAgICAgICBfdGhpcy5fYWN0aXZhdGVGaXJzdElucHV0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZXBvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX2Vuc3VyZVRyaWdnZXJFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl90cmlnZ2VyRWxlbWVudEV4aXN0cygpKSB7XG4gICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wRW5zdXJlVHJpZ2dlckVsZW1lbnQoKTtcbiAgICB9XG4gIH07XG5cbiAgT3BlbnRpcC5wcm90b3R5cGUuX2Vuc3VyZVRyaWdnZXJFbGVtZW50SW50ZXJ2YWwgPSAxMDAwO1xuXG4gIE9wZW50aXAucHJvdG90eXBlLl9zdGFydEVuc3VyZVRyaWdnZXJFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5fZW5zdXJlVHJpZ2dlckVsZW1lbnRUaW1lb3V0SWQgPSBzZXRJbnRlcnZhbCgoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX2Vuc3VyZVRyaWdnZXJFbGVtZW50KCk7XG4gICAgfSksIHRoaXMuX2Vuc3VyZVRyaWdnZXJFbGVtZW50SW50ZXJ2YWwpO1xuICB9O1xuXG4gIE9wZW50aXAucHJvdG90eXBlLl9zdG9wRW5zdXJlVHJpZ2dlckVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY2xlYXJJbnRlcnZhbCh0aGlzLl9lbnN1cmVUcmlnZ2VyRWxlbWVudFRpbWVvdXRJZCk7XG4gIH07XG5cbiAgcmV0dXJuIE9wZW50aXA7XG5cbn0pKCk7XG5cbnZlbmRvcnMgPSBbXCJraHRtbFwiLCBcIm1zXCIsIFwib1wiLCBcIm1velwiLCBcIndlYmtpdFwiXTtcblxuT3BlbnRpcC5wcm90b3R5cGUuc2V0Q3NzM1N0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGVzKSB7XG4gIHZhciBwcm9wLCB2YWx1ZSwgdmVuZG9yLCB2ZW5kb3JQcm9wLCBfcmVzdWx0cztcbiAgZWxlbWVudCA9IHRoaXMuYWRhcHRlci51bndyYXAoZWxlbWVudCk7XG4gIF9yZXN1bHRzID0gW107XG4gIGZvciAocHJvcCBpbiBzdHlsZXMpIHtcbiAgICBpZiAoIV9faGFzUHJvcC5jYWxsKHN0eWxlcywgcHJvcCkpIGNvbnRpbnVlO1xuICAgIHZhbHVlID0gc3R5bGVzW3Byb3BdO1xuICAgIGlmIChlbGVtZW50LnN0eWxlW3Byb3BdICE9IG51bGwpIHtcbiAgICAgIF9yZXN1bHRzLnB1c2goZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdHMucHVzaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHMxO1xuICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB2ZW5kb3JzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgdmVuZG9yID0gdmVuZG9yc1tfaV07XG4gICAgICAgICAgdmVuZG9yUHJvcCA9IFwiXCIgKyAodGhpcy51Y2ZpcnN0KHZlbmRvcikpICsgKHRoaXMudWNmaXJzdChwcm9wKSk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQuc3R5bGVbdmVuZG9yUHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2goZWxlbWVudC5zdHlsZVt2ZW5kb3JQcm9wXSA9IHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMxLnB1c2godm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX3Jlc3VsdHM7XG59O1xuXG5PcGVudGlwLnByb3RvdHlwZS5kZWZlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZnVuYywgMCk7XG59O1xuXG5PcGVudGlwLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oZnVuYywgc2Vjb25kcykge1xuICByZXR1cm4gc2V0VGltZW91dChmdW5jLCBzZWNvbmRzID8gc2Vjb25kcyAqIDEwMDAgOiAwKTtcbn07XG5cbk9wZW50aXAucHJvdG90eXBlLnVjZmlyc3QgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn07XG5cbk9wZW50aXAucHJvdG90eXBlLmRhc2hlcml6ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24oXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIFwiLVwiICsgKGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpKTtcbiAgfSk7XG59O1xuXG5tb3VzZVBvc2l0aW9uT2JzZXJ2ZXJzID0gW107XG5cbm1vdXNlUG9zaXRpb24gPSB7XG4gIHg6IDAsXG4gIHk6IDBcbn07XG5cbm1vdXNlTW92ZWQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBvYnNlcnZlciwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICBtb3VzZVBvc2l0aW9uID0gT3BlbnRpcC5hZGFwdGVyLm1vdXNlUG9zaXRpb24oZSk7XG4gIF9yZXN1bHRzID0gW107XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gbW91c2VQb3NpdGlvbk9ic2VydmVycy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIG9ic2VydmVyID0gbW91c2VQb3NpdGlvbk9ic2VydmVyc1tfaV07XG4gICAgX3Jlc3VsdHMucHVzaChvYnNlcnZlcigpKTtcbiAgfVxuICByZXR1cm4gX3Jlc3VsdHM7XG59O1xuXG5PcGVudGlwLmZvbGxvd01vdXNlUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE9wZW50aXAuYWRhcHRlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZWQpO1xufTtcblxuT3BlbnRpcC5fb2JzZXJ2ZU1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbihvYnNlcnZlcikge1xuICByZXR1cm4gbW91c2VQb3NpdGlvbk9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbn07XG5cbk9wZW50aXAuX3N0b3BPYnNlcnZpbmdNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24ocmVtb3ZlT2JzZXJ2ZXIpIHtcbiAgdmFyIG9ic2VydmVyO1xuICByZXR1cm4gbW91c2VQb3NpdGlvbk9ic2VydmVycyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBtb3VzZVBvc2l0aW9uT2JzZXJ2ZXJzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBvYnNlcnZlciA9IG1vdXNlUG9zaXRpb25PYnNlcnZlcnNbX2ldO1xuICAgICAgaWYgKG9ic2VydmVyICE9PSByZW1vdmVPYnNlcnZlcikge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKG9ic2VydmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9KSgpO1xufTtcblxuT3BlbnRpcC5Kb2ludCA9IChmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBKb2ludChwb2ludGVyU3RyaW5nKSB7XG4gICAgaWYgKHBvaW50ZXJTdHJpbmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocG9pbnRlclN0cmluZyBpbnN0YW5jZW9mIE9wZW50aXAuSm9pbnQpIHtcbiAgICAgIHBvaW50ZXJTdHJpbmcgPSBwb2ludGVyU3RyaW5nLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0KHBvaW50ZXJTdHJpbmcpO1xuICAgIHRoaXM7XG5cbiAgfVxuXG4gIEpvaW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnNldEhvcml6b250YWwoc3RyaW5nKTtcbiAgICB0aGlzLnNldFZlcnRpY2FsKHN0cmluZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgSm9pbnQucHJvdG90eXBlLnNldEhvcml6b250YWwgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgaSwgdmFsaWQsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZXN1bHRzO1xuICAgIHZhbGlkID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdmFsaWQubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSB2YWxpZFtfaV07XG4gICAgICBpZiAofnN0cmluZy5pbmRleE9mKGkpKSB7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGkudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaG9yaXpvbnRhbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmhvcml6b250YWwgPSBcImNlbnRlclwiO1xuICAgIH1cbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IHZhbGlkLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgaSA9IHZhbGlkW19qXTtcbiAgICAgIF9yZXN1bHRzLnB1c2godGhpc1tpXSA9IHRoaXMuaG9yaXpvbnRhbCA9PT0gaSA/IGkgOiB2b2lkIDApO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgSm9pbnQucHJvdG90eXBlLnNldFZlcnRpY2FsID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGksIHZhbGlkLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVzdWx0cztcbiAgICB2YWxpZCA9IFtcInRvcFwiLCBcIm1pZGRsZVwiLCBcImJvdHRvbVwiXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHZhbGlkLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpID0gdmFsaWRbX2ldO1xuICAgICAgaWYgKH5zdHJpbmcuaW5kZXhPZihpKSkge1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gaS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy52ZXJ0aWNhbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLnZlcnRpY2FsID0gXCJtaWRkbGVcIjtcbiAgICB9XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSB2YWxpZC5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgIGkgPSB2YWxpZFtfal07XG4gICAgICBfcmVzdWx0cy5wdXNoKHRoaXNbaV0gPSB0aGlzLnZlcnRpY2FsID09PSBpID8gaSA6IHZvaWQgMCk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBKb2ludC5wcm90b3R5cGUuZXFsID0gZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHJldHVybiAocG9pbnRlciAhPSBudWxsKSAmJiB0aGlzLmhvcml6b250YWwgPT09IHBvaW50ZXIuaG9yaXpvbnRhbCAmJiB0aGlzLnZlcnRpY2FsID09PSBwb2ludGVyLnZlcnRpY2FsO1xuICB9O1xuXG4gIEpvaW50LnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZsaXBwZWRJbmRleCwgcG9zaXRpb25JZHg7XG4gICAgcG9zaXRpb25JZHggPSBPcGVudGlwLnBvc2l0aW9uW3RoaXMudG9TdHJpbmcodHJ1ZSldO1xuICAgIGZsaXBwZWRJbmRleCA9IChwb3NpdGlvbklkeCArIDQpICUgODtcbiAgICB0aGlzLnNldChPcGVudGlwLnBvc2l0aW9uc1tmbGlwcGVkSW5kZXhdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBKb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihjYW1lbGl6ZWQpIHtcbiAgICB2YXIgaG9yaXpvbnRhbCwgdmVydGljYWw7XG4gICAgaWYgKGNhbWVsaXplZCA9PSBudWxsKSB7XG4gICAgICBjYW1lbGl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmVydGljYWwgPSB0aGlzLnZlcnRpY2FsID09PSBcIm1pZGRsZVwiID8gXCJcIiA6IHRoaXMudmVydGljYWw7XG4gICAgaG9yaXpvbnRhbCA9IHRoaXMuaG9yaXpvbnRhbCA9PT0gXCJjZW50ZXJcIiA/IFwiXCIgOiB0aGlzLmhvcml6b250YWw7XG4gICAgaWYgKHZlcnRpY2FsICYmIGhvcml6b250YWwpIHtcbiAgICAgIGlmIChjYW1lbGl6ZWQpIHtcbiAgICAgICAgaG9yaXpvbnRhbCA9IE9wZW50aXAucHJvdG90eXBlLnVjZmlyc3QoaG9yaXpvbnRhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3Jpem9udGFsID0gXCIgXCIgKyBob3Jpem9udGFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIiArIHZlcnRpY2FsICsgaG9yaXpvbnRhbDtcbiAgfTtcblxuICByZXR1cm4gSm9pbnQ7XG5cbn0pKCk7XG5cbk9wZW50aXAucHJvdG90eXBlLl9wb3NpdGlvbnNFcXVhbCA9IGZ1bmN0aW9uKHBvc0EsIHBvc0IpIHtcbiAgcmV0dXJuIChwb3NBICE9IG51bGwpICYmIChwb3NCICE9IG51bGwpICYmIHBvc0EubGVmdCA9PT0gcG9zQi5sZWZ0ICYmIHBvc0EudG9wID09PSBwb3NCLnRvcDtcbn07XG5cbk9wZW50aXAucHJvdG90eXBlLl9kaW1lbnNpb25zRXF1YWwgPSBmdW5jdGlvbihkaW1BLCBkaW1CKSB7XG4gIHJldHVybiAoZGltQSAhPSBudWxsKSAmJiAoZGltQiAhPSBudWxsKSAmJiBkaW1BLndpZHRoID09PSBkaW1CLndpZHRoICYmIGRpbUEuaGVpZ2h0ID09PSBkaW1CLmhlaWdodDtcbn07XG5cbk9wZW50aXAucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhcmdzO1xuICBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgaWYgKE9wZW50aXAuZGVidWcgJiYgKCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlICE9PSBudWxsID8gY29uc29sZS5kZWJ1ZyA6IHZvaWQgMCkgIT0gbnVsbCkpIHtcbiAgICBhcmdzLnVuc2hpZnQoXCIjXCIgKyB0aGlzLmlkICsgXCIgfFwiKTtcbiAgICByZXR1cm4gY29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgfVxufTtcblxuT3BlbnRpcC5maW5kRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFkYXB0ZXIsIGNvbnRlbnQsIGVsZW1lbnQsIG9wdGlvbk5hbWUsIG9wdGlvblZhbHVlLCBvcHRpb25zLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gIGFkYXB0ZXIgPSBPcGVudGlwLmFkYXB0ZXI7XG4gIF9yZWYgPSBhZGFwdGVyLmZpbmRBbGwoZG9jdW1lbnQuYm9keSwgXCJbZGF0YS1vdF1cIik7XG4gIF9yZXN1bHRzID0gW107XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGVsZW1lbnQgPSBfcmVmW19pXTtcbiAgICBvcHRpb25zID0ge307XG4gICAgY29udGVudCA9IGFkYXB0ZXIuZGF0YShlbGVtZW50LCBcIm90XCIpO1xuICAgIGlmIChjb250ZW50ID09PSBcIlwiIHx8IGNvbnRlbnQgPT09IFwidHJ1ZVwiIHx8IGNvbnRlbnQgPT09IFwieWVzXCIpIHtcbiAgICAgIGNvbnRlbnQgPSBhZGFwdGVyLmF0dHIoZWxlbWVudCwgXCJ0aXRsZVwiKTtcbiAgICAgIGFkYXB0ZXIuYXR0cihlbGVtZW50LCBcInRpdGxlXCIsIFwiXCIpO1xuICAgIH1cbiAgICBjb250ZW50ID0gY29udGVudCB8fCBcIlwiO1xuICAgIGZvciAob3B0aW9uTmFtZSBpbiBPcGVudGlwLnN0eWxlcy5zdGFuZGFyZCkge1xuICAgICAgb3B0aW9uVmFsdWUgPSBhZGFwdGVyLmRhdGEoZWxlbWVudCwgXCJvdFwiICsgKE9wZW50aXAucHJvdG90eXBlLnVjZmlyc3Qob3B0aW9uTmFtZSkpKTtcbiAgICAgIGlmIChvcHRpb25WYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gXCJ5ZXNcIiB8fCBvcHRpb25WYWx1ZSA9PT0gXCJ0cnVlXCIgfHwgb3B0aW9uVmFsdWUgPT09IFwib25cIikge1xuICAgICAgICAgIG9wdGlvblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25WYWx1ZSA9PT0gXCJub1wiIHx8IG9wdGlvblZhbHVlID09PSBcImZhbHNlXCIgfHwgb3B0aW9uVmFsdWUgPT09IFwib2ZmXCIpIHtcbiAgICAgICAgICBvcHRpb25WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSBvcHRpb25WYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3Jlc3VsdHMucHVzaChuZXcgT3BlbnRpcChlbGVtZW50LCBjb250ZW50LCBvcHRpb25zKSk7XG4gIH1cbiAgcmV0dXJuIF9yZXN1bHRzO1xufTtcblxuT3BlbnRpcC52ZXJzaW9uID0gXCIyLjQuNlwiO1xuXG5PcGVudGlwLmRlYnVnID0gZmFsc2U7XG5cbk9wZW50aXAubGFzdElkID0gMDtcblxuT3BlbnRpcC5sYXN0WkluZGV4ID0gMTAwO1xuXG5PcGVudGlwLnRpcHMgPSBbXTtcblxuT3BlbnRpcC5fYWJvcnRTaG93aW5nR3JvdXAgPSBmdW5jdGlvbihncm91cCwgb3JpZ2luYXRpbmdPcGVudGlwKSB7XG4gIHZhciBvcGVudGlwLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gIF9yZWYgPSBPcGVudGlwLnRpcHM7XG4gIF9yZXN1bHRzID0gW107XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIG9wZW50aXAgPSBfcmVmW19pXTtcbiAgICBpZiAob3BlbnRpcCAhPT0gb3JpZ2luYXRpbmdPcGVudGlwICYmIG9wZW50aXAub3B0aW9ucy5ncm91cCA9PT0gZ3JvdXApIHtcbiAgICAgIF9yZXN1bHRzLnB1c2gob3BlbnRpcC5fYWJvcnRTaG93aW5nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBfcmVzdWx0cztcbn07XG5cbk9wZW50aXAuX2hpZGVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcmlnaW5hdGluZ09wZW50aXApIHtcbiAgdmFyIG9wZW50aXAsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgX3JlZiA9IE9wZW50aXAudGlwcztcbiAgX3Jlc3VsdHMgPSBbXTtcbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgb3BlbnRpcCA9IF9yZWZbX2ldO1xuICAgIGlmIChvcGVudGlwICE9PSBvcmlnaW5hdGluZ09wZW50aXAgJiYgb3BlbnRpcC5vcHRpb25zLmdyb3VwID09PSBncm91cCkge1xuICAgICAgX3Jlc3VsdHMucHVzaChvcGVudGlwLmhpZGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9yZXN1bHRzO1xufTtcblxuT3BlbnRpcC5hZGFwdGVycyA9IHt9O1xuXG5PcGVudGlwLmFkYXB0ZXIgPSBudWxsO1xuXG5maXJzdEFkYXB0ZXIgPSB0cnVlO1xuXG5PcGVudGlwLmFkZEFkYXB0ZXIgPSBmdW5jdGlvbihhZGFwdGVyKSB7XG4gIE9wZW50aXAuYWRhcHRlcnNbYWRhcHRlci5uYW1lXSA9IGFkYXB0ZXI7XG4gIGlmIChmaXJzdEFkYXB0ZXIpIHtcbiAgICBPcGVudGlwLmFkYXB0ZXIgPSBhZGFwdGVyO1xuICAgIGFkYXB0ZXIuZG9tUmVhZHkoT3BlbnRpcC5maW5kRWxlbWVudHMpO1xuICAgIGFkYXB0ZXIuZG9tUmVhZHkoT3BlbnRpcC5mb2xsb3dNb3VzZVBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3RBZGFwdGVyID0gZmFsc2U7XG4gIH1cbn07XG5cbk9wZW50aXAucG9zaXRpb25zID0gW1widG9wXCIsIFwidG9wUmlnaHRcIiwgXCJyaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tXCIsIFwiYm90dG9tTGVmdFwiLCBcImxlZnRcIiwgXCJ0b3BMZWZ0XCJdO1xuXG5PcGVudGlwLnBvc2l0aW9uID0ge307XG5cbl9yZWYgPSBPcGVudGlwLnBvc2l0aW9ucztcbmZvciAoaSA9IF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IGkgPSArK19pKSB7XG4gIHBvc2l0aW9uID0gX3JlZltpXTtcbiAgT3BlbnRpcC5wb3NpdGlvbltwb3NpdGlvbl0gPSBpO1xufVxuXG5PcGVudGlwLnN0eWxlcyA9IHtcbiAgc3RhbmRhcmQ6IHtcbiAgICBcImV4dGVuZHNcIjogbnVsbCxcbiAgICB0aXRsZTogdm9pZCAwLFxuICAgIGVzY2FwZVRpdGxlOiB0cnVlLFxuICAgIGVzY2FwZUNvbnRlbnQ6IGZhbHNlLFxuICAgIGNsYXNzTmFtZTogXCJzdGFuZGFyZFwiLFxuICAgIHN0ZW06IHRydWUsXG4gICAgZGVsYXk6IG51bGwsXG4gICAgaGlkZURlbGF5OiAwLjEsXG4gICAgZml4ZWQ6IGZhbHNlLFxuICAgIHNob3dPbjogXCJtb3VzZW92ZXJcIixcbiAgICBoaWRlVHJpZ2dlcjogXCJ0cmlnZ2VyXCIsXG4gICAgaGlkZVRyaWdnZXJzOiBbXSxcbiAgICBoaWRlT246IG51bGwsXG4gICAgcmVtb3ZlRWxlbWVudHNPbkhpZGU6IGZhbHNlLFxuICAgIG9mZnNldDogWzAsIDBdLFxuICAgIGNvbnRhaW5JblZpZXdwb3J0OiB0cnVlLFxuICAgIGF1dG9PZmZzZXQ6IHRydWUsXG4gICAgc2hvd0VmZmVjdDogXCJhcHBlYXJcIixcbiAgICBoaWRlRWZmZWN0OiBcImZhZGVcIixcbiAgICBzaG93RWZmZWN0RHVyYXRpb246IDAuMyxcbiAgICBoaWRlRWZmZWN0RHVyYXRpb246IDAuMixcbiAgICBzdGVtTGVuZ3RoOiA1LFxuICAgIHN0ZW1CYXNlOiA4LFxuICAgIHRpcEpvaW50OiBcInRvcCBsZWZ0XCIsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRhcmdldEpvaW50OiBudWxsLFxuICAgIGNhY2hlOiB0cnVlLFxuICAgIGFqYXg6IGZhbHNlLFxuICAgIGFqYXhNZXRob2Q6IFwiR0VUXCIsXG4gICAgYWpheEVycm9yTWVzc2FnZTogXCJUaGVyZSB3YXMgYSBwcm9ibGVtIGRvd25sb2FkaW5nIHRoZSBjb250ZW50LlwiLFxuICAgIGdyb3VwOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGJhY2tncm91bmQ6IFwiI2ZmZjE4ZlwiLFxuICAgIGJhY2tncm91bmRHcmFkaWVudEhvcml6b250YWw6IGZhbHNlLFxuICAgIGNsb3NlQnV0dG9uT2Zmc2V0OiBbNSwgNV0sXG4gICAgY2xvc2VCdXR0b25SYWRpdXM6IDcsXG4gICAgY2xvc2VCdXR0b25Dcm9zc1NpemU6IDQsXG4gICAgY2xvc2VCdXR0b25Dcm9zc0NvbG9yOiBcIiNkMmMzNWJcIixcbiAgICBjbG9zZUJ1dHRvbkNyb3NzTGluZVdpZHRoOiAxLjUsXG4gICAgY2xvc2VCdXR0b25MaW5rT3ZlcnNjYW46IDYsXG4gICAgYm9yZGVyUmFkaXVzOiA1LFxuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGJvcmRlckNvbG9yOiBcIiNmMmUzN2JcIixcbiAgICBzaGFkb3c6IHRydWUsXG4gICAgc2hhZG93Qmx1cjogMTAsXG4gICAgc2hhZG93T2Zmc2V0OiBbMywgM10sXG4gICAgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAwLjEpXCJcbiAgfSxcbiAgZ2xhc3M6IHtcbiAgICBcImV4dGVuZHNcIjogXCJzdGFuZGFyZFwiLFxuICAgIGNsYXNzTmFtZTogXCJnbGFzc1wiLFxuICAgIGJhY2tncm91bmQ6IFtbMCwgXCJyZ2JhKDI1MiwgMjUyLCAyNTIsIDAuOClcIl0sIFswLjUsIFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpXCJdLCBbMC41LCBcInJnYmEoMjUwLCAyNTAsIDI1MCwgMC45KVwiXSwgWzEsIFwicmdiYSgyNDUsIDI0NSwgMjQ1LCAwLjkpXCJdXSxcbiAgICBib3JkZXJDb2xvcjogXCIjZWVlXCIsXG4gICAgY2xvc2VCdXR0b25Dcm9zc0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC4yKVwiLFxuICAgIGJvcmRlclJhZGl1czogMTUsXG4gICAgY2xvc2VCdXR0b25SYWRpdXM6IDEwLFxuICAgIGNsb3NlQnV0dG9uT2Zmc2V0OiBbOCwgOF1cbiAgfSxcbiAgZGFyazoge1xuICAgIFwiZXh0ZW5kc1wiOiBcInN0YW5kYXJkXCIsXG4gICAgY2xhc3NOYW1lOiBcImRhcmtcIixcbiAgICBib3JkZXJSYWRpdXM6IDEzLFxuICAgIGJvcmRlckNvbG9yOiBcIiM0NDRcIixcbiAgICBjbG9zZUJ1dHRvbkNyb3NzQ29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjQwLCAxKVwiLFxuICAgIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC4zKVwiLFxuICAgIHNoYWRvd09mZnNldDogWzIsIDJdLFxuICAgIGJhY2tncm91bmQ6IFtbMCwgXCJyZ2JhKDMwLCAzMCwgMzAsIDAuNylcIl0sIFswLjUsIFwicmdiYSgzMCwgMzAsIDMwLCAwLjgpXCJdLCBbMC41LCBcInJnYmEoMTAsIDEwLCAxMCwgMC44KVwiXSwgWzEsIFwicmdiYSgxMCwgMTAsIDEwLCAwLjkpXCJdXVxuICB9LFxuICBhbGVydDoge1xuICAgIFwiZXh0ZW5kc1wiOiBcInN0YW5kYXJkXCIsXG4gICAgY2xhc3NOYW1lOiBcImFsZXJ0XCIsXG4gICAgYm9yZGVyUmFkaXVzOiAxLFxuICAgIGJvcmRlckNvbG9yOiBcIiNBRTBEMTFcIixcbiAgICBjbG9zZUJ1dHRvbkNyb3NzQ29sb3I6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAxKVwiLFxuICAgIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC4zKVwiLFxuICAgIHNoYWRvd09mZnNldDogWzIsIDJdLFxuICAgIGJhY2tncm91bmQ6IFtbMCwgXCJyZ2JhKDIwMywgMTUsIDE5LCAwLjcpXCJdLCBbMC41LCBcInJnYmEoMjAzLCAxNSwgMTksIDAuOClcIl0sIFswLjUsIFwicmdiYSgxODksIDE0LCAxOCwgMC44KVwiXSwgWzEsIFwicmdiYSgxNzksIDE0LCAxNywgMC45KVwiXV1cbiAgfVxufTtcblxuT3BlbnRpcC5kZWZhdWx0U3R5bGUgPSBcInN0YW5kYXJkXCI7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZSAhPT0gbnVsbCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IE9wZW50aXA7XG59IGVsc2Uge1xuICB3aW5kb3cuT3BlbnRpcCA9IE9wZW50aXA7XG59XG5cblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjQuMFxudmFyIF9fc2xpY2UgPSBbXS5zbGljZTtcblxuKGZ1bmN0aW9uKCQpIHtcbiAgdmFyIEFkYXB0ZXI7XG4gICQuZm4ub3BlbnRpcCA9IGZ1bmN0aW9uKGNvbnRlbnQsIHRpdGxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBPcGVudGlwKHRoaXMsIGNvbnRlbnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgfTtcbiAgQWRhcHRlciA9IChmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIEFkYXB0ZXIoKSB7fVxuXG4gICAgQWRhcHRlci5wcm90b3R5cGUubmFtZSA9IFwianF1ZXJ5XCI7XG5cbiAgICBBZGFwdGVyLnByb3RvdHlwZS5kb21SZWFkeSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gJChjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIEFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgIHJldHVybiAkKGh0bWwpO1xuICAgIH07XG5cbiAgICBBZGFwdGVyLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIGVsZW1lbnRzIHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cbiAgICBBZGFwdGVyLnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gJChlbGVtZW50KVswXTtcbiAgICB9O1xuXG4gICAgQWRhcHRlci5wcm90b3R5cGUudGFnTmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnVud3JhcChlbGVtZW50KS50YWdOYW1lO1xuICAgIH07XG5cbiAgICBBZGFwdGVyLnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncywgZWxlbWVudCwgX3JlZjtcbiAgICAgIGVsZW1lbnQgPSBhcmd1bWVudHNbMF0sIGFyZ3MgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuICAgICAgcmV0dXJuIChfcmVmID0gJChlbGVtZW50KSkuYXR0ci5hcHBseShfcmVmLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgQWRhcHRlci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MsIGVsZW1lbnQsIF9yZWY7XG4gICAgICBlbGVtZW50ID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICAgIHJldHVybiAoX3JlZiA9ICQoZWxlbWVudCkpLmRhdGEuYXBwbHkoX3JlZiwgYXJncyk7XG4gICAgfTtcblxuICAgIEFkYXB0ZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuICQoZWxlbWVudCkuZmluZChzZWxlY3RvcikuZ2V0KDApO1xuICAgIH07XG5cbiAgICBBZGFwdGVyLnByb3RvdHlwZS5maW5kQWxsID0gZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiAkKGVsZW1lbnQpLmZpbmQoc2VsZWN0b3IpO1xuICAgIH07XG5cbiAgICBBZGFwdGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihlbGVtZW50LCBjb250ZW50LCBlc2NhcGUpIHtcbiAgICAgIGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC50ZXh0KGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaHRtbChjb250ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWRhcHRlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oZWxlbWVudCwgY2hpbGQpIHtcbiAgICAgIHJldHVybiAkKGVsZW1lbnQpLmFwcGVuZChjaGlsZCk7XG4gICAgfTtcblxuICAgIEFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAkKGVsZW1lbnQpLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICBBZGFwdGVyLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuICQoZWxlbWVudCkuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9O1xuXG4gICAgQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiAkKGVsZW1lbnQpLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgfTtcblxuICAgIEFkYXB0ZXIucHJvdG90eXBlLmNzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiAkKGVsZW1lbnQpLmNzcyhwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgQWRhcHRlci5wcm90b3R5cGUuZGltZW5zaW9ucyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiAkKGVsZW1lbnQpLm91dGVyV2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0OiAkKGVsZW1lbnQpLm91dGVySGVpZ2h0KClcbiAgICAgIH07XG4gICAgfTtcblxuICAgIEFkYXB0ZXIucHJvdG90eXBlLnNjcm9sbE9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LCB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcF07XG4gICAgfTtcblxuICAgIEFkYXB0ZXIucHJvdG90eXBlLnZpZXdwb3J0RGltZW5zaW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBBZGFwdGVyLnByb3RvdHlwZS5tb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGUucGFnZVgsXG4gICAgICAgIHk6IGUucGFnZVlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIEFkYXB0ZXIucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAkKGVsZW1lbnQpLm9mZnNldCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQsXG4gICAgICAgIHRvcDogb2Zmc2V0LnRvcFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgQWRhcHRlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgb2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiAkKGVsZW1lbnQpLmJpbmQoZXZlbnROYW1lLCBvYnNlcnZlcik7XG4gICAgfTtcblxuICAgIEFkYXB0ZXIucHJvdG90eXBlLnN0b3BPYnNlcnZpbmcgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudE5hbWUsIG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gJChlbGVtZW50KS51bmJpbmQoZXZlbnROYW1lLCBvYnNlcnZlcik7XG4gICAgfTtcblxuICAgIEFkYXB0ZXIucHJvdG90eXBlLmFqYXggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgX3JlZiwgX3JlZjE7XG4gICAgICBpZiAob3B0aW9ucy51cmwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB1cmwgcHJvdmlkZWRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gJC5hamF4KHtcbiAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgICAgdHlwZTogKF9yZWYgPSAoX3JlZjEgPSBvcHRpb25zLm1ldGhvZCkgIT0gbnVsbCA/IF9yZWYxLnRvVXBwZXJDYXNlKCkgOiB2b2lkIDApICE9IG51bGwgPyBfcmVmIDogXCJHRVRcIlxuICAgICAgfSkuZG9uZShmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5vblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMub25TdWNjZXNzKGNvbnRlbnQpIDogdm9pZCAwO1xuICAgICAgfSkuZmFpbChmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5vbkVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLm9uRXJyb3IoXCJTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggc3RhdHVzIFwiICsgcmVxdWVzdC5zdGF0dXMpIDogdm9pZCAwO1xuICAgICAgfSkuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMub25Db21wbGV0ZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5vbkNvbXBsZXRlKCkgOiB2b2lkIDA7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgQWRhcHRlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgb2JqZWN0KTtcbiAgICB9O1xuXG4gICAgQWRhcHRlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlcywgdGFyZ2V0O1xuICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdLCBzb3VyY2VzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICAgIHJldHVybiAkLmV4dGVuZC5hcHBseSgkLCBbdGFyZ2V0XS5jb25jYXQoX19zbGljZS5jYWxsKHNvdXJjZXMpKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBBZGFwdGVyO1xuXG4gIH0pKCk7XG4gIHJldHVybiBPcGVudGlwLmFkZEFkYXB0ZXIobmV3IEFkYXB0ZXIpO1xufSkoalF1ZXJ5KTtcblxuXG4vLyBNb2RpZmllZCBieSBNYXRpYXMgTWVubyB0byB3b3JrIGluIElFOC5cbi8vIEkgcmVtb3ZlZCB0aGUgbGluZSAzMTIsIGFzIHByb3Bvc2VkIGJ5IHNvbWVvbmUgb24gdGhlIGdvb2dsZSBmb3J1bS5cblxuLy8gQ29weXJpZ2h0IDIwMDYgR29vZ2xlIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG5cbi8vIEtub3duIElzc3Vlczpcbi8vXG4vLyAqIFBhdHRlcm5zIGFyZSBub3QgaW1wbGVtZW50ZWQuXG4vLyAqIFJhZGlhbCBncmFkaWVudCBhcmUgbm90IGltcGxlbWVudGVkLiBUaGUgVk1MIHZlcnNpb24gb2YgdGhlc2UgbG9vayB2ZXJ5XG4vLyAgIGRpZmZlcmVudCBmcm9tIHRoZSBjYW52YXMgb25lLlxuLy8gKiBDbGlwcGluZyBwYXRocyBhcmUgbm90IGltcGxlbWVudGVkLlxuLy8gKiBDb29yZHNpemUuIFRoZSB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZSBoYXZlIGhpZ2hlciBwcmlvcml0eSB0aGFuIHRoZVxuLy8gICB3aWR0aCBhbmQgaGVpZ2h0IHN0eWxlIHZhbHVlcyB3aGljaCBpc24ndCBjb3JyZWN0LlxuLy8gKiBQYWludGluZyBtb2RlIGlzbid0IGltcGxlbWVudGVkLlxuLy8gKiBDYW52YXMgd2lkdGgvaGVpZ2h0IHNob3VsZCBpcyB1c2luZyBjb250ZW50LWJveCBieSBkZWZhdWx0LiBJRSBpblxuLy8gICBRdWlya3MgbW9kZSB3aWxsIGRyYXcgdGhlIGNhbnZhcyB1c2luZyBib3JkZXItYm94LiBFaXRoZXIgY2hhbmdlIHlvdXJcbi8vICAgZG9jdHlwZSB0byBIVE1MNVxuLy8gICAoaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay8jdGhlLWRvY3R5cGUpXG4vLyAgIG9yIHVzZSBCb3ggU2l6aW5nIEJlaGF2aW9yIGZyb20gV2ViRlhcbi8vICAgKGh0dHA6Ly93ZWJmeC5lYWUubmV0L2RodG1sL2JveHNpemluZy9ib3hzaXppbmcuaHRtbClcbi8vICogTm9uIHVuaWZvcm0gc2NhbGluZyBkb2VzIG5vdCBjb3JyZWN0bHkgc2NhbGUgc3Ryb2tlcy5cbi8vICogT3B0aW1pemUuIFRoZXJlIGlzIGFsd2F5cyByb29tIGZvciBzcGVlZCBpbXByb3ZlbWVudHMuXG5cbi8vIE9ubHkgYWRkIHRoaXMgY29kZSBpZiB3ZSBkbyBub3QgYWxyZWFkeSBoYXZlIGEgY2FudmFzIGltcGxlbWVudGF0aW9uXG5pZiAoIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQpIHtcblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIGFsaWFzIHNvbWUgZnVuY3Rpb25zIHRvIG1ha2UgKGNvbXBpbGVkKSBjb2RlIHNob3J0ZXJcbiAgdmFyIG0gPSBNYXRoO1xuICB2YXIgbXIgPSBtLnJvdW5kO1xuICB2YXIgbXMgPSBtLnNpbjtcbiAgdmFyIG1jID0gbS5jb3M7XG4gIHZhciBhYnMgPSBtLmFicztcbiAgdmFyIHNxcnQgPSBtLnNxcnQ7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIGZvciBzdWIgcGl4ZWwgcHJlY2lzaW9uXG4gIHZhciBaID0gMTA7XG4gIHZhciBaMiA9IFogLyAyO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bnRpb24gaXMgYXNzaWduZWQgdG8gdGhlIDxjYW52YXM+IGVsZW1lbnRzIGFzIGVsZW1lbnQuZ2V0Q29udGV4dCgpLlxuICAgKiBAdGhpcyB7SFRNTEVsZW1lbnR9XG4gICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF99XG4gICAqL1xuICBmdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRfIHx8XG4gICAgICAgICh0aGlzLmNvbnRleHRfID0gbmV3IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF8odGhpcykpO1xuICB9XG5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBCaW5kcyBhIGZ1bmN0aW9uIHRvIGFuIG9iamVjdC4gVGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHVzZSB0aGVcbiAgICogcGFzc2VkIGluIHtAY29kZSBvYmp9IGFzIHtAY29kZSB0aGlzfS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICBnID0gYmluZChmLCBvYmosIGEsIGIpXG4gICAqICAgZyhjLCBkKSAvLyB3aWxsIGRvIGYuY2FsbChvYmosIGEsIGIsIGMsIGQpXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRvIGJpbmQgdGhlIG9iamVjdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdGhhdCBzaG91bGQgYWN0IGFzIHRoaXMgd2hlbiB0aGUgZnVuY3Rpb25cbiAgICogICAgIGlzIGNhbGxlZFxuICAgKiBAcGFyYW0geyp9IHZhcl9hcmdzIFJlc3QgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAqICAgICBhcmd1bWVudHMgd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB0aGF0IGhhcyBib3VuZCB0aGlzXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kKGYsIG9iaiwgdmFyX2FyZ3MpIHtcbiAgICB2YXIgYSA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZi5hcHBseShvYmosIGEuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gIH1cblxuICB2YXIgR192bWxDYW52YXNNYW5hZ2VyXyA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihvcHRfZG9jKSB7XG4gICAgICBpZiAoL01TSUUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5vcGVyYSkge1xuICAgICAgICB2YXIgZG9jID0gb3B0X2RvYyB8fCBkb2N1bWVudDtcbiAgICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgZWxlbWVudCBzbyB0aGF0IElFIHdpbGwgYWxsb3cgY2FudmFzIGVsZW1lbnRzIHRvIGJlXG4gICAgICAgIC8vIHJlY29nbml6ZWQuXG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgZG9jLmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBiaW5kKHRoaXMuaW5pdF8sIHRoaXMsIGRvYykpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0XzogZnVuY3Rpb24oZG9jKSB7XG4gICAgICAvLyBjcmVhdGUgeG1sbnNcbiAgICAgIGlmICghZG9jLm5hbWVzcGFjZXNbJ2dfdm1sXyddKSB7XG4gICAgICAgIGRvYy5uYW1lc3BhY2VzLmFkZCgnZ192bWxfJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICcjZGVmYXVsdCNWTUwnKTtcblxuICAgICAgfVxuICAgICAgaWYgKCFkb2MubmFtZXNwYWNlc1snZ19vXyddKSB7XG4gICAgICAgIGRvYy5uYW1lc3BhY2VzLmFkZCgnZ19vXycsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpvZmZpY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJyNkZWZhdWx0I1ZNTCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXR1cCBkZWZhdWx0IENTUy4gIE9ubHkgYWRkIG9uZSBzdHlsZSBzaGVldCBwZXIgZG9jdW1lbnRcbiAgICAgIGlmICghZG9jLnN0eWxlU2hlZXRzWydleF9jYW52YXNfJ10pIHtcbiAgICAgICAgdmFyIHNzID0gZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKTtcbiAgICAgICAgc3Mub3duaW5nRWxlbWVudC5pZCA9ICdleF9jYW52YXNfJztcbiAgICAgICAgc3MuY3NzVGV4dCA9ICdjYW52YXN7ZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVuOycgK1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBzaXplIGlzIDMwMHgxNTAgaW4gR2Vja28gYW5kIE9wZXJhXG4gICAgICAgICAgICAndGV4dC1hbGlnbjpsZWZ0O3dpZHRoOjMwMHB4O2hlaWdodDoxNTBweH0nICtcbiAgICAgICAgICAgICdnX3ZtbF9cXFxcOip7YmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCl9JyArXG4gICAgICAgICAgICAnZ19vX1xcXFw6KntiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKX0nO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgYWxsIGNhbnZhcyBlbGVtZW50c1xuICAgICAgdmFyIGVscyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmluaXRFbGVtZW50KGVsc1tpXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBpbml0aWFsaXplcyBhIGNhbnZhcyBlbGVtZW50IHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgY2FudmFzXG4gICAgICogZWxlbWVudCBmcm9tIG5vdyBvbi4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBiZWZvcmUgdGhlIHBhZ2UgaXNcbiAgICAgKiBsb2FkZWQgYnV0IGlmIHlvdSBhcmUgY3JlYXRpbmcgZWxlbWVudHMgdXNpbmcgY3JlYXRlRWxlbWVudCB5b3UgbmVlZCB0b1xuICAgICAqIG1ha2Ugc3VyZSB0aGlzIGlzIGNhbGxlZCBvbiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgY2FudmFzIGVsZW1lbnQgdG8gaW5pdGlhbGl6ZS5cbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gdGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBpbml0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIGlmICghZWwuZ2V0Q29udGV4dCkge1xuXG4gICAgICAgIGVsLmdldENvbnRleHQgPSBnZXRDb250ZXh0O1xuXG4gICAgICAgIC8vIFJlbW92ZSBmYWxsYmFjayBjb250ZW50LiBUaGVyZSBpcyBubyB3YXkgdG8gaGlkZSB0ZXh0IG5vZGVzIHNvIHdlXG4gICAgICAgIC8vIGp1c3QgcmVtb3ZlIGFsbCBjaGlsZE5vZGVzLiBXZSBjb3VsZCBoaWRlIGFsbCBlbGVtZW50cyBhbmQgcmVtb3ZlXG4gICAgICAgIC8vIHRleHQgbm9kZXMgYnV0IHdobyByZWFsbHkgY2FyZXMgYWJvdXQgdGhlIGZhbGxiYWNrIGNvbnRlbnQuXG4gICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgIC8vIGRvIG5vdCB1c2UgaW5saW5lIGZ1bmN0aW9uIGJlY2F1c2UgdGhhdCB3aWxsIGxlYWsgbWVtb3J5XG4gICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgb25Qcm9wZXJ0eUNoYW5nZSk7XG4gICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbnJlc2l6ZScsIG9uUmVzaXplKTtcblxuICAgICAgICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzO1xuICAgICAgICBpZiAoYXR0cnMud2lkdGggJiYgYXR0cnMud2lkdGguc3BlY2lmaWVkKSB7XG4gICAgICAgICAgLy8gVE9ETzogdXNlIHJ1bnRpbWVTdHlsZSBhbmQgY29vcmRzaXplXG4gICAgICAgICAgLy8gZWwuZ2V0Q29udGV4dCgpLnNldFdpZHRoXyhhdHRycy53aWR0aC5ub2RlVmFsdWUpO1xuICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gYXR0cnMud2lkdGgubm9kZVZhbHVlICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC53aWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycy5oZWlnaHQgJiYgYXR0cnMuaGVpZ2h0LnNwZWNpZmllZCkge1xuICAgICAgICAgIC8vIFRPRE86IHVzZSBydW50aW1lU3R5bGUgYW5kIGNvb3Jkc2l6ZVxuICAgICAgICAgIC8vIGVsLmdldENvbnRleHQoKS5zZXRIZWlnaHRfKGF0dHJzLmhlaWdodC5ub2RlVmFsdWUpO1xuICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGF0dHJzLmhlaWdodC5ub2RlVmFsdWUgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsLmhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvL2VsLmdldENvbnRleHQoKS5zZXRDb29yZHNpemVfKClcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gb25Qcm9wZXJ0eUNoYW5nZShlKSB7XG4gICAgdmFyIGVsID0gZS5zcmNFbGVtZW50O1xuXG4gICAgc3dpdGNoIChlLnByb3BlcnR5TmFtZSkge1xuICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IGVsLmF0dHJpYnV0ZXMud2lkdGgubm9kZVZhbHVlICsgJ3B4JztcbiAgICAgICAgZWwuZ2V0Q29udGV4dCgpLmNsZWFyUmVjdCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGVsLmF0dHJpYnV0ZXMuaGVpZ2h0Lm5vZGVWYWx1ZSArICdweCc7XG4gICAgICAgIGVsLmdldENvbnRleHQoKS5jbGVhclJlY3QoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXNpemUoZSkge1xuICAgIHZhciBlbCA9IGUuc3JjRWxlbWVudDtcbiAgICBpZiAoZWwuZmlyc3RDaGlsZCkge1xuICAgICAgZWwuZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9ICBlbC5jbGllbnRXaWR0aCArICdweCc7XG4gICAgICBlbC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IGVsLmNsaWVudEhlaWdodCArICdweCc7XG4gICAgfVxuICB9XG5cbiAgR192bWxDYW52YXNNYW5hZ2VyXy5pbml0KCk7XG5cbiAgLy8gcHJlY29tcHV0ZSBcIjAwXCIgdG8gXCJGRlwiXG4gIHZhciBkZWMyaGV4ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgZGVjMmhleFtpICogMTYgKyBqXSA9IGkudG9TdHJpbmcoMTYpICsgai50b1N0cmluZygxNik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWF0cml4SWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFsxLCAwLCAwXSxcbiAgICAgIFswLCAxLCAwXSxcbiAgICAgIFswLCAwLCAxXVxuICAgIF07XG4gIH1cblxuICBmdW5jdGlvbiBtYXRyaXhNdWx0aXBseShtMSwgbTIpIHtcbiAgICB2YXIgcmVzdWx0ID0gY3JlYXRlTWF0cml4SWRlbnRpdHkoKTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgMzsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDM7IHkrKykge1xuICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IDM7IHorKykge1xuICAgICAgICAgIHN1bSArPSBtMVt4XVt6XSAqIG0yW3pdW3ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W3hdW3ldID0gc3VtO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY29weVN0YXRlKG8xLCBvMikge1xuICAgIG8yLmZpbGxTdHlsZSAgICAgPSBvMS5maWxsU3R5bGU7XG4gICAgbzIubGluZUNhcCAgICAgICA9IG8xLmxpbmVDYXA7XG4gICAgbzIubGluZUpvaW4gICAgICA9IG8xLmxpbmVKb2luO1xuICAgIG8yLmxpbmVXaWR0aCAgICAgPSBvMS5saW5lV2lkdGg7XG4gICAgbzIubWl0ZXJMaW1pdCAgICA9IG8xLm1pdGVyTGltaXQ7XG4gICAgbzIuc2hhZG93Qmx1ciAgICA9IG8xLnNoYWRvd0JsdXI7XG4gICAgbzIuc2hhZG93Q29sb3IgICA9IG8xLnNoYWRvd0NvbG9yO1xuICAgIG8yLnNoYWRvd09mZnNldFggPSBvMS5zaGFkb3dPZmZzZXRYO1xuICAgIG8yLnNoYWRvd09mZnNldFkgPSBvMS5zaGFkb3dPZmZzZXRZO1xuICAgIG8yLnN0cm9rZVN0eWxlICAgPSBvMS5zdHJva2VTdHlsZTtcbiAgICBvMi5nbG9iYWxBbHBoYSAgID0gbzEuZ2xvYmFsQWxwaGE7XG4gICAgbzIuYXJjU2NhbGVYXyAgICA9IG8xLmFyY1NjYWxlWF87XG4gICAgbzIuYXJjU2NhbGVZXyAgICA9IG8xLmFyY1NjYWxlWV87XG4gICAgbzIubGluZVNjYWxlXyAgICA9IG8xLmxpbmVTY2FsZV87XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzU3R5bGUoc3R5bGVTdHJpbmcpIHtcbiAgICB2YXIgc3RyLCBhbHBoYSA9IDE7XG5cbiAgICBzdHlsZVN0cmluZyA9IFN0cmluZyhzdHlsZVN0cmluZyk7XG4gICAgaWYgKHN0eWxlU3RyaW5nLnN1YnN0cmluZygwLCAzKSA9PSAncmdiJykge1xuICAgICAgdmFyIHN0YXJ0ID0gc3R5bGVTdHJpbmcuaW5kZXhPZignKCcsIDMpO1xuICAgICAgdmFyIGVuZCA9IHN0eWxlU3RyaW5nLmluZGV4T2YoJyknLCBzdGFydCArIDEpO1xuICAgICAgdmFyIGd1dHMgPSBzdHlsZVN0cmluZy5zdWJzdHJpbmcoc3RhcnQgKyAxLCBlbmQpLnNwbGl0KCcsJyk7XG5cbiAgICAgIHN0ciA9ICcjJztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBkZWMyaGV4W051bWJlcihndXRzW2ldKV07XG4gICAgICB9XG5cbiAgICAgIGlmIChndXRzLmxlbmd0aCA9PSA0ICYmIHN0eWxlU3RyaW5nLnN1YnN0cigzLCAxKSA9PSAnYScpIHtcbiAgICAgICAgYWxwaGEgPSBndXRzWzNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBzdHlsZVN0cmluZztcbiAgICB9XG5cbiAgICByZXR1cm4ge2NvbG9yOiBzdHIsIGFscGhhOiBhbHBoYX07XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzTGluZUNhcChsaW5lQ2FwKSB7XG4gICAgc3dpdGNoIChsaW5lQ2FwKSB7XG4gICAgICBjYXNlICdidXR0JzpcbiAgICAgICAgcmV0dXJuICdmbGF0JztcbiAgICAgIGNhc2UgJ3JvdW5kJzpcbiAgICAgICAgcmV0dXJuICdyb3VuZCc7XG4gICAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdzcXVhcmUnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIGludGVyZmFjZSBhcyBkZXNjcmliZWQgYnlcbiAgICogdGhlIFdIQVRXRy5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3VyZmFjZUVsZW1lbnQgVGhlIGVsZW1lbnQgdGhhdCB0aGUgMkQgY29udGV4dCBzaG91bGRcbiAgICogYmUgYXNzb2NpYXRlZCB3aXRoXG4gICAqL1xuICBmdW5jdGlvbiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRfKHN1cmZhY2VFbGVtZW50KSB7XG4gICAgdGhpcy5tXyA9IGNyZWF0ZU1hdHJpeElkZW50aXR5KCk7XG5cbiAgICB0aGlzLm1TdGFja18gPSBbXTtcbiAgICB0aGlzLmFTdGFja18gPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRQYXRoXyA9IFtdO1xuXG4gICAgLy8gQ2FudmFzIGNvbnRleHQgcHJvcGVydGllc1xuICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSAnIzAwMCc7XG4gICAgdGhpcy5maWxsU3R5bGUgPSAnIzAwMCc7XG5cbiAgICB0aGlzLmxpbmVXaWR0aCA9IDE7XG4gICAgdGhpcy5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgdGhpcy5saW5lQ2FwID0gJ2J1dHQnO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IFogKiAxO1xuICAgIHRoaXMuZ2xvYmFsQWxwaGEgPSAxO1xuICAgIHRoaXMuY2FudmFzID0gc3VyZmFjZUVsZW1lbnQ7XG5cbiAgICB2YXIgZWwgPSBzdXJmYWNlRWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLnN0eWxlLndpZHRoID0gIHN1cmZhY2VFbGVtZW50LmNsaWVudFdpZHRoICsgJ3B4JztcbiAgICBlbC5zdHlsZS5oZWlnaHQgPSBzdXJmYWNlRWxlbWVudC5jbGllbnRIZWlnaHQgKyAncHgnO1xuICAgIC8vIGVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHN1cmZhY2VFbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcblxuICAgIHRoaXMuZWxlbWVudF8gPSBlbDtcbiAgICB0aGlzLmFyY1NjYWxlWF8gPSAxO1xuICAgIHRoaXMuYXJjU2NhbGVZXyA9IDE7XG4gICAgdGhpcy5saW5lU2NhbGVfID0gMTtcbiAgfVxuXG4gIHZhciBjb250ZXh0UHJvdG90eXBlID0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXy5wcm90b3R5cGU7XG4gIGNvbnRleHRQcm90b3R5cGUuY2xlYXJSZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbGVtZW50Xy5pbm5lckhUTUwgPSAnJztcbiAgfTtcblxuICBjb250ZXh0UHJvdG90eXBlLmJlZ2luUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE86IEJyYW5jaCBjdXJyZW50IG1hdHJpeCBzbyB0aGF0IHNhdmUvcmVzdG9yZSBoYXMgbm8gZWZmZWN0XG4gICAgLy8gICAgICAgYXMgcGVyIHNhZmFyaSBkb2NzLlxuICAgIHRoaXMuY3VycmVudFBhdGhfID0gW107XG4gIH07XG5cbiAgY29udGV4dFByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbihhWCwgYVkpIHtcbiAgICB2YXIgcCA9IHRoaXMuZ2V0Q29vcmRzXyhhWCwgYVkpO1xuICAgIHRoaXMuY3VycmVudFBhdGhfLnB1c2goe3R5cGU6ICdtb3ZlVG8nLCB4OiBwLngsIHk6IHAueX0pO1xuICAgIHRoaXMuY3VycmVudFhfID0gcC54O1xuICAgIHRoaXMuY3VycmVudFlfID0gcC55O1xuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24oYVgsIGFZKSB7XG4gICAgdmFyIHAgPSB0aGlzLmdldENvb3Jkc18oYVgsIGFZKTtcbiAgICB0aGlzLmN1cnJlbnRQYXRoXy5wdXNoKHt0eXBlOiAnbGluZVRvJywgeDogcC54LCB5OiBwLnl9KTtcblxuICAgIHRoaXMuY3VycmVudFhfID0gcC54O1xuICAgIHRoaXMuY3VycmVudFlfID0gcC55O1xuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGFDUDF4LCBhQ1AxeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNQMngsIGFDUDJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhWCwgYVkpIHtcbiAgICB2YXIgcCA9IHRoaXMuZ2V0Q29vcmRzXyhhWCwgYVkpO1xuICAgIHZhciBjcDEgPSB0aGlzLmdldENvb3Jkc18oYUNQMXgsIGFDUDF5KTtcbiAgICB2YXIgY3AyID0gdGhpcy5nZXRDb29yZHNfKGFDUDJ4LCBhQ1AyeSk7XG4gICAgYmV6aWVyQ3VydmVUbyh0aGlzLCBjcDEsIGNwMiwgcCk7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGFscmVhZHkgZml4ZWQgY29yZGluYXRlcy5cbiAgZnVuY3Rpb24gYmV6aWVyQ3VydmVUbyhzZWxmLCBjcDEsIGNwMiwgcCkge1xuICAgIHNlbGYuY3VycmVudFBhdGhfLnB1c2goe1xuICAgICAgdHlwZTogJ2JlemllckN1cnZlVG8nLFxuICAgICAgY3AxeDogY3AxLngsXG4gICAgICBjcDF5OiBjcDEueSxcbiAgICAgIGNwMng6IGNwMi54LFxuICAgICAgY3AyeTogY3AyLnksXG4gICAgICB4OiBwLngsXG4gICAgICB5OiBwLnlcbiAgICB9KTtcbiAgICBzZWxmLmN1cnJlbnRYXyA9IHAueDtcbiAgICBzZWxmLmN1cnJlbnRZXyA9IHAueTtcbiAgfVxuXG4gIGNvbnRleHRQcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKGFDUHgsIGFDUHksIGFYLCBhWSkge1xuICAgIC8vIHRoZSBmb2xsb3dpbmcgaXMgbGlmdGVkIGFsbW9zdCBkaXJlY3RseSBmcm9tXG4gICAgLy8gaHR0cDovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL0NhbnZhc190dXRvcmlhbDpEcmF3aW5nX3NoYXBlc1xuXG4gICAgdmFyIGNwID0gdGhpcy5nZXRDb29yZHNfKGFDUHgsIGFDUHkpO1xuICAgIHZhciBwID0gdGhpcy5nZXRDb29yZHNfKGFYLCBhWSk7XG5cbiAgICB2YXIgY3AxID0ge1xuICAgICAgeDogdGhpcy5jdXJyZW50WF8gKyAyLjAgLyAzLjAgKiAoY3AueCAtIHRoaXMuY3VycmVudFhfKSxcbiAgICAgIHk6IHRoaXMuY3VycmVudFlfICsgMi4wIC8gMy4wICogKGNwLnkgLSB0aGlzLmN1cnJlbnRZXylcbiAgICB9O1xuICAgIHZhciBjcDIgPSB7XG4gICAgICB4OiBjcDEueCArIChwLnggLSB0aGlzLmN1cnJlbnRYXykgLyAzLjAsXG4gICAgICB5OiBjcDEueSArIChwLnkgLSB0aGlzLmN1cnJlbnRZXykgLyAzLjBcbiAgICB9O1xuXG4gICAgYmV6aWVyQ3VydmVUbyh0aGlzLCBjcDEsIGNwMiwgcCk7XG4gIH07XG5cbiAgY29udGV4dFByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbihhWCwgYVksIGFSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSkge1xuICAgIGFSYWRpdXMgKj0gWjtcbiAgICB2YXIgYXJjVHlwZSA9IGFDbG9ja3dpc2UgPyAnYXQnIDogJ3dhJztcblxuICAgIHZhciB4U3RhcnQgPSBhWCArIG1jKGFTdGFydEFuZ2xlKSAqIGFSYWRpdXMgLSBaMjtcbiAgICB2YXIgeVN0YXJ0ID0gYVkgKyBtcyhhU3RhcnRBbmdsZSkgKiBhUmFkaXVzIC0gWjI7XG5cbiAgICB2YXIgeEVuZCA9IGFYICsgbWMoYUVuZEFuZ2xlKSAqIGFSYWRpdXMgLSBaMjtcbiAgICB2YXIgeUVuZCA9IGFZICsgbXMoYUVuZEFuZ2xlKSAqIGFSYWRpdXMgLSBaMjtcblxuICAgIC8vIElFIHdvbid0IHJlbmRlciBhcmNoZXMgZHJhd24gY291bnRlciBjbG9ja3dpc2UgaWYgeFN0YXJ0ID09IHhFbmQuXG4gICAgaWYgKHhTdGFydCA9PSB4RW5kICYmICFhQ2xvY2t3aXNlKSB7XG4gICAgICB4U3RhcnQgKz0gMC4xMjU7IC8vIE9mZnNldCB4U3RhcnQgYnkgMS84MCBvZiBhIHBpeGVsLiBVc2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGluIGJpbmFyeVxuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5nZXRDb29yZHNfKGFYLCBhWSk7XG4gICAgdmFyIHBTdGFydCA9IHRoaXMuZ2V0Q29vcmRzXyh4U3RhcnQsIHlTdGFydCk7XG4gICAgdmFyIHBFbmQgPSB0aGlzLmdldENvb3Jkc18oeEVuZCwgeUVuZCk7XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoXy5wdXNoKHt0eXBlOiBhcmNUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBhUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgeFN0YXJ0OiBwU3RhcnQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHlTdGFydDogcFN0YXJ0LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB4RW5kOiBwRW5kLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB5RW5kOiBwRW5kLnl9KTtcblxuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKGFYLCBhWSwgYVdpZHRoLCBhSGVpZ2h0KSB7XG4gICAgdGhpcy5tb3ZlVG8oYVgsIGFZKTtcbiAgICB0aGlzLmxpbmVUbyhhWCArIGFXaWR0aCwgYVkpO1xuICAgIHRoaXMubGluZVRvKGFYICsgYVdpZHRoLCBhWSArIGFIZWlnaHQpO1xuICAgIHRoaXMubGluZVRvKGFYLCBhWSArIGFIZWlnaHQpO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgY29udGV4dFByb3RvdHlwZS5zdHJva2VSZWN0ID0gZnVuY3Rpb24oYVgsIGFZLCBhV2lkdGgsIGFIZWlnaHQpIHtcbiAgICB2YXIgb2xkUGF0aCA9IHRoaXMuY3VycmVudFBhdGhfO1xuICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICB0aGlzLm1vdmVUbyhhWCwgYVkpO1xuICAgIHRoaXMubGluZVRvKGFYICsgYVdpZHRoLCBhWSk7XG4gICAgdGhpcy5saW5lVG8oYVggKyBhV2lkdGgsIGFZICsgYUhlaWdodCk7XG4gICAgdGhpcy5saW5lVG8oYVgsIGFZICsgYUhlaWdodCk7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLnN0cm9rZSgpO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aF8gPSBvbGRQYXRoO1xuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUuZmlsbFJlY3QgPSBmdW5jdGlvbihhWCwgYVksIGFXaWR0aCwgYUhlaWdodCkge1xuICAgIHZhciBvbGRQYXRoID0gdGhpcy5jdXJyZW50UGF0aF87XG4gICAgdGhpcy5iZWdpblBhdGgoKTtcblxuICAgIHRoaXMubW92ZVRvKGFYLCBhWSk7XG4gICAgdGhpcy5saW5lVG8oYVggKyBhV2lkdGgsIGFZKTtcbiAgICB0aGlzLmxpbmVUbyhhWCArIGFXaWR0aCwgYVkgKyBhSGVpZ2h0KTtcbiAgICB0aGlzLmxpbmVUbyhhWCwgYVkgKyBhSGVpZ2h0KTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbCgpO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aF8gPSBvbGRQYXRoO1xuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUuY3JlYXRlTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbihhWDAsIGFZMCwgYVgxLCBhWTEpIHtcbiAgICB2YXIgZ3JhZGllbnQgPSBuZXcgQ2FudmFzR3JhZGllbnRfKCdncmFkaWVudCcpO1xuICAgIGdyYWRpZW50LngwXyA9IGFYMDtcbiAgICBncmFkaWVudC55MF8gPSBhWTA7XG4gICAgZ3JhZGllbnQueDFfID0gYVgxO1xuICAgIGdyYWRpZW50LnkxXyA9IGFZMTtcbiAgICByZXR1cm4gZ3JhZGllbnQ7XG4gIH07XG5cbiAgY29udGV4dFByb3RvdHlwZS5jcmVhdGVSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKGFYMCwgYVkwLCBhUjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhWDEsIGFZMSwgYVIxKSB7XG4gICAgdmFyIGdyYWRpZW50ID0gbmV3IENhbnZhc0dyYWRpZW50XygnZ3JhZGllbnRyYWRpYWwnKTtcbiAgICBncmFkaWVudC54MF8gPSBhWDA7XG4gICAgZ3JhZGllbnQueTBfID0gYVkwO1xuICAgIGdyYWRpZW50LnIwXyA9IGFSMDtcbiAgICBncmFkaWVudC54MV8gPSBhWDE7XG4gICAgZ3JhZGllbnQueTFfID0gYVkxO1xuICAgIGdyYWRpZW50LnIxXyA9IGFSMTtcbiAgICByZXR1cm4gZ3JhZGllbnQ7XG4gIH07XG5cbiAgY29udGV4dFByb3RvdHlwZS5kcmF3SW1hZ2UgPSBmdW5jdGlvbihpbWFnZSwgdmFyX2FyZ3MpIHtcbiAgICB2YXIgZHgsIGR5LCBkdywgZGgsIHN4LCBzeSwgc3csIHNoO1xuXG4gICAgLy8gdG8gZmluZCB0aGUgb3JpZ2luYWwgd2lkdGggd2Ugb3ZlcmlkZSB0aGUgd2lkdGggYW5kIGhlaWdodFxuICAgIHZhciBvbGRSdW50aW1lV2lkdGggPSBpbWFnZS5ydW50aW1lU3R5bGUud2lkdGg7XG4gICAgdmFyIG9sZFJ1bnRpbWVIZWlnaHQgPSBpbWFnZS5ydW50aW1lU3R5bGUuaGVpZ2h0O1xuICAgIGltYWdlLnJ1bnRpbWVTdHlsZS53aWR0aCA9ICdhdXRvJztcbiAgICBpbWFnZS5ydW50aW1lU3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuXG4gICAgLy8gZ2V0IHRoZSBvcmlnaW5hbCBzaXplXG4gICAgdmFyIHcgPSBpbWFnZS53aWR0aDtcbiAgICB2YXIgaCA9IGltYWdlLmhlaWdodDtcblxuICAgIC8vIGFuZCByZW1vdmUgb3ZlcmlkZXNcbiAgICBpbWFnZS5ydW50aW1lU3R5bGUud2lkdGggPSBvbGRSdW50aW1lV2lkdGg7XG4gICAgaW1hZ2UucnVudGltZVN0eWxlLmhlaWdodCA9IG9sZFJ1bnRpbWVIZWlnaHQ7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAzKSB7XG4gICAgICBkeCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGR5ID0gYXJndW1lbnRzWzJdO1xuICAgICAgc3ggPSBzeSA9IDA7XG4gICAgICBzdyA9IGR3ID0gdztcbiAgICAgIHNoID0gZGggPSBoO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSA1KSB7XG4gICAgICBkeCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGR5ID0gYXJndW1lbnRzWzJdO1xuICAgICAgZHcgPSBhcmd1bWVudHNbM107XG4gICAgICBkaCA9IGFyZ3VtZW50c1s0XTtcbiAgICAgIHN4ID0gc3kgPSAwO1xuICAgICAgc3cgPSB3O1xuICAgICAgc2ggPSBoO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSA5KSB7XG4gICAgICBzeCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHN5ID0gYXJndW1lbnRzWzJdO1xuICAgICAgc3cgPSBhcmd1bWVudHNbM107XG4gICAgICBzaCA9IGFyZ3VtZW50c1s0XTtcbiAgICAgIGR4ID0gYXJndW1lbnRzWzVdO1xuICAgICAgZHkgPSBhcmd1bWVudHNbNl07XG4gICAgICBkdyA9IGFyZ3VtZW50c1s3XTtcbiAgICAgIGRoID0gYXJndW1lbnRzWzhdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgdmFyIGQgPSB0aGlzLmdldENvb3Jkc18oZHgsIGR5KTtcblxuICAgIHZhciB3MiA9IHN3IC8gMjtcbiAgICB2YXIgaDIgPSBzaCAvIDI7XG5cbiAgICB2YXIgdm1sU3RyID0gW107XG5cbiAgICB2YXIgVyA9IDEwO1xuICAgIHZhciBIID0gMTA7XG5cbiAgICAvLyBGb3Igc29tZSByZWFzb24gdGhhdCBJJ3ZlIG5vdyBmb3Jnb3R0ZW4sIHVzaW5nIGRpdnMgZGlkbid0IHdvcmtcbiAgICB2bWxTdHIucHVzaCgnIDxnX3ZtbF86Z3JvdXAnLFxuICAgICAgICAgICAgICAgICcgY29vcmRzaXplPVwiJywgWiAqIFcsICcsJywgWiAqIEgsICdcIicsXG4gICAgICAgICAgICAgICAgJyBjb29yZG9yaWdpbj1cIjAsMFwiJyAsXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cIndpZHRoOicsIFcsICdweDtoZWlnaHQ6JywgSCwgJ3B4O3Bvc2l0aW9uOmFic29sdXRlOycpO1xuXG4gICAgLy8gSWYgZmlsdGVycyBhcmUgbmVjZXNzYXJ5IChyb3RhdGlvbiBleGlzdHMpLCBjcmVhdGUgdGhlbVxuICAgIC8vIGZpbHRlcnMgYXJlIGJvZy1zbG93LCBzbyBvbmx5IGNyZWF0ZSB0aGVtIGlmIGFiYnNvbHV0ZWx5IG5lY2Vzc2FyeVxuICAgIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgZG9lc24ndCBhY2NvdW50IGZvciBza2V3cyAod2hpY2ggZG9uJ3QgZXhpc3RcbiAgICAvLyBpbiB0aGUgY2FudmFzIHNwZWMgKHlldCkgYW55d2F5LlxuXG4gICAgaWYgKHRoaXMubV9bMF1bMF0gIT0gMSB8fCB0aGlzLm1fWzBdWzFdKSB7XG4gICAgICB2YXIgZmlsdGVyID0gW107XG5cbiAgICAgIC8vIE5vdGUgdGhlIDEyLzIxIHJldmVyc2FsXG4gICAgICBmaWx0ZXIucHVzaCgnTTExPScsIHRoaXMubV9bMF1bMF0sICcsJyxcbiAgICAgICAgICAgICAgICAgICdNMTI9JywgdGhpcy5tX1sxXVswXSwgJywnLFxuICAgICAgICAgICAgICAgICAgJ00yMT0nLCB0aGlzLm1fWzBdWzFdLCAnLCcsXG4gICAgICAgICAgICAgICAgICAnTTIyPScsIHRoaXMubV9bMV1bMV0sICcsJyxcbiAgICAgICAgICAgICAgICAgICdEeD0nLCBtcihkLnggLyBaKSwgJywnLFxuICAgICAgICAgICAgICAgICAgJ0R5PScsIG1yKGQueSAvIFopLCAnJyk7XG5cbiAgICAgIC8vIEJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbiAobmVlZCB0byBtaW5pbWl6ZSBkaXNwbGF5ZWQgYXJlYSBzbyB0aGF0XG4gICAgICAvLyBmaWx0ZXJzIGRvbid0IHdhc3RlIHRpbWUgb24gdW51c2VkIHBpeGVscy5cbiAgICAgIHZhciBtYXggPSBkO1xuICAgICAgdmFyIGMyID0gdGhpcy5nZXRDb29yZHNfKGR4ICsgZHcsIGR5KTtcbiAgICAgIHZhciBjMyA9IHRoaXMuZ2V0Q29vcmRzXyhkeCwgZHkgKyBkaCk7XG4gICAgICB2YXIgYzQgPSB0aGlzLmdldENvb3Jkc18oZHggKyBkdywgZHkgKyBkaCk7XG5cbiAgICAgIG1heC54ID0gbS5tYXgobWF4LngsIGMyLngsIGMzLngsIGM0LngpO1xuICAgICAgbWF4LnkgPSBtLm1heChtYXgueSwgYzIueSwgYzMueSwgYzQueSk7XG5cbiAgICAgIHZtbFN0ci5wdXNoKCdwYWRkaW5nOjAgJywgbXIobWF4LnggLyBaKSwgJ3B4ICcsIG1yKG1heC55IC8gWiksXG4gICAgICAgICAgICAgICAgICAncHggMDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeCgnLFxuICAgICAgICAgICAgICAgICAgZmlsdGVyLmpvaW4oJycpLCBcIiwgc2l6aW5nbWV0aG9kPSdjbGlwJyk7XCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZtbFN0ci5wdXNoKCd0b3A6JywgbXIoZC55IC8gWiksICdweDtsZWZ0OicsIG1yKGQueCAvIFopLCAncHg7Jyk7XG4gICAgfVxuXG4gICAgdm1sU3RyLnB1c2goJyBcIj4nICxcbiAgICAgICAgICAgICAgICAnPGdfdm1sXzppbWFnZSBzcmM9XCInLCBpbWFnZS5zcmMsICdcIicsXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cIndpZHRoOicsIFogKiBkdywgJ3B4OycsXG4gICAgICAgICAgICAgICAgJyBoZWlnaHQ6JywgWiAqIGRoLCAncHg7XCInLFxuICAgICAgICAgICAgICAgICcgY3JvcGxlZnQ9XCInLCBzeCAvIHcsICdcIicsXG4gICAgICAgICAgICAgICAgJyBjcm9wdG9wPVwiJywgc3kgLyBoLCAnXCInLFxuICAgICAgICAgICAgICAgICcgY3JvcHJpZ2h0PVwiJywgKHcgLSBzeCAtIHN3KSAvIHcsICdcIicsXG4gICAgICAgICAgICAgICAgJyBjcm9wYm90dG9tPVwiJywgKGggLSBzeSAtIHNoKSAvIGgsICdcIicsXG4gICAgICAgICAgICAgICAgJyAvPicsXG4gICAgICAgICAgICAgICAgJzwvZ192bWxfOmdyb3VwPicpO1xuXG4gICAgdGhpcy5lbGVtZW50Xy5pbnNlcnRBZGphY2VudEhUTUwoJ0JlZm9yZUVuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bWxTdHIuam9pbignJykpO1xuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUuc3Ryb2tlID0gZnVuY3Rpb24oYUZpbGwpIHtcbiAgICB2YXIgbGluZVN0ciA9IFtdO1xuICAgIHZhciBsaW5lT3BlbiA9IGZhbHNlO1xuICAgIHZhciBhID0gcHJvY2Vzc1N0eWxlKGFGaWxsID8gdGhpcy5maWxsU3R5bGUgOiB0aGlzLnN0cm9rZVN0eWxlKTtcbiAgICB2YXIgY29sb3IgPSBhLmNvbG9yO1xuICAgIHZhciBvcGFjaXR5ID0gYS5hbHBoYSAqIHRoaXMuZ2xvYmFsQWxwaGE7XG5cbiAgICB2YXIgVyA9IDEwO1xuICAgIHZhciBIID0gMTA7XG5cbiAgICBsaW5lU3RyLnB1c2goJzxnX3ZtbF86c2hhcGUnLFxuICAgICAgICAgICAgICAgICAnIGZpbGxlZD1cIicsICEhYUZpbGwsICdcIicsXG4gICAgICAgICAgICAgICAgICcgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDonLCBXLCAncHg7aGVpZ2h0OicsIEgsICdweDtcIicsXG4gICAgICAgICAgICAgICAgICcgY29vcmRvcmlnaW49XCIwIDBcIiBjb29yZHNpemU9XCInLCBaICogVywgJyAnLCBaICogSCwgJ1wiJyxcbiAgICAgICAgICAgICAgICAgJyBzdHJva2VkPVwiJywgIWFGaWxsLCAnXCInLFxuICAgICAgICAgICAgICAgICAnIHBhdGg9XCInKTtcblxuICAgIHZhciBuZXdTZXEgPSBmYWxzZTtcbiAgICB2YXIgbWluID0ge3g6IG51bGwsIHk6IG51bGx9O1xuICAgIHZhciBtYXggPSB7eDogbnVsbCwgeTogbnVsbH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY3VycmVudFBhdGhfLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuY3VycmVudFBhdGhfW2ldO1xuICAgICAgdmFyIGM7XG5cbiAgICAgIHN3aXRjaCAocC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdmVUbyc6XG4gICAgICAgICAgYyA9IHA7XG4gICAgICAgICAgbGluZVN0ci5wdXNoKCcgbSAnLCBtcihwLngpLCAnLCcsIG1yKHAueSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lVG8nOlxuICAgICAgICAgIGxpbmVTdHIucHVzaCgnIGwgJywgbXIocC54KSwgJywnLCBtcihwLnkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgIGxpbmVTdHIucHVzaCgnIHggJyk7XG4gICAgICAgICAgcCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JlemllckN1cnZlVG8nOlxuICAgICAgICAgIGxpbmVTdHIucHVzaCgnIGMgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgbXIocC5jcDF4KSwgJywnLCBtcihwLmNwMXkpLCAnLCcsXG4gICAgICAgICAgICAgICAgICAgICAgIG1yKHAuY3AyeCksICcsJywgbXIocC5jcDJ5KSwgJywnLFxuICAgICAgICAgICAgICAgICAgICAgICBtcihwLngpLCAnLCcsIG1yKHAueSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhdCc6XG4gICAgICAgIGNhc2UgJ3dhJzpcbiAgICAgICAgICBsaW5lU3RyLnB1c2goJyAnLCBwLnR5cGUsICcgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgbXIocC54IC0gdGhpcy5hcmNTY2FsZVhfICogcC5yYWRpdXMpLCAnLCcsXG4gICAgICAgICAgICAgICAgICAgICAgIG1yKHAueSAtIHRoaXMuYXJjU2NhbGVZXyAqIHAucmFkaXVzKSwgJyAnLFxuICAgICAgICAgICAgICAgICAgICAgICBtcihwLnggKyB0aGlzLmFyY1NjYWxlWF8gKiBwLnJhZGl1cyksICcsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgbXIocC55ICsgdGhpcy5hcmNTY2FsZVlfICogcC5yYWRpdXMpLCAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgIG1yKHAueFN0YXJ0KSwgJywnLCBtcihwLnlTdGFydCksICcgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgbXIocC54RW5kKSwgJywnLCBtcihwLnlFbmQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuXG4gICAgICAvLyBUT0RPOiBGb2xsb3dpbmcgaXMgYnJva2VuIGZvciBjdXJ2ZXMgZHVlIHRvXG4gICAgICAvLyAgICAgICBtb3ZlIHRvIHByb3BlciBwYXRocy5cblxuICAgICAgLy8gRmlndXJlIG91dCBkaW1lbnNpb25zIHNvIHdlIGNhbiBkbyBncmFkaWVudCBmaWxsc1xuICAgICAgLy8gcHJvcGVybHlcbiAgICAgIGlmIChwKSB7XG4gICAgICAgIGlmIChtaW4ueCA9PSBudWxsIHx8IHAueCA8IG1pbi54KSB7XG4gICAgICAgICAgbWluLnggPSBwLng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heC54ID09IG51bGwgfHwgcC54ID4gbWF4LngpIHtcbiAgICAgICAgICBtYXgueCA9IHAueDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluLnkgPT0gbnVsbCB8fCBwLnkgPCBtaW4ueSkge1xuICAgICAgICAgIG1pbi55ID0gcC55O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXgueSA9PSBudWxsIHx8IHAueSA+IG1heC55KSB7XG4gICAgICAgICAgbWF4LnkgPSBwLnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGluZVN0ci5wdXNoKCcgXCI+Jyk7XG5cbiAgICBpZiAoIWFGaWxsKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5saW5lU2NhbGVfICogdGhpcy5saW5lV2lkdGg7XG5cbiAgICAgIC8vIFZNTCBjYW5ub3QgY29ycmVjdGx5IHJlbmRlciBhIGxpbmUgaWYgdGhlIHdpZHRoIGlzIGxlc3MgdGhhbiAxcHguXG4gICAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIGRpbHV0ZSB0aGUgY29sb3IgdG8gbWFrZSB0aGUgbGluZSBsb29rIHRoaW5uZXIuXG4gICAgICBpZiAobGluZVdpZHRoIDwgMSkge1xuICAgICAgICBvcGFjaXR5ICo9IGxpbmVXaWR0aDtcbiAgICAgIH1cblxuICAgICAgbGluZVN0ci5wdXNoKFxuICAgICAgICAnPGdfdm1sXzpzdHJva2UnLFxuICAgICAgICAnIG9wYWNpdHk9XCInLCBvcGFjaXR5LCAnXCInLFxuICAgICAgICAnIGpvaW5zdHlsZT1cIicsIHRoaXMubGluZUpvaW4sICdcIicsXG4gICAgICAgICcgbWl0ZXJsaW1pdD1cIicsIHRoaXMubWl0ZXJMaW1pdCwgJ1wiJyxcbiAgICAgICAgJyBlbmRjYXA9XCInLCBwcm9jZXNzTGluZUNhcCh0aGlzLmxpbmVDYXApLCAnXCInLFxuICAgICAgICAnIHdlaWdodD1cIicsIGxpbmVXaWR0aCwgJ3B4XCInLFxuICAgICAgICAnIGNvbG9yPVwiJywgY29sb3IsICdcIiAvPidcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5maWxsU3R5bGUgPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBmaWxsU3R5bGUgPSB0aGlzLmZpbGxTdHlsZTtcbiAgICAgIHZhciBhbmdsZSA9IDA7XG4gICAgICB2YXIgZm9jdXMgPSB7eDogMCwgeTogMH07XG5cbiAgICAgIC8vIGFkZGl0aW9uYWwgb2Zmc2V0XG4gICAgICB2YXIgc2hpZnQgPSAwO1xuICAgICAgLy8gc2NhbGUgZmFjdG9yIGZvciBvZmZzZXRcbiAgICAgIHZhciBleHBhbnNpb24gPSAxO1xuXG4gICAgICBpZiAoZmlsbFN0eWxlLnR5cGVfID09ICdncmFkaWVudCcpIHtcbiAgICAgICAgdmFyIHgwID0gZmlsbFN0eWxlLngwXyAvIHRoaXMuYXJjU2NhbGVYXztcbiAgICAgICAgdmFyIHkwID0gZmlsbFN0eWxlLnkwXyAvIHRoaXMuYXJjU2NhbGVZXztcbiAgICAgICAgdmFyIHgxID0gZmlsbFN0eWxlLngxXyAvIHRoaXMuYXJjU2NhbGVYXztcbiAgICAgICAgdmFyIHkxID0gZmlsbFN0eWxlLnkxXyAvIHRoaXMuYXJjU2NhbGVZXztcbiAgICAgICAgdmFyIHAwID0gdGhpcy5nZXRDb29yZHNfKHgwLCB5MCk7XG4gICAgICAgIHZhciBwMSA9IHRoaXMuZ2V0Q29vcmRzXyh4MSwgeTEpO1xuICAgICAgICB2YXIgZHggPSBwMS54IC0gcDAueDtcbiAgICAgICAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG4gICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihkeCwgZHkpICogMTgwIC8gTWF0aC5QSTtcblxuICAgICAgICAvLyBUaGUgYW5nbGUgc2hvdWxkIGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci5cbiAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgIGFuZ2xlICs9IDM2MDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcnkgc21hbGwgYW5nbGVzIHByb2R1Y2UgYW4gdW5leHBlY3RlZCByZXN1bHQgYmVjYXVzZSB0aGV5IGFyZVxuICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gYSBzY2llbnRpZmljIG5vdGF0aW9uIHN0cmluZy5cbiAgICAgICAgaWYgKGFuZ2xlIDwgMWUtNikge1xuICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAwID0gdGhpcy5nZXRDb29yZHNfKGZpbGxTdHlsZS54MF8sIGZpbGxTdHlsZS55MF8pO1xuICAgICAgICB2YXIgd2lkdGggID0gbWF4LnggLSBtaW4ueDtcbiAgICAgICAgdmFyIGhlaWdodCA9IG1heC55IC0gbWluLnk7XG4gICAgICAgIGZvY3VzID0ge1xuICAgICAgICAgIHg6IChwMC54IC0gbWluLngpIC8gd2lkdGgsXG4gICAgICAgICAgeTogKHAwLnkgLSBtaW4ueSkgLyBoZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICB3aWR0aCAgLz0gdGhpcy5hcmNTY2FsZVhfICogWjtcbiAgICAgICAgaGVpZ2h0IC89IHRoaXMuYXJjU2NhbGVZXyAqIFo7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBtLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgc2hpZnQgPSAyICogZmlsbFN0eWxlLnIwXyAvIGRpbWVuc2lvbjtcbiAgICAgICAgZXhwYW5zaW9uID0gMiAqIGZpbGxTdHlsZS5yMV8gLyBkaW1lbnNpb24gLSBzaGlmdDtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgbmVlZCB0byBzb3J0IHRoZSBjb2xvciBzdG9wcyBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgb2Zmc2V0LFxuICAgICAgLy8gb3RoZXJ3aXNlIElFIHdvbid0IGludGVycHJldCBpdCBjb3JyZWN0bHkuXG4gICAgICB2YXIgc3RvcHMgPSBmaWxsU3R5bGUuY29sb3JzXztcbiAgICAgIHN0b3BzLnNvcnQoZnVuY3Rpb24oY3MxLCBjczIpIHtcbiAgICAgICAgcmV0dXJuIGNzMS5vZmZzZXQgLSBjczIub2Zmc2V0O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdG9wcy5sZW5ndGg7XG4gICAgICB2YXIgY29sb3IxID0gc3RvcHNbMF0uY29sb3I7XG4gICAgICB2YXIgY29sb3IyID0gc3RvcHNbbGVuZ3RoIC0gMV0uY29sb3I7XG4gICAgICB2YXIgb3BhY2l0eTEgPSBzdG9wc1swXS5hbHBoYSAqIHRoaXMuZ2xvYmFsQWxwaGE7XG4gICAgICB2YXIgb3BhY2l0eTIgPSBzdG9wc1tsZW5ndGggLSAxXS5hbHBoYSAqIHRoaXMuZ2xvYmFsQWxwaGE7XG5cbiAgICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgY29sb3JzLnB1c2goc3RvcC5vZmZzZXQgKiBleHBhbnNpb24gKyBzaGlmdCArICcgJyArIHN0b3AuY29sb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIGNvbG9ycyBhdHRyaWJ1dGUgaXMgdXNlZCwgdGhlIG1lYW5pbmdzIG9mIG9wYWNpdHkgYW5kIG86b3BhY2l0eTJcbiAgICAgIC8vIGFyZSByZXZlcnNlZC5cbiAgICAgIGxpbmVTdHIucHVzaCgnPGdfdm1sXzpmaWxsIHR5cGU9XCInLCBmaWxsU3R5bGUudHlwZV8sICdcIicsXG4gICAgICAgICAgICAgICAgICAgJyBtZXRob2Q9XCJub25lXCIgZm9jdXM9XCIxMDAlXCInLFxuICAgICAgICAgICAgICAgICAgICcgY29sb3I9XCInLCBjb2xvcjEsICdcIicsXG4gICAgICAgICAgICAgICAgICAgJyBjb2xvcjI9XCInLCBjb2xvcjIsICdcIicsXG4gICAgICAgICAgICAgICAgICAgJyBjb2xvcnM9XCInLCBjb2xvcnMuam9pbignLCcpLCAnXCInLFxuICAgICAgICAgICAgICAgICAgICcgb3BhY2l0eT1cIicsIG9wYWNpdHkyLCAnXCInLFxuICAgICAgICAgICAgICAgICAgICcgZ19vXzpvcGFjaXR5Mj1cIicsIG9wYWNpdHkxLCAnXCInLFxuICAgICAgICAgICAgICAgICAgICcgYW5nbGU9XCInLCBhbmdsZSwgJ1wiJyxcbiAgICAgICAgICAgICAgICAgICAnIGZvY3VzcG9zaXRpb249XCInLCBmb2N1cy54LCAnLCcsIGZvY3VzLnksICdcIiAvPicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lU3RyLnB1c2goJzxnX3ZtbF86ZmlsbCBjb2xvcj1cIicsIGNvbG9yLCAnXCIgb3BhY2l0eT1cIicsIG9wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgJ1wiIC8+Jyk7XG4gICAgfVxuXG4gICAgbGluZVN0ci5wdXNoKCc8L2dfdm1sXzpzaGFwZT4nKTtcblxuICAgIHRoaXMuZWxlbWVudF8uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVFbmQnLCBsaW5lU3RyLmpvaW4oJycpKTtcbiAgfTtcblxuICBjb250ZXh0UHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0cm9rZSh0cnVlKTtcbiAgfVxuXG4gIGNvbnRleHRQcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jdXJyZW50UGF0aF8ucHVzaCh7dHlwZTogJ2Nsb3NlJ30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udGV4dFByb3RvdHlwZS5nZXRDb29yZHNfID0gZnVuY3Rpb24oYVgsIGFZKSB7XG4gICAgdmFyIG0gPSB0aGlzLm1fO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBaICogKGFYICogbVswXVswXSArIGFZICogbVsxXVswXSArIG1bMl1bMF0pIC0gWjIsXG4gICAgICB5OiBaICogKGFYICogbVswXVsxXSArIGFZICogbVsxXVsxXSArIG1bMl1bMV0pIC0gWjJcbiAgICB9XG4gIH07XG5cbiAgY29udGV4dFByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBjb3B5U3RhdGUodGhpcywgbyk7XG4gICAgdGhpcy5hU3RhY2tfLnB1c2gobyk7XG4gICAgdGhpcy5tU3RhY2tfLnB1c2godGhpcy5tXyk7XG4gICAgdGhpcy5tXyA9IG1hdHJpeE11bHRpcGx5KGNyZWF0ZU1hdHJpeElkZW50aXR5KCksIHRoaXMubV8pO1xuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvcHlTdGF0ZSh0aGlzLmFTdGFja18ucG9wKCksIHRoaXMpO1xuICAgIHRoaXMubV8gPSB0aGlzLm1TdGFja18ucG9wKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF0cml4SXNGaW5pdGUobSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IDI7IGsrKykge1xuICAgICAgICBpZiAoIWlzRmluaXRlKG1bal1ba10pIHx8IGlzTmFOKG1bal1ba10pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TShjdHgsIG0sIHVwZGF0ZUxpbmVTY2FsZSkge1xuICAgIGlmICghbWF0cml4SXNGaW5pdGUobSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4Lm1fID0gbTtcblxuICAgIGlmICh1cGRhdGVMaW5lU2NhbGUpIHtcbiAgICAgIC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAgIC8vIERldGVybWluYW50IG9mIHRoaXMubV8gbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgICAvLyBmb3Igd2lkdGguXG4gICAgICB2YXIgZGV0ID0gbVswXVswXSAqIG1bMV1bMV0gLSBtWzBdWzFdICogbVsxXVswXTtcbiAgICAgIGN0eC5saW5lU2NhbGVfID0gc3FydChhYnMoZGV0KSk7XG4gICAgfVxuICB9XG5cbiAgY29udGV4dFByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbihhWCwgYVkpIHtcbiAgICB2YXIgbTEgPSBbXG4gICAgICBbMSwgIDAsICAwXSxcbiAgICAgIFswLCAgMSwgIDBdLFxuICAgICAgW2FYLCBhWSwgMV1cbiAgICBdO1xuXG4gICAgc2V0TSh0aGlzLCBtYXRyaXhNdWx0aXBseShtMSwgdGhpcy5tXyksIGZhbHNlKTtcbiAgfTtcblxuICBjb250ZXh0UHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKGFSb3QpIHtcbiAgICB2YXIgYyA9IG1jKGFSb3QpO1xuICAgIHZhciBzID0gbXMoYVJvdCk7XG5cbiAgICB2YXIgbTEgPSBbXG4gICAgICBbYywgIHMsIDBdLFxuICAgICAgWy1zLCBjLCAwXSxcbiAgICAgIFswLCAgMCwgMV1cbiAgICBdO1xuXG4gICAgc2V0TSh0aGlzLCBtYXRyaXhNdWx0aXBseShtMSwgdGhpcy5tXyksIGZhbHNlKTtcbiAgfTtcblxuICBjb250ZXh0UHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oYVgsIGFZKSB7XG4gICAgdGhpcy5hcmNTY2FsZVhfICo9IGFYO1xuICAgIHRoaXMuYXJjU2NhbGVZXyAqPSBhWTtcbiAgICB2YXIgbTEgPSBbXG4gICAgICBbYVgsIDAsICAwXSxcbiAgICAgIFswLCAgYVksIDBdLFxuICAgICAgWzAsICAwLCAgMV1cbiAgICBdO1xuXG4gICAgc2V0TSh0aGlzLCBtYXRyaXhNdWx0aXBseShtMSwgdGhpcy5tXyksIHRydWUpO1xuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpIHtcbiAgICB2YXIgbTEgPSBbXG4gICAgICBbbTExLCBtMTIsIDBdLFxuICAgICAgW20yMSwgbTIyLCAwXSxcbiAgICAgIFtkeCwgIGR5LCAgMV1cbiAgICBdO1xuXG4gICAgc2V0TSh0aGlzLCBtYXRyaXhNdWx0aXBseShtMSwgdGhpcy5tXyksIHRydWUpO1xuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpIHtcbiAgICB2YXIgbSA9IFtcbiAgICAgIFttMTEsIG0xMiwgMF0sXG4gICAgICBbbTIxLCBtMjIsIDBdLFxuICAgICAgW2R4LCAgZHksICAxXVxuICAgIF07XG5cbiAgICBzZXRNKHRoaXMsIG0sIHRydWUpO1xuICB9O1xuXG4gIC8qKioqKioqKiBTVFVCUyAqKioqKioqKi9cbiAgY29udGV4dFByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50XG4gIH07XG5cbiAgY29udGV4dFByb3RvdHlwZS5hcmNUbyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE86IEltcGxlbWVudFxuICB9O1xuXG4gIGNvbnRleHRQcm90b3R5cGUuY3JlYXRlUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgQ2FudmFzUGF0dGVybl87XG4gIH07XG5cbiAgLy8gR3JhZGllbnQgLyBQYXR0ZXJuIFN0dWJzXG4gIGZ1bmN0aW9uIENhbnZhc0dyYWRpZW50XyhhVHlwZSkge1xuICAgIHRoaXMudHlwZV8gPSBhVHlwZTtcbiAgICB0aGlzLngwXyA9IDA7XG4gICAgdGhpcy55MF8gPSAwO1xuICAgIHRoaXMucjBfID0gMDtcbiAgICB0aGlzLngxXyA9IDA7XG4gICAgdGhpcy55MV8gPSAwO1xuICAgIHRoaXMucjFfID0gMDtcbiAgICB0aGlzLmNvbG9yc18gPSBbXTtcbiAgfVxuXG4gIENhbnZhc0dyYWRpZW50Xy5wcm90b3R5cGUuYWRkQ29sb3JTdG9wID0gZnVuY3Rpb24oYU9mZnNldCwgYUNvbG9yKSB7XG4gICAgYUNvbG9yID0gcHJvY2Vzc1N0eWxlKGFDb2xvcik7XG4gICAgdGhpcy5jb2xvcnNfLnB1c2goe29mZnNldDogYU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGFDb2xvci5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgYWxwaGE6IGFDb2xvci5hbHBoYX0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENhbnZhc1BhdHRlcm5fKCkge31cblxuICAvLyBzZXQgdXAgZXh0ZXJuc1xuICBHX3ZtbENhbnZhc01hbmFnZXIgPSBHX3ZtbENhbnZhc01hbmFnZXJfO1xuICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRfO1xuICBDYW52YXNHcmFkaWVudCA9IENhbnZhc0dyYWRpZW50XztcbiAgQ2FudmFzUGF0dGVybiA9IENhbnZhc1BhdHRlcm5fO1xuXG59KSgpO1xuXG59IC8vIGlmIl19
